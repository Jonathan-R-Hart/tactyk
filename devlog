20 Jul 2023
  tactyk-doc
    Update documentation for 0.9.0 (for now, only a partial description of new features - it will need a closer examination since a lot has changed)
  
  tactyk-runtime
    Allow direct loading of programs [without a manifest file].
    So long as a raw program (.tkp file) does not need external modules or resources, this should suffice for basic experiments.
    This will replace the tactyk demo program (tdemo).
  
  tactyk-examples
    new example:  The obligatory "Hello, world!" program.  (examples/hello.tkp)
    
    updated: emit.tkp, fib.tkp, hello_sdl.tkp, julia.tkp
    
    removed:  lazy_quine.tkp 
      (lazy_quine does not DO anything particularly interesting, BUT it does require direct access to its own source code, 
       which is only permitted with the more complex program loading scheme -- that and real_quine would be extra work for not much gain...)

19 Jul 2023
  tactyk-core-memory
    load and store instructions - Move most code generation to a set of subroutines, with properties provided by the "word" typespec.

  tactyk-extras - png/deflate/code
    Replaced a lot of stash/data-register shuffling patterns with the new stash operations.
      TACTYK-PL no longer needs to resemble a programming puzzle just to implement non-trivial program.
  
  tactyk-pl - bus notation
    Added an alternative dataflow notation to tactyk-pl.  For lack of a better term, I'm calling it "bus notation".
    
    Bus notation is a table layout for subroutines.
    Each column represents a register or memory location (defined by an associated "bus header")
    Each row represents an instruction.
    Parameters into an instruction are represented with numeric "pins".
    The integer value of a pin specifies where within the list of parameters a given register or memory location is placed.
    
    The bus header is a directive which specifies which symbol each column maps onto.
    
    EXAMPLE:
      bus rF rE rD rC rB rA
      assign 23 ^ 1 . . . . . ^     # assign rF 23
      assign 54 ^ . . 1 . . . ^     # assign rD 54
      assign 1  ^ . . . . . 1 ^     # assign rA 1
      add       ^ 2 . . . 1 . ^     # add rB rF
      mul       ^ . . 2 . 1 . ^     # mul rB rD
      add       ^ . . . . 1 2 ^     # add rB rA
      add       ^ 1 . . . 2 . ^     # add rF rB
    
    Implementation details:
      There are no constraints on what symbols may be used to define a column - it can accept literals, functions, labels, etc (though this is only of limited use).
        (parameters specified in bus notation are subject to the same rules and restrictions as are in place everywhere else).
      The following characters are ignored [and thus may freely be used for any supplemental formatting]:  <>[](){} and SPACE
      The carat char ^ defines the boundaries of the bus-notation table.
      Symbols which are outside of the bus-notation table will inserted [in order] into the generated code in positions which are not referenced by the table.
        If there are not enough symbols to fill in all gaps, then the instruction will terminate at the first undefined position
        (even if there are bus-notation references to paramters farther out).
      Bus notation may freely be mixed with more conventional assembly-like notation (the bus header will remain valid until the next bus header is encountered).
    
    The main motivation for this is to try to better represent how a processor is being used
      (generic register names does not yield much insight, and setting descriptive aliases for them does not help much).

18 Jul 2023
  tactyk-core - stash ops
    Unify "stash-item-low" and "stash-item-high" typespecs
    Add a pair of typespecs for indicating a stash item shich should be interpreted as a floating point number
    Added variants of basic operations which operate on stash entries
      The stash is now treated like a bank of 64 data registers
      The variants primarilly use register-memory operations.
      This is expected to make TACTYK-PL a much more practical language (and much less like a programming pizzle)
      This is expected to improve performance (fewer explicit movement instructions are needed)
    Instructions affected:
      [simple_unary_instruction]: inc dec negate not
      [binary_instruction]: add sub
      [simple_binary_instruction]:  and or xor
      [shift]: shift-left shift-right rotate-left rotate-right
      [flow control]: goto lwcall if
      [others]: assign mul div sign abs reverse-bits
    planned/maybe variations:  load, store, block-load, block-store, block-assign, xassign, x-unary-op, x-binary-op, s-compute
    notable absense:  compute - this instruction already operates on stash items.
  
  tactyk-core - test (condition evaluation)
    replace direct immediate loading with indirect (temp register)
      (direct immedaite operand specification does not [at present] account for word size, so this causes incorrect ASM output when compiling)

  tactyk-extras - png/deflate/code
    begin refactoring (to make use of recently added tactyk features)

17 Jul 2023
  tactyk-extras - png
    Handle low bitrate images with odd sizes (bypass padding when loading images with bitrates 1,2,4)
    Handle multiple IDAT chunks
      The hackish method of overwriting PNG memory was employed, so attempting to load a PNG multiple times will fail (there is not much incentive to fix this).
  tactyk-extras - deflate
    Handle multiple deflate blocks.
    Allocate a 5th bit to the control table codeword size field (to ensure it can actually handle 16-bit codewords)
  
  The DEFLATE decompressor seems to be correctly identifying the stream terminals - the "pad" option was successfully removed from all images imports that used it.

15 Jul 2023
  tactyk-extras - deflate
    uncompressed block handler
    fix codelen-code repetition handling
      this one caused an obvious catastrophic failure due to a compressed data stream misread.
    fix lookup table setup
      The least significant bit was getting masked off on large table indices, causing a problem which initially was mistaken for a fencepost error.
    fix max codeword size
  tactyk-extras - code
    make lookup table size a configurable parameter
      This had no major impact, but the hard-coded value doesn't really belong.  Also took the opportunity to double it as I am not certain about what the largest
      codeword size is which might appear in a DEFLATE stream.
  tactyk-extras - png
    indexed color format (bitrates 1,2,4,8)
    48-bit rgb color format
    test and fix the average filter
    grayscale with alpha format (8 and 16 bit)
    truecolor with alpha format (8 and 16 bit)
    
    NOTES ON INTERLACING:
      Interlaced images are not endorsed, and for the time being, are not supported.  If interlaced images need to be loaded, the preferred solution is to re-encode.
      (Interlacing undermines compression, would requrie substantial code complexity, and are only meaningful if downloading images from the Internet).
  tactyk-extras - draw
    add a pixmap renderer which performs alpha blending
14 Jul 2023
  tactyk-core
    new instructions:  sign
      returns -1 if the register value is less than zero, returns 1 if the value is equal to or greater than zero
      Implmeneted in single-operand and two-operand form (the single-operand form transforms a value, the two-operand form preserves the value and assigns to anothe register)
    new instruction: abs
      returns the absolute value of the value on a register
      Implmeneted in single-operand and two-operand form (the single-operand form transforms a value, the two-operand form preserves the value and assigns to anothe register)
  
  tactyk-extras - PNG
    16-bit grEyscale.
    24-bit RGB
      As a side-effect of implementing this, an issue apparent only as one incorrect pixel in 16-bit grayscale handling was fixed (through greater clarity on how PNG filters are applied)

3-14 Jul 2023
  tactyk-extras - pixmap handling
    Revise the "GX.rect.fill" rasterizaer to leave more sensible values on the registers.
      (and more importantly, to leave relative X and Y coordinates on the registers)
    Added a "pixmap" sampler (nearest-neighbor only)
      This takes relative X and Y coordinates from a rasterizer and samples a pixmap (2D image with a 32-bit RGBA pixel format)
      and passes the sampled color to the next stage.
    Added a PNG image loader
      (and a DEFLATE de-compressor ... and a binary code evaluator, and mechanisms to configure it to recognize Canonical Huffman Code)
      It does not perform any sort of error checking and will produce grabage data (if anything) or induce a crash if the input is corrupt or unrecognized.
      And, most significantly:  It is implemented completely inside the TACTYK sandbox.
      Currently supported formats:
        1-bit greyscale
        2-bit grayscale
        4-bit greyscale
        8-bit grAyscale
        24-bit RGB
      
12 Jul 2023
  tactyk-core-bits - new instruction:  reverse-bits
    reverse bit order with bitwise opreators and bswap. 
    The second [optional] parameter specifies the size of the bitfield.
      (if specified, this reverses the least signfiicant bits and discards any out-of-bounds bits)

8 Jul 2023
  tactyk-runtime
    Add an option to append padding bytes to loaded files.

6 Jul 2023
  tactyk-extras - table
    Make the table data structures passable as a generic container format
    (move the table header to the 2nd entry use the first entry for a file header which indicates file type and specifies an optioanl supplemental data block)

4 Jul 2023
  tactyk-core-bits - new instruction:  bitcount

30 Jun 2023
  tactyk-core-bits - new instruction:  reverse-bytes
    Accepts a word size and input data register, transforms it by reversing byte order.
  tactyk-core
    Allow the use of branch targets as [integer] operands in simple two-argument instructions
29 Jun 2023
  tactyk-draw
    use registers rA and rB as absolute x and y coordinate outputs for rasterizer stage renderers
    add a function for clipping pixels outside of a specified rectangle
    
  tactyk-ui [basic]
    clip button/label text againts component boundary
    draw-all function

  bitmap-font renderer - fix incorrect transition to next bitmap row
  tactyk-emit
    bind the template selector (combined product of pick operators) to a local variable named "$TEMPLATE_SELECTOR"
  
  tactyk-core
    Add alternative typespecs which allow integers, integer constants, labels, and strings to be treated as the same type
    Make spread, block-assign, and xassign instructions more flexible about what types are accepted (and consolidate template selectors a bit)
    goto, lwcall, tcall, and ccall - augmented these flow-control instructions to optionally write constant-integer-type data to data registers prior to the flow-control transfer
      It is equivalent to prepending the flow-control instruction with "spread rA ...".
      This is intended to simplify a common pattern.
    store - allow direct storage of integer literals, integer constants, and strings to 8,16,32, and 64 bit memory locations, as well as floating point constants and literals to 32 or 64 bit memory locations
      Similarly motivated to do this in order to simplify common patterns (and to reduce register pressure)

26-28 Jun 2023
  tactyk-ui - A simple framework for setting up Graphical User Interface components.
    It tracks mouse activity and sends mouse-in, mouse-out, mouse-button-down, and mouse-button-up events to abstract components
    Components are generated and configured by calling the constructor, then writing data to the returned memblock
    based on the result of an abstract hit-test function
    There is no notion of layering or bubbling - all components which respond to the hit-test will receive the provoking mouse event.
  tactyk-basic-ui - Graphical User Interface components
    This is a basic implementation of tactyk-ui
    If provides a generic GUI component rendering function and constructor.
    basic-components are instantiated in the same way as the underlying components (actually just an extention of it)
    The generated componnet has a border color, border width, and background color (which may be defined per-state), and up to 50 text snippets.
    Each text snippet is independently positioned and colored, and can contain up to 64 aschii chars (or 64 bytes of unicode text).
    GUI components are drawn directly onto the framebuffer, and there is no notion of layering or depth (apart from draw order).
    A GUI components are also immediately redrawn when its internal state is changed (and will "pop" to the front if nothing else is drawn over before submitting the frame to SDL)
    All mouse events are captured and used to update the state.
      If a mouse-out event occurs, it will cancel the "pressed" state (and thus anything that responds to the mouse button release).
  
  aux-sdl - revise the "sdl_state" data structure
    Send both press and release events
    Transfer unicode value of pressed keyboard buttons
    
24 Jun 2023
  tactyk-emit - repeat operator
    This runs evaluates a subroutine an arbitrary number of times (specified with a V-ISA parameter)

  tactyk-bits - new instruction: lut-transform
    This instruction breaks up an input value into a set of chunks (1, 2, 4, 8, or 16 bits wide), performs a series of lookups using each chunk as an
      index into a lookup table, and combines values obtained from the lookup tables with a combiner function (add, and, or, xor), yielding the output
    Both the word-size of the chunk and the word-size of the lookup table entries must be specified 
      typically the chunk word size will be small, and the table entry wors size will be the maximum size (qword)
    A different table is used for each chunk
    The lookup tables must be a contiguous memblock [in little-endian chunk-order]
    Tables are indexed directly with chunk values
    Bounds checking is performed only once within the instruction (the memblock bounds must be large enough to contain a complete set of lookup tables)
    The memblock must also be offset to the location of the first lookup table within the set
    The main use of this is expected to be bitwise interleaving & de-interleaving and operations involving binary representations of color
    ADDENDUM:
      As an afterthought, an extra variant which operates on xmm registers has been added.
      This uses [64-bit] data & temp registers for control, but targets an an xmm register.
      Be default, this simply replicates the behavior of a data register destination/target
      BUT, if the xmm register operand is prepended with optional operand "x2", the width of the operation will be doubled
        the control register will use the same word sizes, but the values applied to the xmm register will be twice as wide as the control words
        (and the lookup tables will also need to be twice as large)
      For the time being, it has not been tested in any way.
      Known discrepencies:
        Due to limitations od sse (and no desire to insert extra steps to detect integer overflow and convert it to a carry) the "add" operator uses 64-bit integer addition. 
        128-bit addition would be somewhat preferable (for consistancy)
    
  tactyk-draw
    Initial revision of tactyk rendering to directly output 32-bit integer pixels (ABGR).
      removed the scratch buffer (it may be re-introduced strictly as one or more script-controlled buffers to be used in compositing operations)
      Removed the blend function.
      Remove value transfer functions (only meaningful in the context of said blend function)
      Everything else was handled by retargetting everything at the pixel buffer
      Remove other functions for supporting a complex rendering pipeline
      - Will probably pick a stash allocation and use that for data interchange between rendering components

  tactyk-extras
    Added a collection of bitwise interleaving transforms (extras/lib/bitwise-transforms/*)
    Each of these is a module which sets up a named memblock containing a series of lookup tables
    Each of these also contain a pair of comments demonstrating how to apply it.
    NOTE:  Testing of this data set and of the underlying lookup table transform was very limited 
           (typically only one transform from each module - and many of them using similar inputs)
    Added a new module for handling basic user-interface components

22 Jun 2023
tactyk-extras - bdf-extract / bmpfnt16x16
  Convert the interchange bitmap format to the format the renderer uses.
  The renderer was implemented after the extracter, so the requirements were not fully worked out at the time.
  The renderer format makes better use of space, supports a few additional features, and is intended to be extended at some point for used for 
    non-text bitmap rendering.
  The intermediate data storage format had to be expanded to include the code-point.
  It is intended that the new converter should clip leading and trailing emoty lines form bitmaps.  The clipping if leading empty lines works,
    but the code for clipping trailing empty lines fails and clips off the 16th line if it is present, and so has been disabled.

BACKTRACK NOTICE
Performance testing of tactyk-draw yielded the predictabley bad results (it at least would likely do alright if spread across many cores).
The results were expected (due to use of complex per-pixel calculations), though the unexpected result was that the "--perf" option did not 
significantly improve performance (though I still expect it to make a difference when handling large amounts of code).  I'm planning on setting aside the 
complex portions of the rendering pipeline and instead operating on RGBA pixels directly with integer/bitwise opretors (possibly also with a bit of SIMD).
I do plan on keeping most fo the rendering pipeline (in particular, the "rasterization" fucntions), as I have little reason at present to blame it for anything.

NOTE:  If/when I get around to implementing 3D rendering interface, that complex rendering pipeline is likely to come back in the form of shader and geometric primitive management (where it actually belongs).

21 Jun 2023
tactyk-runtime
  Added a "text" data-block directive - this places the contained text into a named datablock
    It is intended to be used for loading parameters into a tactyk program.

tactyk-extras
  Added a BDF font extractor utility
    Ostensibly, this was/is needed to support text rendering, but its *real* purpose was to guide the initial development
    of string processing and an associative array, as well as the backend functionality needed for an efficient implementation.
  Added a bitmap font renderer
    It is construction as a rasterizer, and thus only selects pixels and defers the production of color to other rendering opreations.
    Bitmap format is 1-bit / 16x28 in bitwise row-major order with little-endian bit-order
    It renders only a single line of up to 228 chars (with no corrections or accounting for bounds other than tactyk counds checking)
    It begins drawing text at a provided starting point, and accumulates per-glyph displacement vectors to trace the path text is to be rendered along
    Glyphs are additionally positioned in relation to the base position by an offset applied to the first row of pixels.
    Data extracted from GNU Unifont is used by the test code [and will likely be used as the builtin font] (http://unifoundry.com/unifont/)
  minstring
    Split ministring into a string reader component and a string handler
    Add a function for extracting unicode codepoints from a string
20 Jun 2023
tactyk-runtime
  catch invalid file references and report error.
  catch null or invalid data references and report them as errors

tactyk-core-memory - load
  Add the ability to load signed 8-bit, 16-bit, and 32-bit words onto data registers.
  Signed value loading is specified with keywords "sbyte", "sword", and "sdword"
    ("sqword" has been added for completeness, but there is no technical difference between signed and unsigned 64-bit integers)
  The implementation is a bit hackish [on account of x86-shennanigans]

tactyk-emit
  Report an error when NASM rejects the generated assembly code.
  I would also like to capture the error output, but attempts to redirect it to an error log caused it to vanish completely 
    (both by piping to a log file and by using NASM's a -Z option), so for now, unmodified stderr in a text terminal will have to suffice.
  Require subroutines invoked through the "sub" operator to report success

19 Jun 2023
tactyk-core - if
  Added bitwise operators "or", "and", "nor", and "nand"
  The "or" test combines the 'A' and 'B' arguments with a bitwise or, then evaluates to true if any result bits are set
  The "and" test  combines the 'A' and 'B' arguments with a bitwise and, then evaluates to true if any result bits are set
  The "nor" test combines the 'A' and 'B' arguments with a bitwise or, then evaluates to true if no result bits are set
  The "nand" test  combines the 'A' and 'B' arguments with a bitwise and, then evaluates to true if no result bits are set
  The bitwise opreators applies either to data registers or xmm registers [if a packed-integer type specification is provided]
  Changed the notation for xmm "all" modifier from a prepended '&' to surrounding square brackets
    the "all" modifier is an extra set of variants which evaluate to true only if the bitwise opreator evaluates to true for all 
    xmm packed fields.
  Added a collection of arithmetical comparators for packed floating point fields and another set for packed integer fields
    (comparators < <= == ~= >= > and packed types float-32x4, float-64x2, int32x4, and int64x2)
    The "all" modifier can be applied to these as well.

New instructions:  nop and skip
  "nop" is just a conventional no-op
  "skip" is a dummy instruction which is skipped over completely.
    The skip instruction causes extra references to the next valid instruction to be inserted into the global jump table.
    All labels prepended to a skip instruction target the next non-skip instruction
    Any computed gotos will jump straight to the next non-skip instruction
    This is to be used for aligning the global jump table (to help set up and switch statements / computed goto and make them equivalent)

New tactyk module - "bits"
  For bitwise operations
  New instruction:  find-bit <low/high> <destination> <source> <opt-branch>
    This returns the lowest or highest bit set on a data register
    Optionally, this also does a conditional jump (or a conditionally executes a code block) if the test value is non-zero.
  Moved conventional bitwise operators to the "bits" module (and or xor not shift/rotate)
  Moved the "simple_binary_instruction" subroutine to the "bits" module and merged the xmm extension into it
    (It is not presently used for anything but bitwise operators - other instructions which previously used it got switched to a more
     elaborate base)

17 Jun 2023
tactyk-emit
  New operator:  reset-template-selector
    This resets the tokens selected with "pick" opertor (and is intended to allow selecting and contatenating two or more templates)
  Subroutine arguments
    When explicitly invoking a subroutine ( "sub <subroutine-name>" ), any trailing tokens will be resolved (against local & global variables)
    and assigned to a set of local variables (format:  $arg.#)
    There is no concept of scope or stack within tactyk-visa/emit
      The variables will persist until either another subroutine is invoked (and will be replaced by a new set of arguments) or until the
      evaluation of the currnet instruction is complete.
  New operator:  default
    The "default" operator unconditionally runs its subordinate subroutine and indicates success 
      (causing select operator to also accept anything)
    This will prevent evaluation of any subsequent code within a selector subroutine, so if it represents a default case, it should be placed
      at the end of the selector subroutine.

tactyk-core
  restructured if - Transferred the conditional jump operator into the "test" subroutine.
  Formally declare temp registers, and make temp register cleanup optional
    This is accomplished by invoking a new subroutine named "tmp" and passing it a name (or common alias) for a temp register, then
      placing the text, "$RESET_TEMP" in the location in code where the temp register reset code should be inserted.
    In cases where the instruction resets the temp register on its own, or where the cleanup is impractical (such as a register-indirect jump),
      register declaration is not needed or desirable.
    Except for configuration, this is handled entirely through Virtual-ISA operations
    In general, it is recommented to declare temp registers immediately before the template which uses temp registers.
    In cases where temp register use is a bit more dynamic, it is acceptable to place it where the temp register is referenced
    The temp register subroutine deliberately ignores invalid references (for compatibility with immediate operand not-really-scrambling)
    Recognized temp register aliases:
      rTEMPA:  rTEMPA
      rTEMPC:  rTEMPC
      rTEMPD:  rTEMPD
      ra:      rTEMPA
      rc:      rTEMPC
      rd:      rTEMPD
      a:       rTEMPA
      c:       rTEMPC
      d:       rTEMPD
      xTEMPA:  xTEMPA
      xTEMPB:  xTEMPB
      xa:      xTEMPA
      xb:      xTEMPB
  Adjusted a few memory instructions to resist leaking address register content when temp register resetting is disabled 
    (or left temp register resets as-is where appropriate adjustment were not available)
  Adjusted vectorized instructions to use "vcode" directives exclusively
    (the original design of vcode too rigid, and was also visually ambiguous)
  New instruction - "block-assign"
    This loads a value or set of packed values onto every register within a register-group
    For data register groups, it can accept an integer literal, an integer constant, an 8-char string literal, a floating point literal, 
      a floating point constant, a data register, or an xmm register.
    For xmm register register groups, it can accept anything a data register can, but has additional functions for accepting packed data.
      It can accept two floating point literals, two floating point constants, two integer literals, two integer constants, two data registers, 
        or two xmm registers and convert it to the packed 64-bit floating point format [copied onto the entire register group].
      It can also accept four floating point literals, four floating point constants, four integer literals, four integer constants, four data
        registers, or four xmm registers and convert it to the packed 32-bit floating point format[copied onto the entire register group].

16 Jun 2023
tactyk-extras - table
  Added NANOTABLE and MEGATABLE variants
  Made register and stash allocations configurable (tactyk-runtime module loading)
  I was almost able to get the table size as a configuration option, but a the handling of nanotables differed enough to break the limited generic-ish system.
    (It was also making the code unreasonably harder to understand -- too many $pesos)

tactyk-emit
  Add options for enabling/disabling the experimental [and heavy-handed] security features
  
  Make aggressive binary executable randomization optional
    Jumps between adjacent instructions are now handled by the emit interface (and only inserted if the aggressive binary executable layout option is enabled)
    Added a "terminal" emit operator.  This marks an instruction as a "terminal" (always redicrects control flow).  Terminal instructions will always be ignored by
      "jump-to-next-isntruction" logic (it's an error if control flow makes it through such instructions, so maybe in the future, an option to insert instructions to
      terminate and throw an exception should be added).
    The automatically generated branch targets attached to each instruction are retained.
      (it is simpler that way, and they are still needed to enable some of the more advanced forms of control flow.  They also are not known to take up any extra space in the executable.)
  
  Make immediate operand scrambling optional
    Responsibility for injecting scrambling code into the output is now exclusively on V-ISA subroutines
      Specificially, the emit "scramble" operator now only provides the scrambled data thorugh variables and invokes the V-ISA scramble subroutine
      It is up to the scramble subroutine to reset its code and the operand subroutine to select and rename the scramble subroutine outputs,
      and the code template to accept the renamed outputs.
    All aspects of tactyk-core which either have formal test coverage or are used by new scripts have been reworded to use the newer, more flexible
      immediate operand handling.
    When immediate operand scrambling is enabled, it works the way it did previously
      (a random value and a difference are derived by the emit interface, and the scramble function accepts the derviced values and generates
       code which loads them onto a pair of temp registers and combines them with an xor instruction)
    When immediate operand scrambling is disabled, there are two schemes at play:
      In the simple case (when only an 8-32 bit value is needed as a proper immediate), it bypasses the temp register and places it directly
      in the x86 instruction as an immediate
      In the complex case (when eithe the immediate is a 64-bit value or when it simply needs to be on a temp register), then the value
        is loaded onto a temp register (the smae one that it would with scrambling).
  
  Make exopointers optional
    Nor much to this one - just a set of offsets applied to segment registers
  
  Make composite-instruction permutations optional
    For the time being, this only affects the unstructured stash instructions (specifically the order in which stash transfers are exeuted)  
  
  TACTYK has been steadilly gaining interesting features and qualities in other aspects
  It is starting to seem appropriate to think of tactyk as a general experiment in low-level scripting, and perhaps even as an alternative to Assembly Language.

tactyk-dblock - fixed a subtle table corruption error
  A random error was occuring in one of the tests - a named field wasn't getting picked up by the string interpolator, but changing a single char
  caused it to pick up the string (and pass the test).  Several hours later (after much tracing), an out-of-spec operation was found in the 
  table lookup function - specfically, it was an inappropriate check for "PSEUDO_NULL" (causing a retired table entry to be treated as an 
  empty entry, which causes rare data-dependent table lookup failures [would be a bit more common with denser tables]).

15 Jun 2023
tactyk-extras - table
  A TACTYK-PL component implementing an associative array
  This accepts 8-char keys (or 64-bit integers, if you prefer) and binds 64-bit integer values to them (or indices into an memblock)
  The internal data structure is a prefix trie -- which was selected mainly due to not needing any data beyond a memblock with a root node at position 0.
    (and it proved to very simple to implement)
  All of these tables are expected to uniquely resolve each key to a specific table entry
  Presently, there is only the "MINITABLE" variant has been implemented
    It offers a maximum of 65536 entries of storage, uses 3 key bits per lookup iteration, and has a worst-case lookup time of 22 iterations.
  There are plans to add a "MEGATABLE" (dword) variant with maximum table size of 2^32 (after implementing a table entry removal function)
  ... and possibly also a "NANOTABLE" (byte) variant that supports just 256 entries

tactyk-pl - add a basic preprocessor
  It scans tactyk-pl code for the presence of defined aliases, then replaces them with aliased values.
  This is intended to allow tactyk-pl register allocation to be configurable
  (With a bit of creativity, it should also be able to support generic programming -- though only through the script import procedure)

14 Jun 2023
tactyk-core - bitwise opreators (and or xor)
  Added templates for handling xmm registers to the basic bitwise operators
tactyk-core - if
  Add generic packed-xmm register type specifications
  Add typed xmm registers as recognizable arguments to the if instruction (no templates yet, and the specialized comparators will probably be limited in scope)
  Expanded the comparator type specification to include "any" and "all" hints for comparisons involving packed types.
  Added templates to 'if' for conditional jumps involving packed floating point and integer fields (32 and 64 bit floats, 8,16,32, and 64 bit integers, "any-pass" and "all-pass")
    Packed integer comparators needed specialized logic to synthesize the operations from eq and gt comparators and bitwise inversion

tactyk-core - new instruction: block-stash
  This is an alternative (and simpler and faster) stash instruction which transfers entire register groups in and out of the stash
  It works similarly to stash, in that it accepts a stash reference and a register, performs a transfer in or out of the stash depending on argument order,
    and optionally instead performs a swap if the "swap" keyword is present
  It also accepts an integer quanity specifying how wide the stash opreation shoudl be (defaults to maximum amount)
  And, like the block-load and block-store commands, it operates on register groups (consecutive registers by lexical ordering, with wraparound)
  Unlike the stash command, this does not permit stash-stash transfers, and it does not allow upper/lower halves of a 128-bit element to be targetted specifically
    Instead, all stash operations start at the lower element and affect entire entries (a complete data stash fills 3 stash entries, and a complete xmm stash fills 14)
  This should help to reinforce the concept for which the "microcontext" stash was named.

tactyk-extras - ministring
  A TACTYK-PL component for handling 8 and 16 char strings

13 Jun 2023
tactyk-core-simd - added instructions:  "xadd-interleaved", xsxub-interleaved", and "xsqrt"
  These functions accept one of two xmm register arguments and optionally may be vectorized further by prepending it with a quantity (like the other x-whatever instrucitons)
  the "interleaved" instructions are perform operations between adjacent values within a packed register ("horizontal" in SSE terminology)
  like multiplication and division operators are desirable, but they'll have to be synthesized from other packed instructions (shuffle + op).

tactyk-draw
  texture generation - "texture" within tactyk-draw is defined as any multiplicative combination of single-channel generators.
    These are initiated with the 'GX.texture' function, then any series ot texture functions are run, then the result is applied with a GX.transfer.<destination> function.
  Irregular Value Noise - First texture!  A value noise function based on distance drop-off.  It has an inefficient x87-based implementation, as well as a much more effiicent 
    SIMD implementation.

tactyk-runtime - Added a data export mechanism
  Data storage must be declared in the manifest file (a specific file name, maximum file length, and buffer name).
  When setting up the runtime, this adds an export target with a data buffer equal to the specified maximum file length, and makes it available through the "get-data" tcall function.
  The program may freely read and write to that buffer.
  To store the data, use "tcall export" while the export buffer is bound to addr1.  This will then measure the length of the data buffer [by scanning for the last non-zero byte],
    then write it to the file specified in the application manifest file.
  If your application needs to read the file back in [in a lsubsequent session],
    add a regular data buffer reference to the file [with a different buffer name] to the application manifest file.

12 Jun 2023
tactyk-core-math - add an exponentiation function to the compute instruction, as well as an equivalent exponentiation instruction.
  For the time being, these functions only work with positive base values, so negative numbers need to be handled correctly, wrap it and handle the sign/parity explicitly.

10 Jun 2023
tactyk-core - add a null pointer check to all dynamic memory access instructions
tactyk-emit - prevent the composite instruction handler from removing duplicates when not requested

9 Jun 2023
tactyk-draw - rendering pipeline
  A software rendering pipeline, modelled loosely on a conventional GPU rendering pipeline.
  It will break GPU conventions in at least two ways:
    Rasterization shader support
    Shaders with read+write access to the output buffer

tactyk-core-simd
  Add a pack instruction template for taking values from data registers
  Add an unpack instruction template for unpacking to data registers
  
8 Jun 2023
tactyk-simd - new instructions: x-and, x-or, x-xor
  These are based on the "x-binary-op" subroutine (and thus aren't particularly noteworthy for test coverage).
  x86_64/sse4 does not come with scalar instructions the x-binary-op subroutine wants to use (andsd, andss, orsd, orss, xorsd, xorss), so for a simple workaround, 
    a set of aliases have been added to the main assembly header which map said non-existent isntructions onto the packed instuctions.
  The motivation was to hack in an easy floating point absolute value function, but vectorized bitwise operators are very much a welcome addition to tactyk-core.

Begin development of a 2D rendering & GUI framefork ("tactyk-draw")
  This is a TACTYK-PL project.  It will run in the new standalone runtime.  It will render to a framebuffer and use SDL, both for displaying video output and for obtaining events.
  It will also use a formal rendering pipeline to produce graphics.

aux-printit - add a set of functions for printing long-double values from the stash

Add option to aux-sdl to choose whether to use a "flat" array format or an "element" array format for framebuffers and scratchbuffer
  The "flat" format represents the buffer as a simple byte array
    The flat buffer requires a complete offset be computed for all access
  The "element" format represents the buffer as an array of objects
    The element buffer format requires the address offset to be applied separately to the memblock each time a different "object" within it is accessed
  (It might be worthwhile to consider adding a tactyk function to dynamiclaly set a memblock format)

Use the word size used by the adress offset setter template

6-7 Jun 2023
Added a minimal tactyk runtime + components.
  Not much to it - just a mechanism for loading data from files, program code, and defining an entry point, and accessing loaded data from tactyk

Upgrade the status of the aux-sdl component (from test code to an actual auxilliary library component)
  Switch to dynamic memory binding (simplifies setup)
  Add a "scratch" buffer (not really an SDL thing, but should help with specialized rendering code)
  Add an OpenGL flag to the SDL window (eventually, a 3D rendering interface based on OpenGL is to be included)

tactyk-core - Add templates for making dynamic lwcalls (referencing jump targets by register or by integer literal/constant)

5 Jun 2023 [0.9.0]
Add a mechanism for defining code blocks.
Code blocks [at the V-ISA level] are defined as a set of labels which are accessible from templates
  These labels are visible to "child" instructions
    $CODEBLOCK_HEADER - branch target referencing the parent instruction
    $CODEBLOCK_FIRST  - branch target referencing the first instruction within the parent code block
    $CODEBLOCK_CLOSE  - branch target referencing the next instruction in the parent code block.
  These labels are visible to the "parent" instructions
    $CODEBLOCK_CHILD_HEADER - branch target self-reference
    $CODEBLOCK_CHILD_FIRST  - branch target referencing the first instruction within the child code block
    $CODEBLOCK_CHILD_CLOSE  - branch target referencing the next instruction within the current block

Due to 'discovered' functionality, the extensive rewrite of the "if" instruction tests can be de-prioritized! 
  (the conversion was accomplished by overriding branch target variables)
  There was a plan to implement chained control-flow structures (if-elif-...-else), but it was cancelled due to
    requiring dynamic instruction insertion.

Reset the x87 FPU on context switch
Also decided that x87 stack content left over after compute operation is underfined behavior.
  (might consider a complete fpu reset at the end of compute instructions if the unchecked-ness of the matter is considered too bothersome)

Add a mechanism for obtaining a dynamic reference to labels (branch targets)
  added internal "label-index" symbol table + typespec
  added the label-index typespec to assign operator
  added a template alias to assign operator ['load constant onto register' template]

Add dynamic branch templates to the goto instruction
  Dynamic branching jumps to specific instructions (by indexing an opaque global jump table which maps all instructions onto positions in the assembly)
  A label reference may be obtained by assigning it to a data register, then offset by adding or subtracting integer values  to/from it.
  It might be worthwhile to add a set of templates to the 'if' instruction, but that would be a lot of extra junk to test, and the real value of this is with 
    the goto instruction (for implementing jump tables).

5 Jun 2023 [0.8.1]
tactyk-emit now produces detailed error reports when instruction interpretation fails.
The most common errors are expected to be unrecognized operands, unrecognized instructions, and missing templates, which should be fairly easy to recognize.
Other more complex issues are expected to need the other parts of the report to puzzle out (particularly if/when the problem is caused by hackish use of Virtual-ISA features).

Example error report  (generated by using invalid argument 'rG' with a stash command)
    ERROR-REPORT
    ------------
    COMMAND: stash sAl rD sBl rG
    INDEX: 0
    LABEL: lbl#MAIN
    >: instruction stash
    COMPOSITE-EVALUATOR
      OPT-OPERAND: sAl
        resolved: sAl
        opt-reject
      OPERAND: sAl
        resolved: sAl
        TYPE-accept: stash-item-low
        [assign] $DEST: al
      OPERAND: rD
        resolved: rD
        TYPE-accept: data
        [assign] $SRC: rD
      SELECT-TEMPLATE: SilD
        CODE-TEMPLATE:
            mov gs:[microcontext.$DEST+random_const_GS], $SRC
        CODE-GENERATED:
            mov gs:[microcontext.al+random_const_GS], rD
      OPT-OPERAND: sBl
        resolved: sBl
        opt-reject
      OPERAND: sBl
        resolved: sBl
        TYPE-accept: stash-item-low
        [assign] $DEST: bl
      OPERAND: rG
        resolved: rG
        type-all-rejected: data xmmx stash-item stash-item-low stash-item-high 

    LOCAL VARIABLES:
      $COMMAND_INDEX: 0
      $RESOLVED_OPERAND: rG
      $VALUE: [[ NULL ]]
      $COMMAND_INDEX_NEXT: 1
      $SRC: rD

    Composite instruction - failed to handle all arguments: stash sAl rD sBl rG

3 Jun 2023
Begin development of a new error and warning reporting interface.
  This is intended to simplify code for reporting errors, to make error reports clearer, and to enable advancement beyond simple Console-based execution environments.
  The new error reporting system is to be a detailed log which is kept in memory.
  The error report is to be filled with detailed information on how TACTYK responds to a single line of input code.
  If a fatal error is observed, the error log will be published.
  If the line of code is accepted and successfully converted to assembly language, then the error report will be erased.
  As the current TACTYK implementation is a prototype, so there is no plan to make error reporting optional
    If TACTYK draws wider interest, then the error reporting system shoudl be turned into a compiler option (for performance reasons)

2 Jun 2023 [version 0.8.0]
compute instruction adjustments
  revised code generation
  proper names and common abbreviated names for all operators
  swap internal argument order of swap and mod operations
  Add ~atan and ~mod operators (these omit said argument swap)
  add log-base-N operators (and the swapped operand form)
  
  tactyk-emit - add a "new" modifer to the code operator
    The "new" modifier causes it to create a new code block instead of appending to an existing one.
    (This eliminates need for certain V-ISA hacks)

1 Jun 2023
Add "compute" instruction
  This is an instruction comparable to "xcompute" which uses high-precision floating point operations (x87 fpu)
  It is loosely similar to xcompute, in that it allows an arbitrary sequence of operators which are evaluated from left to right and which passively applies a mathematical operator
    for each value or referenced register.
  It accepts xmm registers, data registers, constants, and stash entries
  It does not include a mechanism for accessing xmm packed field slots (That's a "MAYBE" feature)
  It is able to access up to 4 transient variables on the FPU stack (used for complex calculations, does not persist beyond the end of the instruction)

Documentation for "Super-SIMD" instructions and "xmm-fpmath" instructions

Update "tactyk-core" documentation to cover block-load and block-store instructions

tactyk-test - Add checks for 64-bit and 80-bit floating point values in the stash test.

31 May 2023
Add matrix inversion function to the matrix-simd example

Reinstate "round" conversion mode (and force it).
Use truncating conversion instructions for converting floating point numbers to integers.

30 May 2023
Add "xcompute" instruction
  4-function calculator
  This accepts an arbitrary list of arithmetic functions, constants, data registers, xmm registers, and packed xmm register slots (32-bit and 64-bit floating point formats)
  and generates an instruction which evaluates list items from left to right.
  For each value in the list, it applies the active arithmetic function using the value as the 2nd operand (and the accumulated balue as the 1st)
  If it encounters an arithmetic function, it uses it as the active function (starts with addition).
  This is intended to be a straightforward mechanism for simple calculations.
  sub-instruction list:
    add - set the active function to add
    sub - set the active function to subtract
    mul - set the active function to multiply
    div - set the active function to divide
    ~sub - set the active function to subtract with reversed operand order
    ~div - set the active function to divide with reversed operand order
    <register> - load a register value and apply the active function
    <int float int-const float-const> load a constant and apply the active function
    <xmm-register>.<fmt>.<index> load a value from an xmm register containind packed fields and apply the active function
  NOTE:  this instruciton partially violates one of the arguably paranoid security constraints - it produces a contiguous chunk of executable bytes with a 
         higher level of script influence than most (or all) other instructions, and so may need to be omitted in maximally paranoid modes 
         (or rewritten to insert extra junk).
  NOTE 2: This might seem misclassified as a "simd" instruction, its placement has more to do with its ability to handle packed fields (and thus to augment actual SIMD code)
         If at some point, the underlying instruction extender is improved to handle more complex situations, it may be reclassified, renamed to "compute", and have the
         packed field handling moved to a separate module (variable-length parameter list with parameter handlers that affect subsequent parameter handlers)

Add "shuffle" instruction
This rearranges the packed 32-bit fields on a register
  For now, only 32-bit fields are supported.  At some future time, this is to be extended to include variants for 8,16, and 64 bit packed fields.

29 May 2023
Add a matrix transformation example using the new SIMD instructions
  It packs the entire matrix onto 4 xmm registers (using the 32-bit packed floating point format)
  It does not rely on either the stash or a memblock
  It does not modify registers used for inputs (thoguh it does use a bit of hackery to handle the perspective transform).

26-27 May 2023
test coverage for xadd (packed 64-bit target functions)
  For the time being, I'm going to make a lot of presumptions and allow the "xadd" test to also stand in as a test of xsub, xmul, xdiv, xmin, and xmax
  This should suffice as an assurance that TACTYK is generating correct code (but does not actually verify that the system is producing correct results)
  
tactyk-test - Reduce precision of 32-bit floating point tests a bit more

Remove instruction xsqrt.  "square-root" (the x87 fpu one) should suffice for now.  
  (Will probably reconsider this if/when there is a decision to add a collection of math functions using SSE instructions)

tactyk-core-math - add dot product and cross product instructions, move transpose function to math module

tactyk-code-simd - "xduplicate" instruction - this copies up to 7 xmm registers from a source xmm register to a destination xmm register
  to a destination position (based on lexical ordering).

25 May 2023
Expand xassign
  templates for assigning directly setting all fields fields
  Typing is implicit:
    xmm-dest + Two integers -> packed 64-bit integers
    xmm-dest + Two data registers -> packed 64-bit integers
    xmm-dest + Four integers -> packed 32-bit integers
    xmm-dest + Four data registers -> packed 32-bit integers
    xmm-dest + Two floating point numbers -> packed 64-bit floats
    xmm-dest + Two xmm registers ->  packed 64-bit floats
    xmm-dest + Four floating point numbers -> packed 32-bit floats
    xmm-dest + Four xmm registers ->  packed 32-bit floats
  Integers and integer-constants are integerchangable
  Likewise, floating point numbers and floating point constants are interchangeable
  floating point numbers can not be mixed with integers for this (xassign configuration is heavy enough already)
  NOTE:  floating point numbers are differentiated from integers by the presence of a decimal point. 

24 May 2023
Complete xassign test coverage
remove insert and extract instructions, revise tests to use xassign

Add a matrix transposition instruction: "transpose"
  This accepts a 4x4 matrix (encoded as packed 32-bit values arranged on xmm registers [in lexical order]) and applies an in-place tranposition to its input.
    (flip between row-major and column-major order)
  This is expected to be a fairly common operation needed by secondary optimizations (mainly handling of 3d matrix transformations)

SUPER SIMD!
  This is a large collection of "vectorized" SIMD-based operations
  These instructions apply simd operations to sets of XMM registers (and may be thought of as SIMD on a larger scale than x86-sse extensions offer).
    The larger scale is basically intended to help math-heavy programs overcome some of the performance penalties incurred by tactyk binary executable randomization
  These instructions accept many formats (and internally apply conversions to match the output)
  Instructions: are as follows:
    xadd, xsub, xmul, xdiv, xmin, and xmax (basically the xmm floating point opreators)
  TODO:  Integer operations.

23 May 2023
tactyk-test - add an explitic text exit function
  This terminates a test script early (and is intended only as a to help repurposing test scripts)

xassign - ensure implicitly typed (float-64) assignment to xmm register clears upper bytes

xassign test coverge
  xassign is a very complex operator.
  Complete test coverage would require several hundred thousand usage, so some aspects of it may have to be deferred.
    This is mostly on account of a combinatorial explosion from static-indirect transfers between slots, particularly when handling small words.
    However, this is mostly combinations of parameters generated by a Python script and copied into the V-ISA configuration.

Use a declared data structure for context state management (both native and tactyk)

new instruction: "float-to-int--cast-mode"
  This sets flags which control which operation float-to-int conversion functions perform
  functions are:  "truncate" (default), "round", "round-down", and "round-up"

22 May 2023
tactyk-visa - add a generic selector
  This uses string interpolation (against local variables) to generate the select token.

More simd refactoring
  simd handling is to expand on the concept of polymorphism and vectorized operations based on register lexical orderings.

new instruction:  "xassign"
  xassign is intended to partly to supersede/replace extract & insert, and partly to test static xmm packed element indirection
    static xmm packed element indirection essentially allows the entire xmm register file to be treated as a semi-circular array of 8/16/32/64 bit items.
    Individual items are referenced as a register, a data type, and an integer offset.
    The offset is divided by the number of elements per register
      The resulting integer part is used to select another register [based on the lexical ordering of xmm register aliases].
      The resulting remainder is used to index the packed word within the selected register.
    This is intended to help simplify tactyk scripts, especially when setting up vectorized/simd logic

20 May 2023
Add templates to load, store, block-load, block-store instructions for handling [full] 128-bit xmm fields.
  Add test coverage for the new variants

Refactor simd handling
  Added a large "simd-format" typespec to encode various sse/mmx idiosyncrasies
  pack-float32 and pack-int32 merged into a general "pack" instruction
  unpack-float32 and unpack-int32 merged into a general "pack" instruction
  Revise insert and extract instructions to use simd-format

19 May 2023
test coverage for insert and extract instructions

tactyk-test - refactor and extend the xmm register test function.
  It now works with 32-bit fields
  It now checks the entire register for every test
  It now requires type specification if the xmm register contains anything other than 64-bit floating point numbers
  Make the xmm register deviation checker more consistant

update tests for changes to the xmm register test function
  the load-float32 test was found to be flawed - it erroneously assumes that loading 32-bit floating point numbers onto xmm registers results in the
  register holding a number in 32-bit format (tactyk auto-promotes them).

tactyk-debug - update format specifiers

Add instructions pack-float32, pack-int32, unpack-float32, and unpack-int32 + test coverage
  These instructions take 4 consecutive xmm registers, reduce them to 32-bit fields (of int or float types),
  and pack them onto one xmm register.

*** The pack, unpack, insert, and extract instructions are intended to become the basis for performing SIMD operations
    within tactyk scripts.


18 May 2023
New Virtual-ISA operator:  "vcode"
  The vcode operator subsets a variable-length block of code.
  It fetches a variable, then selectively appends subordinate code.
  Each line of [subordinate] code is prefixed with an integer header.
  If the header has a value less than a defined maximum value (the fetched variable), then the code will be
    appended to the main code block.
  Any code with header value greater than the defined maximum will be omitted.

Update the block-load and block-store operations to use the vcode operator to properly subset the variable-length portion
  (instead of hard-coding everything and using a goto to jump to the correct starting point)

tactyk-debug - Add a tcall function for changing the format used for printing xmm register content with dump-ctx.
  TACTYK code to make it print xmm register contents with integer formatting instead of float-64:
    assign rA 9
    tcall dump-dispmode
    tcall dump-ctx

tactyk-debug - add int32 and float32 format handlign for the dump-ctx function.

tactyk-emit - Handle undefined instruction error

tactyk-simd
  begin development of simd capabilities
  add instructions for packing and unpacking data on xmm registers


16 May 2023
Test coverage for square-root, spread

New instruction:  spread
  This loads a list of values onto a series of registers (lexical order by tactyk aliases)
  Up to 6 integers may be loaded onto data registers, starting at any named data register (rA-rF)
  Up to 14 floating point values may be loaded onto xmm registers, starting at any named xmm register (xA-xN)
  For the time being, this is restricted to hard-coded integer and floating point values
    At some point later, this should be changed to allow integer constants and floating point constants
    (this can technically be accomomplished with tactyk as-is, but would require a combinatorial explosion due to literals and constants being handled
     with separate type specifiers)

Add a new example:  "matrix.tkp"
  This example sets up a 3D perspective transformation using the Matrix processing component of an in-dev 3D graphcis framework for TACTYK.
  The introductory comment includes JavaScript code for using THREE.js to generate the same matrix using equivalent logic.
    "TACTYK-in-3D matrix processing is adapted from the Matrix component from THREE.js
      (modified to use in-place modifications of existing data structures instead of requiring multiple data structures with separate calls for concatenation)

15 May 2023
test coverage for: sine, cosine, tangent, arctangent, log2, log

Add an "extra" Python script to help generate tactyk test scripts
  Tests are generated by selecting random numbers and performing calculations with Python functions, then emitting a test script which performs the same test
  in tactyk and compares the tactyk result with the result from Python.
  If python implementation is correct and correctly used, this should suffice for common cases.

Add square-root instruction

13 May 2023
Make tactyk-visa loading modular.
Split tactyk-core into a set of modules.
  A large portion of tactyk can now be factored out of complexity considerations if not needed.

Remove memblock stash allocation.  Re-assign the space to general-purpose storage.

Remove "diagnostic" output
Remove "cpuclocks" instruction

Added a mechanism for accessing the x87 FPU.
  It uses a few new entries added to the context data structure to transfer data between tactyk and the x87 FPU.
  The x87 FPU is not considered part of tactyk state
    There is no plan or intent either to allow scripts.
    Data is not to be stored on the x87 registers beyond the duration of a single instruction.
    Neither the x87 FPU state, nor the memory used to transfer data in and out of it are considered part of the tactyk state
      (no intent to check it on tests) - actual results should suffice for testing.

New instructions: sine, cosine, tangent, arctangent, log2, log
  (access to x87 transcendentals functions)

12 May 2023
tactyk-auxiliary library - Add "text" print statements for xmm register content (16 byte text chunks).

11 May 2023
tactyk-pl - Fix the '.' and '>' sub-directives (used for union type specifications)
tactyk-auxiliary library - Add functions for printing floating point numbres (from xmm registers)
tactyk_core.visa - Supplemental memory binding functions
  Add an "unbind" instruction
  Add the abiltiy to copy another memory binding to the "bind" instruction
  Add an ability to swap a pair of memory bindings to the "swap" instruction
tactyk-test - Add a null memory binding test

10-11 May 2023
tactyk_core.visa - Add a "block-store" instruction (with test coverage)
  This stores values from consecutive sets of registers (according to tactyk register alias lexical order) in blocks of memory

8 May 2023
tactyk_core.visa - Add a "block-load" instruction (with test coverage)
  This loads short blocks of memory and writes it to consecutive sets of registers (according to tactyk register alias lexical order)
  It loads 1-6 words onto data registers or 1-14 words onto xmm registers.
  It starts at any requested register and wraps around.
  This only does operates on qwords (8-byte words)
    (at some point an extra xmm variant should be added which does double-qword loads [to the whole register])
  Internally, this is accomplished with a large set of register aliases (in the asm header)
  This probably should be revised to use a specialized operator
    (was initially going to use a simple repetition operator, but bounds checking undermined that approach)

Fixed an error in tactyk-pl "flat" directive
  (It was only copying 4 out of 8 bytes into the [compiler-initialized] memblock when using double-precisions floating point numbers)

6 May 2023
tactyk-pl - platform constant tables
  Host applications can now provide arbitrary constant tables for use by tactyk-pl scripts.
  This generalizes the "use_vconstants" directive.

5 May 2023
Support for loading and storing 32-bit floating point values in memory operations
  Conversions are only done on load and store operations - internally the 64-bit format is used for both

Test coverage for 32-bit floating point load/store operations

Add a semi-justification for the floating point values used in the load-fail-f64 test (and load-fail-32).

4 May 2023
Fix a use-after-free error in the tactyk demo
  This was due to an oversight when releasing the buffer containing the raw script code. 
  - forgot that that buffer was treated as a persistant backing buffer for table keys.

Rename the tactyk_asm memory binding updater.
Add a dynamic object binding function to tactyk_asmvm
  This sets up a temporary memory binding within the tactyk context.
  The memory binding is assumed to be valid until a matching unbind function is called
    the unbind function scans the context for the binding (scripts are allowed to move them) and resets it.

Add an auxiliary library for helper functions for use by tactyk scripts.
  These are optional, placed in a separate library by the build script.
  To use them, a host application must be linked to the library, and it must call the configuration functions when setting up a tactyk-emit context.

2 May 2023
Disable memory-bind stashing
  It directly conflicts with dynamic memory binding, and dynamic memory binding is preferred over it.
    (Either all dynamically allocated would have to be permanantely allocated, 
     or the entire stash would have to be scanned by the memory management system)
  Stashed memory bindings would be fine if it where checked to ensuire the stashed bindings are declared memblocks
    But the checks would require two static memory fetches, one dynamic memory fetch, and two comparisons
      (which seems a bit much for stash ops (which are supposed to be rapid))

Build script modifications
  Make symlinks if building the testing system or the demo, but not the tactyk library
  Use a better path variable (CMAKE_CURRENT_SOURCE_DIR instead of CMAKE_SOURCE_DIR)

29 Apr 2023
Wrote documentation for the tactyk emit interface
Removed the old overview document.  The operational aspects of TACTYk are now described by the documents in the doc directory, and
the overview-ish aspects are in readme.md.

Design corrections
  Combine tactyk_emit__reset() with tactyk_emit__init_program()

28 Apr 2023
Wrote the instruction section for the new documentation of the tactyk_core Virtual ISA.
Wrote new documentation for basic usage of libtactyk by host applications.
Wrote documentation for tactyk-test.

Move word size type specification used in load and store operations to a named typespec

Design corrections
  Move Virtual-ISA resource directory specification to the V-ISA init function.
  Move the tactyk_pl initialization to tactyk_init()

27 Apr 2023
Wrote documentation for the general-purpose structured text used for all TACTYK code and configuration inputs.
Wrote new documentation covering TACTYK Virtual Instruction Set Architecture.
Wrote new documentation covering the [native] TACTYK Programming Language.
Wrote the typespec section for the new documentation of the tactyk_core Virtual ISA.

Marked the old overview document as obsolete (current subproject is to rewrite it).

Remove effectively duplicate V-ISA operator "label"
  The "symbol" operator is quite sufficient for this purpose.

Design corrections
  Transfer responsibility of instantiating the tactyk program data structure form tactyk_pl to tactyk_emit
  Remove spurious tactyk_emit_svc dependency on tactyk_pl
  Remove unused Variable $CTX_MEMBLOCK_TYPE from tactyk_core.visa "address" type specifciation

Fixed a vectorizd opreation format specifier in tactyk_core.visa

26 Apr 2023 -- VERSION 0.7.0
Test coverage for add, mul, sub, and div instruction involving xmm registers
Test coverage for assign instructions involving the xmm registers
Test coverage for stash operations involving extended fields (16-bytes / full xmm register)

Fix divsion, addition, and subtraction instruction templates

Reduce precision for floating point comparisons
  (current test is (abs(A/B)-1.0) < PRECISION, and 256*epsilon was too low)

tactyk-test: add alternative xmm register display modes:  int32, int64, float32, float64, and string
tactyk-debug: add alternative xmm register display modes:  int64, float64, and string

tactyk-test:  rename the xmm register test and add a string literal test to it

25 Apr 2023
Test coverage for tvmcall interaction with the lwcall stack
Test coverage for tvmcall interaction with memory bindings
Test coverage for store-xxmx templates
Test coverage for bounds checking in load/store operations using xmm registers
Test coverage for swap instructions involving xmm registers

Expand tvmcall instruction to update references to program memory bindings when calling and restore it when returning.
Add checks to tactyk-test to validate tvmcall interactions with memory bindings.

Add floating point value handling to tactyk-test memory validator

fix template swap xmmx-xmmx

remove vectorized instruction stub code

Begin [re-]writing tactyk documentation.

24 Apr 2023
Test coverage for tvmcall interaction with the mctx stack.

Re-enable missing register checks (address and stack registers)
Replace mctx clamping with overflow and underflow errors
Unwind mctx and lwcall stacks [to original positions] when returning from a tvmcall

22 Apr 2023
Add test coverage for tvmcall instructions (tvmpush, tvmjump, tvmreturn)
Add test coverage for load-xmmx instructions

tactyk-test refactoring
  Improve descriptions when indicating where unexpected state transitions are observed.
  Use a generic macro to checking for and describe unexpected state transtions
  Remove most pass/fail testing from individual property tests
    For the most part, these functions now just write the expected state change to the relevant shadow object.
    Responsibility for recognizing unexpected state changes now mostly belongs to the general-purpose state transition recognition function.
      (where specialized handling is needed, the individual test functions can still do it)

Remove direct state adjustment functions from tactyk-test
  tactyk is quite capable on its own state on its own.

Add test functions for validating the primary stack (tvmcalls -- tactyk program callign into other tactyk programs)

Corrected an inconsist state change in tvmpush.  This one arguably gets a bit pedantic...
  It previously was writing a stack entry after validating the program handle, but prior to validating the function handle.
  If the tactyk runtime is well-behaved, this isn't an issue, as it does correctly signal an error and terminate, 
  However, if the runtime is poorly behaved (liek the current testing setup) and allows script re-entry after an error is signaled, 
  then a subsequent attempt at performing a tvmjump results in a segmentation fault due to the use of improperly placed invalid data
  on in the "stale" tvmjump.
  The correction was to rearrange code and reallocate registers to perform the stack entry write after validating the function handle.
  The odd handling of invalid data was a compromise to avoid having future constant/integer variant spill a register.
    (An extra temp register was subsequently made available through a refactoring effort, so there is no need for any such compromise)
  (NOTE:  fixes segfaults originating inside of tactyk under script control have a much higher priority than fixes for segfaults in the runtime).

Added variants of tvmcall isntruction which use integer/const arguments

Add a templates for loading truncated floating point values onto data registers

21 Apr 2023
Add test coverage for instructions: stash, mctxpush, mctxpop, mctxjump

Repurposed "type" field from memory block specification.  
  It is Renamed to "offset" and is now intended solely for storing the address offset while stashed.
  (and will only be updated when stashing memory bindings)

Micrcontext stash redesign
  Most of stash memory is now general-purpose
    All data, xmm, and unused slots in the stash have been combined into a general-purpose stash 
      Ttotal of 52 8-byte slots, or 26 16-byte slots (if/when large vectorized/SSE2 operations get more than a few bits of stub code)
    All data and xmm stash operators can now read from or write to any part of general-purpose stash (no more shadowing).
  Stashed memory bindings still use a reserved portion of the stash (same size)
    (the reservation is to help avoid having to re-apply memory safety checks)
  The stash and unstash instructions have been merged.
  Stash arguments have been broken up and are now a sequence of destination-source token pairs
  The stash command is now a composite operation which can perform any combination of load, store, and swap (maximum of 16 operations).
    Conflicting load/store/swap sequences is undefiend behavior (the result of which is non-deterministic on account of internal randomization).
    Exact duplicate operations are not permitted (duplicate operations will be silently culled prior to assembly)

Add "mctxjump" instruction
  This allows programs to bind any stash in the microcontext stack (above the "floor")
  This is intended to allow support the use of the microcontext stack as script-local storage.

Extend assign instruction to read stack registers (rLWSCI and rMSCI)
  The value obtained is relative to the stack floor

New security feature:  Random address displacement
  Two random 30-bit constants are generated and used for address displacement.
  These are generated during initialization and apply to all programs using the same context
    (different contexts may use different displacements, but support for mutliple contexts is not [yet] a part of tactyk).
  These are are applied to the context data structure (which uses the fs segment register) and the microcontext stash (which uses the gs segment register).
  The displacement value is subtracted from the pointers prior to writing to the segment register, and added as a constant displacement to each address referencing them.
  The primary interest is to fortify the stash operation
    (it allows scripts to specify a multiple immediately adjacent instructions and can achieve only a moderate level of randomization without resorting to arbitrarilly inserted nops)

Restructured tactyk-test

Add state change tracking for the main stack to the test system.

20 Apr 2023
Add instructions:  not, negate (tactyk_core.visa)
Add test coverage for and, or, xor, not, negate, inc, dec instructions  (tactyk_core.visa)
Add test coverage for shift operations (shift-left, shift-right, rotate-left, rotate-right)
Add test coverage for goto instruction
Add test coverage for tcall and ccall instructions
Add test coverage for if instruction
Add test coverage for lwcall

Add template for using integers or constants to offset an address.

Correct and expand address offsetting through the assign instruction.
  the instruction now accepts a data register, a hard-coded integer, or a constant.
  Also added test coverage for it

Correct register usage for shift instruction (which taking the shift parameter from a data register)

Correct the microcontext stash layout

Expand the testing system to accept and validate callbacks from tactyk.
Expand the testing system to validate microcontext stack and lwcall stack state transitions.

Remove all constant to constant conditional jump templates
  (get your own preprocessor!)

Add break .. resume, with test coverage
  The "break" instruction places the vm in a suspended state.
  A subsequent "resume" operation causes the execution to continue where it left off.

19 Apr 2023
Use mkstemps() to generate unique temporary filenames when building assembly intermediates.
  (Fixes automated tests failures when using multiple processes)
Test coverage for load instruction bounds checking
Test coverage for store instruction (and bounds checking)
Expand bind instruction coverage to include failures
Test coverage for push and pop instructions
Test coverage for swap instruction
Test coverage for add, sub, mul, and div instructions

Prevent binding of uninitailized memblocks
  (It was probably harmless, but I'd rather not write tests for it, and it has to bounds-check memblock IDs anyway).

Revise stack operations (lwcall/lwreturn, push/pop)
  Stack pointers (or indices) now start at the base address and point at the next entry
  lwcall now uses the whole register and uses proper bounds checking

Append a string terminator to all files read into a buffer.

Fix memblock offset derviation in testing system

Add two methods for handling integer division by zero:
  Exit tactyk with a status code.
  Jump if the denominator is zero.

Add binary and hexadecimal integer format parsing
  bin:  b.0010101110101
  hex:  h.afd2131231aee

17-18 Apr 2023
Add memory and memory binding to the testing system
  It gets a bit complex because memory bindings don't always have a convenient origin.
Test coverage for the bind instruction
Test coverage for load instruction (data register only)

Implement tactyk_pl data directive
  This defines and initializes a memblock containing formatted binary data
  The format of the binary data is provided by a struct (use the "struct" directive and reference it by name)
Add tactyk_pl flat-data directive
  This defines and initializes a single-element memblock consisting of a flat list of values of one data type.

element_bound properties now are an alias for stride/element-size
  Bounds checks are now handled in ASM by offsetting element_bound as to fit the word size
  (bytes can now be written and up to the high edge of an element, while still preventing large words from spilling)

Added a function which invokes tactyk and returns false if it ends in an invalid state instead of throwing an exception.

13-17 Apr 2023
Added an automated testing system
  This was primarilly motivated by the ever-increasing tediousness of manual testing.
  The test program is focused on covering virtual ISA operations.  Another system may be needed for covering supporting components (libtactyk).
  The test program accepts a list of files through command-line input
  Each input file is regarded as one test (though it may test any number of things)
  The test program spawns one process per test (limited by the "--jobs" argument)
  Each child process sets up a complete tactyk context and runs a test script
  The test script is a series of commands (in the same format as virtual ISA configuration and tactyk_pl).
  The commands are high-level controls -- generally compile a program, manipulate tactyk context state, call a tactyk function, and compare expected results with observed results.
  The test process maintains both a real tactyk context and a "shadow" context.  The shadow context is a duplicate of the real one and is used to track unexpected state transitions
    with byte for byte comparison.
  The test gives one of three results:  Pass, Fail, or Test-Error.
    Pass indicates that the following have occured:
      All test functions ran without error
      All test functions that report pass/fail/error reported a pass.
      The tactyk program and all supporting functions operated without error.
      All test checks passed
      The tactyk context state did not perform any unexpected state transitions (all changes accounted for).
    Fail indicates one the follwoing conditions:
      Any test function reported a "fail" result.
      The test process was terminated for exceeding the maximum specified run time (defualt is 4 seconds).
      The test process was terminated by a signal (usually segmentation fault).
        NOTE:  Process termination is presumed to be a problem in tactyk, but it also can be a problem in the test program.
    "Test Error" indicates that the test program identified an error in the test script.
  The test program halts on the first error or failure.
  Additionally, the test program logs errors and text condition failures

Test coverage for handling of integer immediate operands

13 Apr 2023
Fix and enable the garbage collector

Reworked the way tactyk uses jump tables:
  The "rPROG" register (rdi) is renamed to rMAPPER and is primarilly used for completing jumps which involve jump tables, and secondarilly as a 4th temp register.
  Use read-only access for jump table memory
  The pointer to the active program's jump table now belongs to the context data structure (due to rMAPPER being made volatile)

11-12 Apr 2023
Add support for dynamic compilation.
  This is intended to allow for the use of high-level languages in tactyk - with a toolchain which is to run entirely within the sandbox.

Remove erroneous alias of "xo" to xmm14
  (xmm14 is used as the main xmm temp register, so use of "xo" would result in data corruption
Use a "typespec" to define xmm-transfer conversions

Add an error for instruction handler failing to generate code.

Add pointer validation for calling into tactyk and returning to tactyk.
Pointer validation is accomplished by applying a transform to the pointer passed to tactyk, then verifying that the transformed pointer is 
present in the context data structure.
If the value is mismatched, the test fails, then the program reports an error and terminates.

restructure tactyk context
  Replace everything in the "control state" / Virtual Machine data structure with tactyk program declarations
    The program declarations are to be used by tactyk programs to call into other tactyk programs
  Cross-script stack added to context data structure.
  Runtime register storage moved back to the context data structure

Add a mechanism for attaching programs to the new virtual machine structure.

Add an optional allocator which uses sys/mmap.h to request random pages within the "tactyk" subset of user address space.
  This will be disabled by default (I only want it in place for now).
  It may be enabled through conditional compilation with the "USE_TACTYK_ALLOCATOR" #define

Add a pair of "stack floor" variables to prevent a program popping more than pushing when using the lwcall and mctx stacks.
  These are maintained by the vm (during function calls).

Add tactyk-vm calls
  These calls transfer control from one loaded tactyk program into another.
  Context is mostly shared between caller and callee
    The program reference is adjusted 
    Microcontext and lwcall stacks are restricted to prevent the callee from popping entries the the caller's stack entries)
NOTE:  There is a lot of pointer chasing in tactyk-vm calls as-written, so it may be appropriate to add a limited variant which uses pre-fetched data
       to speed things up a bit.  This might not be worthwhile as the critical path doesn't seem to be very long.

Added a "string" type specification
  strings are a sequence of up to 8 or 16 bytes which may be concatenated, converted into an integer, and loaded onto a register.
  String formats supported:
    'string   - single apostrophe followed by any text
    "string"  - text surrounded by quote marks
    `$VAR`    - perform string interpolation on the contained text and use the result
  The "assign" instruction now accepts strings.
    If assigning to a regular register, a maximum of 8 chars may be used.
    If assigning to an xmm register, chars 0-7 will be loaded onto the lower portion of the register, and chars 8-15 will be loaded onto the upper portion
  Space chars (' ') are not supported and will terminate the string (due to a decision to use a simple and strict syntax).

10 Apr 2023
Completed the Julia Fractal example.  It in real-time at 128 max iterations.

Add all xmm registers to context management.  This will increase context switch overhead, but is needed calling into functions which
operate directly on tactyk contexts, to avoid potential data leakage to untrusted code, and [eventually] will also be needed for automated testing.
Add full 128-bit xmm register storage to stash and unstash command.
  (the 128-bit storage competes with 64-bit storage - a stashed 128-bit register uses both 64-bit slots)

New debug system (simpler, calls into a debug C function instead of relying on a specialized debug invoker)
Reworked register allocation to undermine unexpected memory copy operations (movsb).
  Also updated the internal representation of registers.
Added a tracing garbage collector
  (collects objects marked with specific tags)
Made the emit context recyclable (can compile multiple programs)
Made tactyk programs modular
  program loading is broken up into initilization, loading, and compilation phases.
  So long as block structures are not broken up, it can effectively concatenate any number of source code files.

Pending feature:  managed function calls
ccall operation is to be redesigned to prevent undeclared parameters from being passed or received (mostly, this means a function signatures will be needed to configure tactyk-emit, and any unused parameter slots will be zeroed out by the generated code).
  - It might also be worth considering adding ADA-like range restrictions on parameters passed to C functions

6-8 Apr 2023
Begin work on an SIMD handling
Add basic floating point operations (using SSE2)
Add example program: Julia fractal evaluator/renderer

Fix incorrect table entry removal
Fix immediate operand scrambling for qwords, then fix it again
  It now uses loads the random value onto the target register, then the difference onto rTEMPD (rdx), and combines them with one xor.
  rTEMPD is cleared at the end of the unscrambler.
  If more than two scrambled immediates are needed (no such need at present), then one of the previously used registers must be reused.

Add templates for conditional jumps using floating-point comparisons
Add floating point templates to a few regular operators (add, sub, mul, div, assign)
Add 2 banks of floating point values to the microcontext stash (shadowing the xmmx registers and doubling the stash size)
Add options to the stash and unstash to handle floating point values

6 Apr 2023
Implement lightweight calls
  lwcall ... lwreturn is the mechanism for treating labelled statements within tactyk as subroutines.
  lwcall only redirects flow.  

Implement the microcontext stack
  mctxpush ... mctxpop affects the position of the stash pointer (tactyk builtin locals)
  mctxpush + lwcall (passing the values by placing them on registers) is a complete tactyk function call.
  mctxpop + lwreturn (returning results by passing them on registers) is a complete tactyk return

Repurpose low-level memblock specification "left" and "right" properties.  They are being replaced with a memblock identifier and a type declaration,
to make memblocks a bit more dynamic.  The old "left" and "right" fields originally were meant for queue-like behavior (a cancelled feature).

Add optional operands to virtual ISA configuration
Fix memory block layout not respecting a specifying struct


5 Apr 2023
Restructure the project (decouple the test/demo components from library components)
Update resource references in the unconfigured (non-shell) interface.
Use Cmake to declare the version number
Add a mechanism to tactky-PL for defining "variables".
  tactyk-PL "variables" are basically just code templates dressed up as getters and setters.
  The "var" keyword is used to declare a variable.
    The "get" block within a variable declaration specifies the command (and arguments) used for the getter.
    The "set" block within a variable declaration specifies the command (and arguments) used for the setter.
    All arguments in the getter or setter which are equal to "?" are replaced with arguments from the source code [in order].
  The "get" and "set" keywords outside of variable declarations invoke getters and setters.
    For the "get" keyword, the last argument in the list is the variable name and all other arguments are tokens to insert into the command
    For the "set" keyword, the first argument in the list is the variable name and all other arguments are tokens to insert into the command
    This ordering is intended to reflect typical assembly syntax ( op <dest> <source> )
Move the memory block get-by-name function from auxilliary support to tactyk_asmvm

Add an auxilliary interface for rendering framebuffers with SDL2.
Add an auxilliary interface sleep function
Add an example demonstrating rendering a framebuffer through the auxilliary SDL interface.

fixed incorrect c calls
  printf can print floating point values when called from a callback from TACTYK!


4 Apr 2023
Add an introduction (readme.md)
Moved source files to "src" directory

Add copyright notices to all source files, place project under the GPL-3 license.
The project might be relicensed if/when it starts pasing security audits.  Until then, if it's going to get deployed (against all rational advisement), then users 
should at least have the legal right to fix and/or update the unwisely deployed scripting engine.

remove lwcall and mctxcall data structures from context space.  These are now predefined memory blocks allocated by the runtime (was previously [checked] addressable
context memory, in violation of the emergent TACTYK security model).  Context diagnostic memory probably also should be moved to a separate memory block, though nothing presently
indexes it (and there are no plans to implement anything that does).

New Issue:  Native context restoration when calling into a C function does not appear to be complete.  The terminal interface does not immediately display program output if output is sent by a C function called from tactyk.  If the c function segfaults, then the output does not display at all.  This is possbily related to an earlier problem involving printf within a C call from tactyk segfaulting if printing floating point numbers.

3 Apr 2023
Add a code of conduct.  This one aims to respect liberty of conscience, restrict vindictiveness and abuse of process, and encourage amicable dispute resolution.
Add a "tactyk call" interface - A "tactyk call" is a call into a function which extracts its parameters from a tactyk context.  This is a compromise for forbidding
  scripts from directly handling pointers (and is to generally be the means by which host applications receive events/callbacks from tactyk).
Add examples:  Fibonacci Generator and Lazy Quine - these may be run from a terminal interface

1 Apr 2023
Add a shell-based test interface.
Add support for building with cmake
Add a simple method for making c calls.
  It's unstable, platform-specific, and carries a moderate risk of enabling type confusion attacks (though largely on account of an apparent lack of enforcement or 
  warnings in C for failure to abide by declared function prototypes [though even a correction does not guarantee that host application doesn't have unsafe code anyway])

Note:  Noticed that I had no trouble writing a 64-bit field directly in an x86 mov instruction.  The immediate operand scrambling should be reviewed for
       potential improvements (xor is restricted to 32-bits so complex handlign for 64 bit immediates is required).  Can probably cut one op by switching to a 64-bit write and
       using bitwise rotation (more ops could be spared by using a temp register, but the scramble operation is cumbersome enough as it is)

30 Mar 2023
Memory-management revision progress:
  The quicksort test successfully ran
  NOTE: to get the test to run, it was necessesary to re-introduce a memory leak involving dynamically allocated data inserted into
        tables.  These data structures will have to be attached to something else (presumably a context field).
        Alternatively, it ma be appropriate to accept the "memory leak", and simply dispose all of said data structures indiscriminately upon
        completion of compilation.  This will require an extra step to offload tables that need to be persistant.  
        (a custom allocator is used to allocate them, so wiping out everything is viable).
  Removed tactyk_table, tactyk_textbuf, and tactyk_structuredtext (all have successfully been replaced)
28 Mar 2023
Memory-management revision progress:
  The Fibonacci test successfully ran

25 Mar 2023
Memory-management revision progress:
  started with tactyk-pl - struct and memory-specification handling updated

memblock and memblock_spec have been renamed to memblock_spec_lowlevel and memblock_spec_highlevel, to better indicate that both data structures are two distinct representations of the same thing.

24 Mar 2023
The unified data management component has somehow been written in about a day and about 1000 lines of code.  Integration should be interesting.
Also added automatic table resizing and rebuilding, as well as the ability to delete entries.

23 Mar 2023
Rename include guards (per DCL37-C)
  Would prefer to "not care much" about this issue and instead compel whatever committee is responsible for maintaining C standards to select a meaningful prefix (such as CSTDLIB_*) to be treated
  as reserved.
Initiate development of a unified data management component.
  This is intended to replace c-strings for most (if not all) of tactyk.
  Cases to cover are as follows:  associative arrays, debug output, resizeable/writable text buffers, structured (heirarchical) text, string concatenation, pattern matching, and general data structure management

22 Mar 2023
emit+visa revision progress:
  upgrade the pattern matcher to support conditional code insertion based on presence or absence of "flags" within an operand
  Modify the "code" subroutine to append to a text buffer (isntead of a c string).
    (this allows concatenation of conditionally selected code fragments)
  New feature!  The store operation is able to directly write immediates to memory.
    (pre-revision version left omitted this because complexity.  revision included it because I went ahead and implemented it before inspecting the old version more closely.
      (technically, the limitation in the old version was due to restricting immedaite operand data capacity to 16 bytes per instruction, so a compromise was required))
  Quicksort test program executed successfully.  

21 Mar 2023
emit+visa revision progress:
  Integrated the assembled output into tactyk_asmvm.
  Fibonacci test program executed successfully.  

20 Mar 2023
emit+visa revision progress:
  rIPTR is no longer used for holding an instruction index.  No specific purpose has yet been selected (but it still must hold small values or zero)
  Generated code is now accepted by NASM.  (now very close to running the fibonacci test)
  Modifed the immediate operand de-scrambling asm to avoid attempting to encode an xor with a 64-bit register
    destination operand and unsigned 32-bit immediate source operand.
    (this adds more instructions to the "qword" form of the operation and modifes the "dword" form to
     narrowly target the 32-bit register)
   
18 Mar 2023
emit+visa revision progress:
  Generates a complete assembly-language representation of the fibonacci generator test (with full randomization and linkable functions)
  

16 Mar 2023
emit+visa revision progress:
  Generates code for all instructions from the fibonacci generator test

14 Mar 2023
emit+visa revision progress:
  First successful test of the code generator (+ integration with many supporting components).
  

13 Mar 2023
emit+visa revision progress:
  Decided to de-generalize a few substantial aspects of the design (to move toward a declarative design with narrowly focused operators and a bit less syntax)
  Cancel requirement to emit only unique instructions (implemented in the unrevised version).  This is partly to reduce the complexity, and partly because instruction de-duplication does not save much memory anymore (due to inclusion of immediate operands).  To reinstate this functionality, insert immediate operand values into instruction labels,
  use the modified labels as table indices, and use the program jump table to handle all instruction dispatch.
  Added the immediate operand scrambling back-end (prepares the scrambled version of resolved immediates -- as part of operand evaluation)
    -- it also took an arguably embarrassing amount of time to decide where to put it...
  Memory management (data structure disposal for the emit interface, dispose the tactyk_pl text buffer when no longer needed)
    I probably should make a dispose function for the tactyk_pl__program data structure (but in many cases, it will need to persist as long as the host
    application is running (which is the prototype behavior), so for now, this has a low priority.
    If tactyk_pl were implemented properly, it also would need a dispose a complex data structure 
      -- but it runs mostly on static allocation, so I'm not going to bother with it for now.

11 Mar2023
emit+visa revision progress:
  The First operands of the first line of code in the fibonacci generator ("bind addr1 thememory") is correctly handled (address register picked and corresponding parameters to access a 
  memory specification variables in the execution context.
  The second operand also identified (This operand refers to a script-specified memory block, so symbol tables must be integrated into the emit interface to proceed).
  Move memory block symbols to a distinct table (prevents the new emit from inheriting the hack the old emit used to enforce type constraints on memory block identifiers)

9-10 Mar 2023
modify tactyk_textbuf__store() to respect the fixed capacity (produce an error message and exit instead of unexpectedly resizing the buffer and [probably] leaving a bunch of hanging pointers behind).
emit+visa revision progress:
  Added a basic error handling system.
  
8 Mar 2023
  Insert "fallthrough" gotos to jump to next label.  (to support logical layout randomization -- specifically, to randomize jump table indices so they don't have to be scrambled the way immediate operands are)
    NOTE:  jumps are implemented in asm with "jmp [rPROG + rIPTR*8]", instead of labels, because virtual instruction pointers are employed - this logical layout randomization would be unnecessary without it, 
    but direct reliance upon real instruction pointers would carry its own hazards (and it gives the otehrwise de-purposed stack registers something reasonably safe to hold).
    Labels which are preceded by an instruction which [already] unconditionally redirects control flow are ignored.

7 Mar 2023
emit+visa revision progress:  And I went one full day until *something* came up that forced the use of a semi-persistant text buffer for safely storing strings.  The buffer at least can be 
    reset every time an instruction handler is invoked and it is only anticipated to be needed to cover a few very specific cases (and thus for now does not need to be a large buffer).
    (a viable alternative would be to make a variant table which stores copies of data instead of pointers to data)
  removed old tactyk_emit and tactyk_visa, replaced them with the new ones
  Changed many names and method signatures
  Retargetted tactyk_pl [to the new emit interface].  
  Transferred management of the host-api from tactyk_pl to new tactyk_emit, removed references to the host api from program symbol table.
  Labels and and commands are correctly loaded into the new interface.  Verified label correctness. (technically trivial, though retargetting everything and getting it to compile was not).

6 Mar 2023
Adjusted tactyk_table to copy keys and store them in the table structure.  
  The main reason for this is to avoid having to use a key storage buffer in a pending rewrite of virtual-ISA + emit.
    (original intent was to avoid duplicating keys in memory, and not [as it might be assumed] a misunderstanding carried over from other languages)
  This was a minimal change which switched from a string pointer to a fixed-sized block of data in the entry struct.
    (the changes required were also much smaller & simpler than expected)
  The change forced a "quickfix" in tactyk_emit due to emit directly reading tables to iterate through all keys (had to switch the vailidity test from null key to null item, 
    as the key field is now always non-null).
  tactyk_table should probably be further revised to avoid using the entry struct as a simple data type 
    This revision possibly should add a formal means to iterate entries.
    it might be worthwhile to also include a mechanism for deleting entries (though under the current design, any deletion operation would have to trigger an expensive table restructuring)
The designs for the revised Virtual ISA configuration and revised emit interface are mostly settled.
Added an entry assignment function to tactyk_table - this one adds a new entry to the table if the key is not matched, and updates the existing entry if the key is matched.
  (used the easy but inefficient option of simply copying and altering the add_strict() function.  This should probably be implemented smartly, as this approach is twice as expensive as
   a correct implementation)

4 Mar 2023
Initiate redesign of Virtual ISA configuration.  The intend is to make all assembly language handling configuration driven.


28 Feb 2023
Removed outdated reference to precompiled assembly from before initiation of the 21 Sep 2022 revision.
Remove the "simple binary op" implementation of the multiply instruction (was blocking the more detailed version)
Add Memory block offset field reset to the reg-imm variant of memory block bind operation
Rewrote tactyk overview documentat

27 Feb 2023
Reset all temp registers at the end of all functions which modify them.  (for consistancy)

23 Nov 2022
  Switch from threaded code to semi-conventional compilation, doubled performance.
    Given how small the differnece between threaded code and compiled code has become, there simply does not seem to be a compelling reason to insist on using a jump table.
    (Binary Executable Layout Randomization addresses the concerns I had about using JIT compilation - much better than interpretation does)
    ALSO:  Some rather ugly hacks where used to implement this change - At this point, I mostly just want a decent showing on performance.
           A major redesign is what's really needed at this point.  Or will be when moving beyond this prototype.
  Threaded code remains available as an option (for conventional interpreter support)
  
  Fix offset-get to actually calculate the array offset (instead of simply returing array bound)
  
  Add a reset function to tactyk table (clears all data and leaves the table data structure intact).

18 Nov 2022
  Add a flag to the internal instruction definition to help the debugger distinguish debug instructions from real ones. 
  
  Rework mctx/stash to work sensibly with recursion.
    The stash has been reduced to just 4 addresses, 18 data registers, instruction pointer, and fast branch pointer (possibly may expand for floating point numbers).
    Integrated stash with microcontext (stash now lives on the microcontext stack instead of a fixed set of locations on context space).
    Microcontext stacks are now 4 distinct blocks of memory allocated by the runtime
    Use the gs register to hold the reference to the current mctx/stash
    Adjusted the FLAGBUILD assembly template handler to use longer flag names (preferentially so).
    removed the register/address storage options from mctxcall and mctxreturn.  This functionality is subsumed under stash/unstash. (though the stack-id option remains)

    NOTE:  the current mctx/stash is visible within fastcalls and lwcalls, and should still function as global-ish storage within them.
17 Nov 2022
  Added a "stepper" which can cause the VM to execute one instruction per step (while debugging).

13 Nov 2022
  Renamed "changelog" to "devlog" (this document)
    It's easier to change the changelog than to change the log!
    Also, this "devlog" should not be confused for a "devlog" either.
    
10 Nov 2022
  New concept:  Scrambled immediates
    Scrambled immediates is to be an encoding of immediates in executable space, wherein the immediate values are masked by random numbers.  For each, a random number is written to a target register, 
    then the difference between the random number and the intended immediate is added to the target.  THe random numbers are to be taken from an SPRNG.  This is to replace extra-immediates, saving 
    memory and replacing random memory access with a few extra operations (2 ops for small immediates, 4 ops for 64-bit immediates).  The scrambling is to prevent adversarial content from using 
    immediates to encode instructions (and thus further undermine attempts to use tactyk-VM as a source of gadgets for exploits involving vulnerable functions in the host application).
    
    This will probably be an optional / configurable security feature (and like most such mitigations, this too is a workaround for inability to have flow control constraints enforced at the hardware
    level)
  

9 Nov 2022 - 17 Nov 2022
  Extended debugging session for the FHourstones port.
  Bugs fixed:
    subroutine POSITIONCODE had a misplaced jump, resulting in the wrong code returned 50% of the time.
    subroutine AB an index variable swapped with a value variable for one of the writes th the "av" array (whatever that's supposed to be), resulting in a game desync on the 18th ply of the first test
    subroutine AB was not restoring the local variables after returning from recursive calls into itself (which would result in problems with backtracking)
    The underlying microcontext stack position read operation was incorrectly reporting indices 8 times the intended value, resulting in lots of the fhstones local variable storage being sparser than
      intended (it was vastly over-allocated)
    subroutine TRANSTORE lacked a "fastreturn", resulting in fallthrough to subroutine SOLVE, then much misdirection.
    subroutine AB was found to be missing a call to BACKMOVE after the 2nd recursion
    Fix subroutine TRANPOSE and TRANSTORE offsets
    Noticed that TRANSPOSE and TRANSTORE had struct order reversed -- Rather than fight it, decided that the port will simply use the reversed order and changed the C-struct to reflect it.
    And various other problems...
    
8 Nov 2022
  cleaned up the fhourstones "debugprint" function in anticipation of a potentially long debugging session.
    Also inserted a call to the tactyk code debug function.  (This is not a proper debug utility, as it relies on lazilly retained data -- but for an experimental project, it is good enough)

7 Nov 2022
  The dynamically generated VM upgrade is complete enough to run the tactyk programs 
    (with some adjustments to reflect the simplified grammar, as well as some adjustments to take advantage of the underlying templatized assembly system)

4-5 Nov 2022
  re-integrate microcontext, and mostly unify it with the "stash".
  improved some comments on the templatized assembly handler (tactyk_emit__op_process and tactyk_emit__operand_def).
  removed the space allocated for context-based register spills (three unallocated registers seem to cover the needs for everything tactyk-specific)
  re-arranged items in context (specifically to move lightly used words out of the way)
  allow up to 4 simultaneous lwcall stacks (dubious motivation:  24 bytes where added to the lwcall data structure for alignment, and extra assembly-template options does not automatically
    add overhead to the VM, so whatever.).

1 Nov 2022 
  Add a basic error description function to tactyk_emit.  Line numbers don't exist at the level emit operates, so it instead indicates a command name, a subroutine name (label), a command index, 
  and it also lists all operands.
  
  re-integrate operations:  min, max, modulo

31 Oct 2022
  re-integrate lwcall/lwreturn.

29-31 Oct 2022
  re-integrate ccall.

27 Oct 2022
  Reduce "extra" immediates shadow memory to 8 bytes of space per instruction and converted all immediates fetch ops to use scaled index addressing.
  Adjust quicksort test to use a regular index mode (no longer makes sense to have an operation dedicated to reading the first entry)
  Backed off on 32% of native performance claim.  Actual performance is ~26% of native.  The erroneous 32% claim was due to accidentally switching to a debug build target
    .

24 Oct 2022
  Quicksort test works again.  

22-24 Oct 2022
  stash ops re-integrated (and improved)
  structured data handling (memory block offsetting and indexing and bounds-checking, using information from data structure declarations)

19 Oct 2022
  Invented another dubious mechanism for making templatized assembly more confusing 
    (namely, the ability to build an operation from a user-defined list of flags, plus another layer of abstraction to help wedge it in along-side the rest of the operator generator).

12 Oct 2022
  Add a notion of class to integer resolution (to restrict integer resolution to specific symbol sets).
  Fixed a type confusion exploit (from a lazy implemention of register/integer classes).  Fix is to reserve a char for use as an internal delimiter (was previously '.', which is generally allowed).
    NOTE:  direct exploit mitigation of this nature is not yet a high priority, but I'd rather not get in the habit of leaving known-subtle exploitable defects in place.
  Developement progress on NEW tactyk_pl: can now specify, dynamically bind, and access memory.

5-6 Oct 2022
  Redesigned tactyk_pl
  Learned the use of the "fs" and "gs" registers, incorporated their preservation into the context switch logic.  Planning to use them to release rcx and rdx (preferably no special use - just extra
    open registers to avoid spilling and to avoid clashes from non-orthogonal ops).
  released registers rCTX, rSTASH (was going to do rPROG, but it displeased the jmp ops ... or possibly just dipleased NASM -- anyway there's only two general-purpose segments available, so rather 
    than trying to figure out what the issue is, I'll stick with what works easiest).
  Designate the released registers as temp registers (to be used to avoid register spills).  rcx and rdx where chosen to make it easier to use various non-orthogonal instructions.

4 Oct 2022
  Add support for unconditional and conditional jumps to tactyk_visa
  Add an enum-like operand filter to the asm generator.
  Better assembly label generation. 
  (it now can run the Fibbonacci generator)

3 Oct 2022
  Abstract the amd64-assembly out of tactyk_emit
  Replace the direct distinction (in tactyk_emit) between "data" and "address" registers with an abstract/generic "register class"
  Add TACTYK (should) Affix Captions To Your Kitten Virtual Instruction Set Architecture (TACTYK-Virtual-ISA (tactyk_visa))
    This defines all TACTYK-VM operations andconfigures tactyk_emit to produce amd64-assembly (NASM syntax) in response to an assembly-like language.
    In principle, this should be generic enough to emulate any assembly-like language (but completeness is outside of the scope of the project).
    Also, in principle, this should be production rules for amd64 machine code, not NASM-syntax assembly (this is intended as part of project maturation).
    

1 Oct 2022
  modify tactyk_table to use it under stack allocation.
  Developement progress on tactyk_emit:  Made it exstensible.

29 Sep 2022
  Developement progress on tactyk_emit:  Can now run a very simple program on a *correctly* defined runtime-generated randomized VM.

28 Sep 2022
  Developement progress on tactyk_emit:  Randomly permute assembly fragments, run it through the assembler, and have the assembler emit a symbol table as well,
  and extract branch targets from symbol table.  

27 Sep 2022
  Added a string "storage" function to tactyk_textbuf.  This stores the null terminator (to make the static-ish string storage useful).

26 Sep 2022
  Developement progress on tactyk_emit:  Can now run a very simple program on a runtime-generated randomized VM .
    Program:  (enter, store runtime context, load VM context, add a const to a register, store context, restore runtime context, exit)
  

24 Sep 2022
  add a reset function to textbuf
  candidate design for VM function generation.

22 Sep
  Add the "tactyk_emit" component. (the header of the same name was leftover from a pre-ASM effort).
  tactyk_textbuffer now returns a pointer to the appended copy (to allow it to be used for static-ish string storage).
  Add a replace function to tactyk_table.
  Remove old tactyk_pl (to be replaced fairly soon with a simpler/cleaner language)
  Temporarilly remove fibbonacci tests, quicksort tests, and the under-development Fhourstones tests (to be revised and reinstated later)

21 Sep 2022
  Decided to proceed with the VM setup from the "mature" plan ahead of schedule.  
  The reason is that the massively macro-expanded prototype VM is getting too big (beyond 300K of assembled machine code), and the expected instruction cache 
    misses are not part of TACTYK-VM performance testing (the intent is that TACTYK-VM should try to reduce instruction cache misses by only loading the subset of 
    its instructions which the loaded program uses).
  And while I'm at it, binary executable randomization is also going to be implemented (Randomly generate the VM to force would-be attackers targettign tactyk-vm 
    to also have to obtain the state of an SPRNG in order to reliably construct or predict "gadgets").
    
  Built stub code for directly invoking NASM from C, loading the results into executable memory, and calling into it.
    The "bin" format is used to obtain unformatted machine code.
    All tactyk functions are to be reviewed and adjusted to be fully position-independent (no reference to any tactyk symbols) - this mostly just affects error handlers.
    Tactyk functions are to be defined by a handler which takes parameters from tactyk-pl.
    The handler generates a /tmp file consisting of a fixed header specifying macros, a set of %define statements specifying unique proeprties/immediates,
    and the function prototype ASM.  The handler then invokes NASM to generate the function, reads back the machine code, and stores it in a buffer.
    When all program functions are generated, the buffers are coalesced, randomly arranged (using system secure-random to select the function order), and program
    function handles are swapped for actual function addresses.

20 Sep 2022
  Register stashing redesign:
    Place immediates in the same memory block as program instructions (to free up an register)
    Repurpose the immediates register - it is now used for a redes
    Data, address, and branch target stashes now reference posisions within said memory block.
    Data stash operators have all been replaced with generic memory access operators
      (a variant of the memory element accessor which omits the bounds check and is able to access the upper bytes for 8 and 16 and 32 bit words).
    Additionally, there are static accessors for each aligned word (8 and 16 and 32 and 64 bit words)
  The overall purpose of the redesign is to expand the stash concept and make it useful for local data storage under recursive/complex scenarios.
  The redesigned stash is essentially a statically allocated block of memory which can be statically indexed without bounds checks (dynamic indexing 
    has to do bounds checking, but the bounds for that do not need to be fetched out of memory).
    
17 Sep 2022
  split memory element operations into components based on word size

13 Sep 2022
  Add "nullmath" to tactyk-pl (aliases for mathematical operations which either yield zero or an unmodified input)
  Redesign microcontext calls - They are now controlled by flags.
  
  More data stash ops.

9-10 Sep 2022
  Replace ASM "transfer" functions with simpler functions that only care about constants (and can target arbitrary sets of data registers).  
  If interacting with memory, use explicit memory access instructions instead.
  (this replaces 650 lines of rather finnicky & questionable assembly code with a much simpler 130-line component).
  
  fix min,max instructions
  
  add microcontext stack operations - These are middle-weight function calls which store registers on a stack, but do not switch context.  

8 Sep 2022
  Add multi-line definitions
  fix broken bit-shifts on register rD (was rcx, switched to r13 and added a bit of de-mangling logic to ccalls).  I indirectly blame Intel for this one.

7 Sep 2022  
  Adjusted transfer statement control bits shifting (appears to have been a matter of "design drift" between when transfer statements and when TACTYK-PL where defined -- 
    and TACTYK-PL had the more sensible design, so it wins)
  Fixed binary ops macros (Several of them had a few bad parameters)
  Fixed if (X != 0) assembly function (it somehow didn't get updated when switching from "compare(x,y) ... cjump" to faster and more direct "if (condition) {jump}"

6 Sep 2022
  Removed builtin aliases and alternate orderings for various memory operations (the combinatorial explosion got out of hand...).  
  Use define ... undefine for setting up aliases instead.

  increased "minormath" constants range from 1-32 to 1-64.  

5 Sep 2022
  Added the "define" keyeword.  This performs simple text substitutions only (and mainly because letters a-f for "variable names" causes immediate
  conceptualization and maintainability issues).
  
  Add support for union types to the "struct" keyword handler.
  Add support for field width to the "struct" keyword handler.

  Add support for comments.  
  
  Add error messages for undefined commands.
  Add error messages for undefined subcommands (combinations of "parameters" which TACTYK-PL does not understand).

  Wrote documentaiton for TACTYK-PL (tactyk_overview.odt).
    It is not quite a formal specification, but at 5 pages, it is a start, and probably good enough for a language only intended as transitional.
  
  archive sha-256 checksum d9c0ee8f1e2d1661ae7f9f09f1db81e3d83e39b3e69512e0a50425d5b468ae88

1-3 Sep 2022
  Added partial support for C Calls.  
    This is intended only for functions with arguments stored only on registers.  More complex calls will require a more complex handler.
  Added subroutine interactions for various cases (stackless fast calls, lightweight calls, and context-switching calls).
  
  Reinstate "fastbranch" register
    Decided the "fastbranch" register is a much better use (on account of "fastcall" + "fastreturn").
    Procedural jumps are relegated to using an entry from context memory.
  
  Begin porting the Fhourstones benchmark to tactyk-pl.
    supposedly, Fhourstones is considered a realistic benchmark, so perhaps it may be a bit more respectable than quicksort
      (though it does appear to do random access against a 64 MB data set, so if TACTYK manages to "catch up" it might be better to stick with
       simple benchmarks that don't need to look much farther for data than the L1 cache...).
    This also gives an opportunity to develop structured function calls.
    
  Optimize register zero-ing. (Replace all assembly instructions like "move <reg>, 0" with "xor <reg>, <reg>")
    Would prefer to leave it as-was, but disassembly was showing that was not getting handled through optimization.

31 Aug 2022
Added a project overview document to better describe the project.

30 Aug 20224876735616/15249321597
  The quicksort test has been implemented.
  
  TEST RESULTS:
  Both native and the tactyk-pl use quicksort with Hoare's partition scheme (following the pseudocode from Wik-uhh-pedia).
  Both where given the same pseudo-randomly generated inputs.  
  Both produced the same outputs.  
  The output is checked both by a hashing function and by a stricter test for ascending order.
  Test CPU: "Intel(R) Core(TM) i7-8809G CPU @ 3.10GHz" (the test wis single-threaded).
  The native function sorted its block of memory in with a 2642296045 clock cycle differnece between start and end (2.6b clocks).
  The tactyk-pl function sorted its block of memory in with a 10006754823 clock cycle difference between start and end (10.0b clocks).
  (TACTYK-VM was used to obtain clock cycle counts - the performance impact of this measurement is assumed to be neglibigle).
  Additionally, the native code was compiled in a release profile with optimizations (-O3 -s -fexpensive-optimizations -march=native)
    (of which, only -O3 seems to make a difference, but was not noticeably better than -O1)
    (these optimizations do not affect TACTYK-VM due to its being written in Assembly Language)
  The test was repeated several times.  The tactyk-vm program consistantly ran at about 25% of the speed of the native function.

29 Aug 2022
  Add data-register stashing (program register-spilling), with plans to also implement stashing for address registers, instruciton pointers, floating point registers, and all-register stashes
  Add plans and data structure for internal program context management (program stack and coroutine support)
  Add a few memory accessors (read/write/swap element 0, push, pop, 
  Add a native quicksort algorithm (in preparation for the first serious test).

27 Aug 2022
  Add statically allocated memory blocks with preset contents to TACTYK-PL.
  Add a mechanism to dynamically select memory blocks.  Main memory model is now complete.
  
  Rewrote the project description.

26 Aug 2022
  Memory layout for asmvm internals are now defined with macros (the long list of constants was getting a bit tedious).
  Export all symbols along-side the assembled program.
  Addded a function invoker

25 Aug 2022  
  Memory blocks can now be defined by the host/runtime, attached to a context, and bound to address registers.

24 Aug 2022
  Fixed table capacity adjustment function (get_ge_powerof2).
  
  The TACTYK (should) Affix Captions To Your Kitten Programming Language (TACTYK-PL) Program Loader has attained "minimally functional" status.
    (able to implement the same fibonacci generator using text-based symbols as was previously built from raw/binary primitives)

23 Aug 2022
  Fix a fencepost error in table 
    (it was prioritized over what appeared to be be memory corruption, but turned out to be a much less severe error that simply got exposed by allocating 1-entry tables).

22 Aug 2022
  remove cgoto
  Change all conditional tests (if <condition>) to conditional branches.
    The branch target is stored in intermediates (both the offset and an actual instruction pointer).
    If the test passes, it will jump to the specified branch target.
    If the test fails, it will proceed to the next instruction.

20 Aug 2022
  repurpose "fastbranch" register.  It now holds the program length and is to be used for bounds-checking procedural jumps.
  adjust goto and cgoto to obtain the branch target from a register.
  add variants of goto and cgoto which use a branch target stored on immediate properties.  The stored immediate includes both the index of the branch target and the actual function pointer
    (to allow the branch isntruction to be executed to a bit sooner)

19 Aug 2022
  assigned immediates to a specirif register  (not quite sure this is the best use of the register, as tactykvm is designed to avoid direct acquisition of parameters as much as possible,
  but it is needed for getting variables and constants onto the registers, and so putting it on a register saves a dereference.
  
  New coding pattern for assembly:  When spilling registers, an alias is assigned to better indicate what the register is being borrowed for, then undefined at the end of the portion of code using it.

  TACTYK-VM is now an actual data strcture, and it contains contexts and programs.  Haven't quite decided if auto-allocation should be a thing or how to go about doing it.  Much of this is
  expected to be blocks of memory owned by the host program.

18 Aug 2022
  Cancel "immutable" buffers.  It was an interesting concept (and could be much better implemented by a program loader), but is outside of the scope of the project.  
  Redesigned the tactyk memory model.
    Removed the rblock system.
    The rblock data structure has been repurposed.  The large rblock array has been removed, and the rblock header has been renamed to "immediates" (and still directly shadows instructions).
    "transfer": a set of functions which manipulate data registers in fixed positions.  (rA to rF)
      For each affected register, transfer either loads a constant, or it dereferences one of four address registers and either does a memory-to-register transfer or register-to-memory.
      (based on flags)
      parameters are taken from aformentioned immediates.
      There are two main variants of transfer:  transfer32 and transfer16.  
        transfer32 transfers up to 3 words to registers rA, rB, and rC.  
        When assigning constants, its constants are 32 bits wids.
        When transfering memory, its offset is 32 bits wide (4 gigabytes addressable per-transfer).
        transfer16 transfers up to 6 words to registers rA, rB, and rC, rD, rE, and rF.  
        When assigning constants, its constants are 16 bits wids.
        When transfering memory, its offset is 16 bits wide (64 kilobytes addressable per-transfer).
        There is to be two variants of transfer32 and three of transfer16 (for different amounts of transfers)
        The transfer functions are not retargettable - use register permutations to move anything that needs to be retained out of the way.
    Global memory has been removed - Memory is now now virtual and addressable only through what's on the address registers.  
      The address pointers are pointers to buffers allocated by the runtime.
      Programs are free to offset buffers and to change which buffers are referenced on the address registers.
      Stride, current-position (persistant), and max-offset properties are to be associated with each buffer loaded into a VM Context, and used to keep it well-behaved.
      Types and namespaces can now be represented (although they are understood only as sequences of memory locations to transfer in and out of registers).
    
  

17 Aug 2022
Added a device for making runtime-generated buffers immutable (use memory protection to detect tampering by an attacker which is able to arbitrarilly read and write memory, 
but does not "own" the Process).  This will definately need to be reviewed if tactyk becomes a serious project.


16 Aug 2022
Further development on memory handling
  Simplified rblock transfers
    Removed the ability to modify context, memory, and program pointers from rblock transfers.
    Removed the ability to modify the temp pointer form rblock transfers
    Removed the register-memory manipulation logic, use the temp and program registers instead.

  Remove the notion of offset registers and use the two registers for a 3rd and 4th pointer
  Shuffled the registers around to place the current instruction and fast branch target on stack registers (these also are not directly writable and bear low values)
  Extend the rblock transfer system.  There are now three kinds of rblock transfers:
    Constant - directly transfer rblock values to registers
    Absolute - Using rblock data as absolute pointers, transfer data from memory to registers.
    Indirect - Using rblock data as indices relative to an address stored on a specified address register, transfer memory from memory to registers (with bounds-checking)

tactyk_table - performance adjustment - faster exit when checking for item not in table if/while the table is not full.
  If item deletion is added to the table, the deletion function will have to place an invalid entry in the table which is distinct from an uninitialized entry.


15 Aug 2022

Begin development of the TACTYK (should) Affix Captions To Your Kitten Programming Language (TACTYK-PL)

