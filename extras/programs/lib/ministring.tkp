# "ministring" - a utility for handling 8 and 16-char strings from memblocks containing text
#   (In TACTYK, the 8 and 16 char string is KING ... of alphanumeric data processing ... because it is as easy to handle as an integer or floating point number) 
#
# Usage:
#   Bind a memblock with text to $T
#   assign a space delimiter to rA
#   assign a line delimiter to rB
#   lwcall MINISTRING__INIT
#   lwcall MINISTRING__CONTEXT_ENTER to activate the MINISTRING context
#   lwcall MINISTRING__CONTEXT_EXIT to de-activate the MINISTRING context
#   While a MINISTRING context is active:
#     lwcall MINISTRING__NEXTLINE to select the next line
#     lwcall MINISTRING__READ._STR8 to read the next 8 chars and store them on register rA (stops at a token delimiter or end of line)
#     lwcall MINISTRING__READ_STR16 to read next 16 chars and store them on register xA (stops at a token delimiter or end of line)
#     lwcall MINISTRING__TOKENIZE to read the line, identify up to 14 tokens, extract them, and load them onto xmm registers (tokens are clipped at 16 chars if long)
#
#   Register/Stash allocation while the MINISTRING context is active:
#     rA:     char accumulator, 8-char output, eventually, 8-char input
#     rB:     read position
#     rC:     end of line
#     rD,rE:  scratch space
#     rF:     token delimiter
#     xA:     16-char output
#     s31h:   line delimiter
#   Register/Stash allocation while the MINISTRING context is inactive:
#     s29-s31:  MINISTRING context storage
#
# NOTES:
#   MINISTRING is the first *real* component that makes proper use of the TACTYK microcontext.

MINISTRING__INIT.$T:
  stash s31h rB
  assign rF rA
  assign rA rB
  assign rB 0
  assign rC $T.element_bound
  lwcall SEEK_CHAR.$T
  assign rC rB
  assign rB 0
  block-stash 5 s29 rB
  lwreturn

MINISTRING__CONTEXT_ENTER.$T:
MINISTRING__CONTEXT_EXIT.$T:
  block-stash 5 swap s29 rB
  lwreturn

MINISTRING__NEXTLINE.$T:
  assign rB rC
  inc rB
  assign rE rB
  stash rA s31h
  assign rC $T.element_bound
  lwcall SEEK_CHAR.$T
  assign rC rB
  assign rB rE
  lwreturn

# Search memblock $T for a byte with a specific value
#
# input
#   rA:   byte value to search for 
#   rB:   index of first position in buffer
#   rC:   index of limit position
# output
#   rB:   index of found byte, -1 if not found
# clobbers
#   rD
SEEK_CHAR.$T:
  if rB < rC
    load byte rD $T rB
    if rA == rD
      lwreturn
    inc rB
    goto SEEK_CHAR.$T
  assign rB -1
  lwreturn
  
# Read an 8-byte "ministring"
#
# input
#   rB:     index of string
#   rC:     index of limit
#   rF:     terminal char
# output
#   rA:     result minstring
# clobbers
#   rD rE
MINISTRING__READ_STR8.$T:
  assign rA 0
  assign rE 0
  READ_STR8.cont.$T:
  if rB >= rC
    lwreturn
  load byte rD $T rB
  if rD == rF
    lwreturn
  shift-left rD rE
  or rA rD
  inc rB
  add rE 8
  if rE == 64
    lwreturn
  goto READ_STR8.cont.$T

# Read an 16-byte "ministring"
#
# input
#   rB:     index of string
#   rC:     index of limit
#   rE:     terminal char
# output
#   xA:     result minstring
# clobbers
#   rA rB rD rE
MINISTRING__READ.$T:
MINISTRING__READ_STR16.$T:
  lwcall MINISTRING__READ_STR8.$T
  xassign xA int64 0 rA
  lwcall MINISTRING__READ_STR8.$T
  xassign xA int64 1 rA
  lwreturn

MINISTRING__TOKENIZE.$T:
  lwcall MINISTRING__READ.$T
  stash sA xA
  lwcall MINISTRING__TOKENIZE.next.$T
  if rB >= rC MINISTRING__TOKENIZE.ret.$T
  lwcall MINISTRING__READ.$T
  xassign xB xA
  lwcall MINISTRING__TOKENIZE.next.$T
  if rB >= rC MINISTRING__TOKENIZE.ret.$T
  lwcall MINISTRING__READ.$T
  xassign xC xA
  lwcall MINISTRING__TOKENIZE.next.$T
  if rB >= rC MINISTRING__TOKENIZE.ret.$T
  lwcall MINISTRING__READ.$T
  xassign xD xA
  lwcall MINISTRING__TOKENIZE.next.$T
  if rB >= rC MINISTRING__TOKENIZE.ret.$T
  lwcall MINISTRING__READ.$T
  xassign xE xA
  lwcall MINISTRING__TOKENIZE.next.$T
  if rB >= rC MINISTRING__TOKENIZE.ret.$T
  lwcall MINISTRING__READ.$T
  xassign xF xA
  lwcall MINISTRING__TOKENIZE.next.$T
  if rB >= rC MINISTRING__TOKENIZE.ret.$T
  lwcall MINISTRING__READ.$T
  xassign xG xA
  lwcall MINISTRING__TOKENIZE.next.$T
  if rB >= rC MINISTRING__TOKENIZE.ret.$T
  lwcall MINISTRING__READ.$T
  xassign xH xA
  lwcall MINISTRING__TOKENIZE.next.$T
  if rB >= rC MINISTRING__TOKENIZE.ret.$T
  lwcall MINISTRING__READ.$T
  xassign xI xA
  lwcall MINISTRING__TOKENIZE.next.$T
  if rB >= rC MINISTRING__TOKENIZE.ret.$T
  lwcall MINISTRING__READ.$T
  xassign xJ xA
  lwcall MINISTRING__TOKENIZE.next.$T
  if rB >= rC MINISTRING__TOKENIZE.ret.$T
  lwcall MINISTRING__READ.$T
  xassign xK xA
  lwcall MINISTRING__TOKENIZE.next.$T
  if rB >= rC MINISTRING__TOKENIZE.ret.$T
  lwcall MINISTRING__READ.$T
  xassign xL xA
  lwcall MINISTRING__TOKENIZE.next.$T
  if rB >= rC MINISTRING__TOKENIZE.ret.$T
  lwcall MINISTRING__READ.$T
  xassign xM xA
  lwcall MINISTRING__TOKENIZE.next.$T
  if rB >= rC MINISTRING__TOKENIZE.ret.$T
  lwcall MINISTRING__READ.$T
  xassign xN xA
  goto MINISTRING__TOKENIZE.ret.$T

MINISTRING__TOKENIZE.next.$T:
  assign rA rF
  lwcall SEEK_CHAR.$T
  add rB 1
  if rB == 0
    assign rB rC
  lwreturn
MINISTRING__TOKENIZE.ret.$T:
  stash xA sA
  lwreturn

MINISTRING__EXTRACT_UTF8:
  lwcall MINISTRING__EXTRACT_UTF8.nextbyte
  assign rA rF
  # b.0xxxxxxx: ASCII char
  if rA ~& b.10000000
    lwreturn
  
  # b.10xxxxxx: unexpected continuation byte
  if rA ~& b.01000000
    assign rA -1
    lwreturn
  
  # b.110xxxxx: 11-bit char
  if rA ~& b.00100000
    and rA b.00011111
    lwcall MINISTRING__EXTRACT_UTF8.append6bits
    lwreturn
  
  # b.1110xxxx: 16-bit char
  if rA ~& b.00010000
    and rA b.00001111
    lwcall MINISTRING__EXTRACT_UTF8.append6bits
    lwcall MINISTRING__EXTRACT_UTF8.append6bits
    lwreturn
  
  # b.11110xxx: 21-bit char
  if rA ~& b.00001000
    and rA b.00000111
    lwcall MINISTRING__EXTRACT_UTF8.append6bits
    lwcall MINISTRING__EXTRACT_UTF8.append6bits
    lwcall MINISTRING__EXTRACT_UTF8.append6bits
    lwreturn
  
  # b.11111xxx: invalid byte
  assign rA -1
  lwreturn

MINISTRING__EXTRACT_UTF8.append6bits:
  lwcall MINISTRING__EXTRACT_UTF8.nextbyte
  assign rB rE
  and rB b.11000000
  
  #continuation byte
  if rB == b.10000000
    and rE b.00111111
    shift-left rA 6
    or rA rE
    lwreturn
  assign rA -1
  lwreturn

MINISTRING__EXTRACT_UTF8.nextbyte:
  xassign rB xA int64 0
  xassign rC xA int64 1
  assign rE rB
  and rE 255
  
  assign rD rC
  and rD 255
  shift-left rD 56
  shift-right rB 8
  shift-right rC 8
  or rB rD
  xassign xA int64 0 rB
  xassign xA int64 1 rC
  
  if rF == 1
    or rB rC
    if rB == 0
      xduplicate 13 xA xB
      xassign xN 0 0
  lwreturn


MINISTRING__PRINT_TOKENS.$T:
  if xA == 0 MINISTRING__PRINT_TOKENS.end.$T
  tcall print-text-xa
  tcall print-space
  if xB == 0 MINISTRING__PRINT_TOKENS.end.$T
  tcall print-text-xb
  tcall print-space
  if xC == 0 MINISTRING__PRINT_TOKENS.end.$T
  tcall print-text-xc
  tcall print-space
  if xD == 0 MINISTRING__PRINT_TOKENS.end.$T
  tcall print-text-xd
  tcall print-space
  if xE == 0 MINISTRING__PRINT_TOKENS.end.$T
  tcall print-text-xe
  tcall print-space
  if xF == 0 MINISTRING__PRINT_TOKENS.end.$T
  tcall print-text-xf
  tcall print-space
  if xG == 0 MINISTRING__PRINT_TOKENS.end.$T
  tcall print-text-xg
  tcall print-space
  if xH == 0 MINISTRING__PRINT_TOKENS.end.$T
  tcall print-text-xh
  tcall print-space
  if xI == 0 MINISTRING__PRINT_TOKENS.end.$T
  tcall print-text-xi
  tcall print-space
  if xJ == 0 MINISTRING__PRINT_TOKENS.end.$T
  tcall print-text-xj
  tcall print-space
  if xK == 0 MINISTRING__PRINT_TOKENS.end.$T
  tcall print-text-xk
  tcall print-space
  if xL == 0 MINISTRING__PRINT_TOKENS.end.$T
  tcall print-text-xl
  tcall print-space
  if xM == 0 MINISTRING__PRINT_TOKENS.end.$T
  tcall print-text-xm
  tcall print-space
  if xN == 0 MINISTRING__PRINT_TOKENS.end.$T
  tcall print-text-xn
  tcall print-space
  MINISTRING__PRINT_TOKENS.end.$T:
  lwreturn
