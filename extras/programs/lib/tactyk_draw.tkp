
struct gx_pixel
  32 components
  . 16 channel_ABCD
  16 channel_EFGH
  32 normals
  . 16 normal_ABCD
  16 normal_EFGH
  4 a
  4 b
  4 c
  4 d
  4 e
  4 f
  4 g
  4 h
  # positions of global normal and color tables
  16 gdata_indices
  . 4 index_gnorm1
  4 index_gnorm2
  4 index_gcolors1
  4 index_gcolors2
  # additive blend factors
  16 gdata_blend_factors
  . 4 blend_gcolors1
  4 blend_gcolors2
  4 blend_gnorm1
  4 blend_gnorm2

struct gx_info
  32 g_normals
  . 16 normals_ABCD
  16 normals_EFGH
  128 g_colors
  . 64 cmat_1a
  64 cmat_1b
  64 cmat_2a
  64 cmat_2b
  > 65536 g_data
  
  16 view_size
  . 8 width
  8 height
  
  16 fbuf_size
  . 8 fb_width
  8 fb_height
  
  16 world_position
  . 8 x
  8 y
  
  128 rasterizer_data
  65536 properties

struct gx_program
  128 functions
  . 8 f0
  8 f1
  8 f2
  8 f3
  8 f4
  8 f5
  8 f6
  8 f7
  8 f8
  8 f9
  8 f10
  8 f11
  8 f12
  8 f13
  8 f14
  8 f15
  0 end
  3968 data

mem m_gx_info gx_info 1
mem m_gx_drawprogram gx_program 1

# Initialize and obtain a window from SDL
#   At some point, if/when there is a desire to perform off-display rendering, 
#   responsibility for buffer generation and binding will have to be transferred elsewhere.
GX.mk_window:
  bind addr2 m_gx_info
  load qword rA addr2 gx_info.width
  load qword rB addr2 gx_info.height
  assign rC gx_pixel_size
  assign rD 3
  tcall sdl--new
  lwreturn

# Obtain references to tactyk-draw memory
#   All tactyk address registers are used (addr1 is used by renderers for instance-ish parameters), so other components needing memory will have to rebind it.
GX.bind_memblocks:
  tcall sdl--get-framebuffer
  bind addr3 addr1
  tcall sdl--get-scratchbuffer
  bind addr4 addr1
  bind addr2 m_gx_info
  store dword addr2 gx_info.fb_width rA
  store dword addr2 gx_info.fb_height rB
  
  lwreturn

# Convert all pixels from the complex internal format to 32-bit integer rgba
# 
# Per pixel, this multiplies the global colors by pixel blending factors
# Pixel blending factors are obtained by comparing pixel normals with global normals, subtracting the deviation from one, then multiplying the inverted deviation by pixel values
#
# For now, this is a software shader.
# At some point, responsibility for this may be transferred to the tactyk-runtime, with the conversion ported to GLSL and used as the final stage in a deferred rendering pipeline.
GX.to_rgba:
  # fetch dimensions
  load qword rE addr2 gx_info.fb_width
  load qword rC addr2 gx_info.fb_height
  load qword rB addr2 gx_info.width
  load qword rD addr2 gx_info.height
  assign rC rE
  mul rC rD
  mul rE 4
  mul rC 4
  mul rB 4
  assign rD rE
  sub rD rB
  
  # rE:  (fbwidth) * 4            [fb line size]
  # rC:  (fbwidth * height * 4)   [v-end]
  # rB:  (width * 4)              [line-end]
  # rD:  (fbwidth-width) * 4      ["h-blank"]
  
  assign rA 0
  
  xassign xA 0.0   0.0   0.0   0.0
  xassign xB 255.0 255.0 255.0 255.0
  
  # block-load 2 xxC addr2 gx_info.g_normals
  
  DRAW_ROW:
  if rA < rC
    stash sAl rC sAh rD sBl rE
    DRAW_PIXEL:
    if rA < rB
      # next position in buffer 
      assign rC rA
      shift-left rC 5
      assign addr3.offset rA
      assign addr4.offset rC
      
      # get local color/shading data
      load oword xC addr4 gx_pixel.gdata_indices
      unpack int32.4 rC xC
      load oword xG addr4 gx_pixel.gdata_blend_factors
      unpack float32.4 xC xG
      
      # blended local normals
      block-load 2 xxG addr2 rC
      block-load 2 xxI addr2 rD
      xmul 2 xvG float32 xE
      xmul 2 xvI float32 xF
      xadd 2 xvI float32 xvG float32
      
      # get pixel color/shading data
      block-load 4 xxK addr4 0
      xassign xE xA
      xassign xF xA
      
      # compare normals to obtain blending factors
      #   inverse absolute value of deviation between pixel normals and global normals, low values clamped to zero
      xsub 2 xvM float32 xvI float32
      xsub 2 xvE float32 xvM float32
      xmin 2 xvM float32 xvE float32
      xadd 2 xvM float32 1.0
      xmax 2 xvM float32 xA float32
      
      # combine it with channel values
      xmul 2 xvM float32 xvK float32
      # xduplicate 2 xM xK
      
      # load the first pair of 4 local colors (8 total), blend, apply to values, store
      #   (these color values establish color model on a per-pixel basis)
      block-load 4 xxE addr2 rE
      block-load 4 xxI addr2 rF
      
      xmul 4 xvE float32 xC
      xmul 4 xvI float32 xD
      xadd 4 xvE float32 xvI float32
      xmul 4 xvE float32 xM float32
      transpose xE
      xadd 4 xA float32 xvE float32
      
      # repeat with the second pair of 8 local colors
      add rE 64
      add rF 64
      block-load 4 xxE addr2 rE
      block-load 4 xxI addr2 rF
      xmul 4 xvE float32 xC
      xmul 4 xvI float32 xD
      xadd 4 xvE float32 xvI float32
      xmul 4 xvE float32 xN float32
      transpose xE
      xadd 4 xA float32 xvE float32
      
      # scale to range 0-255 and clip
      xmul xA float32 xB float32
      xmin xA float32 xB float32
      
      # move it out of the way, initialize the next pixel,
      # and use the re-initailzied pixel to remove negative components from the output pixel
      xassign xI xA
      xassign xA 0.0 0.0 0.0 0.0
      xmax xI float32 xA float32
      
      # convert and pack to obtain an integer RGBA value
      unpack float32.4 xE xI
      xassign xI int8 0 xE
      xassign xI int8 1 xF
      xassign xI int8 2 xG
      xassign xI int8 3 xH
      
      # write to framebuffer
      xassign rF xI int32 0
      store dword addr3 0 rF
      
      # iterate (next pixel in current row)
      add rA 4
      goto DRAW_PIXEL
    
    stash rC sAl rD sAh rE sBl
    add rB rE
    add rA rD
    goto DRAW_ROW
  
  tcall sdl--upload-framebuffer
  tcall sdl--render
  lwreturn

# fill a rectangular area
GX.fill.rect:
  bind addr1 m_gx_drawprogram
  assign rF 0
  lwcall GX.rect.fill
  lwcall GX.fills.simple
  lwcall GX.util.exit
  assign rF 0
  goto GX.draw

# draw an inset outline around a rectangular area
GX.trace.rect:
  bind addr1 m_gx_drawprogram
  assign rF 0
  lwcall GX.rect.outline
  lwcall GX.fills.simple
  lwcall GX.util.exit
  assign rF 0
  goto GX.draw

# main rendering driver
GX.draw:
  if rF == 1
    lwreturn
  assign rF 0
  load qword rE addr1 gx_program.f0
  lwcall rE
  goto GX.draw

# basic filling function
# This performs a simple overwrite of all color channels and normals
GX.fills.simple:
  block-store 4 addr1 gx_program.data xxA
  assign rA GX.fills.simple.impl
  store qword addr1 rF rA
  add rF 8
  lwreturn
GX.fills.simple.impl:
  block-load 4 xxA addr1 gx_program.data
  block-store 4 addr4 0 xxA
  add rF 8
  if rF == gx_program.end
    lwreturn
  load qword rE addr1 rF
  goto rE

GX.texture:
  assign rA GX.texture.impl
  store qword addr1 rF rA
  add rF 8
  lwreturn
GX.texture.impl:
  assign xA 1.0
  add rF 8
  if rF == gx_program.end
    lwreturn
  load qword rE addr1 rF
  goto rE
GX.transfer.ch0:
  assign rA GX.transfer.ch0.impl
  store qword addr1 rF rA
  add rF 8
  lwreturn
GX.transfer.ch0.impl:
  store float32 addr4 0 xA
  add rF 8
  if rF == gx_program.end
    lwreturn
  load qword rE addr1 rF
  goto rE
GX.transfer.ch1:
  assign rA GX.transfer.ch1.impl
  store qword addr1 rF rA
  add rF 8
  lwreturn
GX.transfer.ch1.impl:
  store float32 addr4 4 xA
  add rF 8
  if rF == gx_program.end
    lwreturn
  load qword rE addr1 rF
  goto rE
GX.transfer.ch2:
  assign rA GX.transfer.ch2.impl
  store qword addr1 rF rA
  add rF 8
  lwreturn
GX.transfer.ch2.impl:
  store float32 addr4 8 xA
  add rF 8
  if rF == gx_program.end
    lwreturn
  load qword rE addr1 rF
  goto rE
GX.transfer.ch3:
  assign rA GX.transfer.ch3.impl
  store qword addr1 rF rA
  add rF 8
  lwreturn
GX.transfer.ch3.impl:
  store float32 addr4 12 xA
  add rF 8
  if rF == gx_program.end
    lwreturn
  load qword rE addr1 rF
  goto rE
GX.transfer.ch4:
  assign rA GX.transfer.ch4.impl
  store qword addr1 rF rA
  add rF 8
  lwreturn
GX.transfer.ch4.impl:
  store float32 addr4 16 xA
  add rF 8
  if rF == gx_program.end
    lwreturn
  load qword rE addr1 rF
  goto rE
GX.transfer.ch5:
  assign rA GX.transfer.ch5.impl
  store qword addr1 rF rA
  add rF 8
  lwreturn
GX.transfer.ch5.impl:
  store float32 addr4 20 xA
  add rF 8
  if rF == gx_program.end
    lwreturn
  load qword rE addr1 rF
  goto rE
GX.transfer.ch6:
  assign rA GX.transfer.ch6.impl
  store qword addr1 rF rA
  add rF 8
  lwreturn
GX.transfer.ch6.impl:
  store float32 addr4 24 xA
  add rF 8
  if rF == gx_program.end
    lwreturn
  load qword rE addr1 rF
  goto rE
GX.transfer.ch7:
  assign rA GX.transfer.ch7.impl
  store qword addr1 rF rA
  add rF 8
  lwreturn
GX.transfer.ch7.impl:
  store float32 addr4 28 xA
  add rF 8
  if rF == gx_program.end
    lwreturn
  load qword rE addr1 rF
  goto rE
  

# return from a renderer
GX.util.exit:
  assign rA GX.util.exit.impl
  store qword addr1 rF rA
  add rF 8
  lwreturn
GX.util.exit.impl:
  assign rF gx_program.end
  lwreturn


