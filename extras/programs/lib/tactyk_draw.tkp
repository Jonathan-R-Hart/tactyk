
struct gx_pixel
  32 components
  . 16 channel_ABCD
  16 channel_EFGH
  32 normals
  . 16 normal_ABCD
  16 normal_EFGH
  64 shader_data
  . 4 x
  4 y
  4 u
  4 v
  4 depth
  4 normal
  4 s
  4 t
  32 unused

struct gx_info
  16 view_size
  . 8 width
  8 height
  
  16 fbuf_size
  . 8 fb_width
  8 fb_height
  
  16 world_position
  . 8 x
  8 y
  
  128 g_colors
  . 16 g_color_A
  16 g_color_B
  16 g_color_C
  16 g_color_D
  16 g_color_E
  16 g_color_F
  16 g_color_G
  16 g_color_H
  
  32 g_normals
  . 4 g_normal_A
  4 g_normal_B
  4 g_normal_C
  4 g_normal_D
  4 g_normal_E
  4 g_normal_F
  4 g_normal_G
  4 g_normal_H
  
  48 rasterizer_data
  . 8 raster_x
  8 raster_x2
  8 raster_y
  8 raster_x1
  8 raster_y2
  8 raster_y1

struct gx_program
  120 functions
  . 8 f0
  8 f1
  8 f2
  8 f3
  8 f4
  8 f5
  8 f6
  8 f7
  8 f8
  8 f9
  8 f10
  8 f11
  8 f12
  8 f13
  8 f14
  8 first
  3968 data

struct gx_program__standard
  120 functions
  . 8 f0
  8 f1
  8 f2
  8 f3
  8 f4
  8 f5
  8 f6
  8 f7
  8 f8
  8 f9
  8 f10
  8 f11
  8 f12
  8 f13
  8 f14
  8 first
  3968 data
  . 16 components_ABCD
  16 components_EFGH
  16 normals_ABCD
  16 normals_EFGH
  64 blend_mat_components_ABCD
  64 blend_mat_components_DEFG
  64 blend_mat_normals_ABCD
  64 blend_mat_normals_EFGH

mem m_gx_info gx_info 1
mem m_gx_drawprogram gx_program 1

GX.mk_window:
  bind addr2 m_gx_info
  load qword rA addr2 gx_info.width
  load qword rB addr2 gx_info.height
  assign rC gx_pixel_size
  assign rD 3
  tcall sdl--new
  lwreturn

GX.bind_memblocks:
  tcall sdl--get-framebuffer
  bind addr3 addr1
  tcall sdl--get-scratchbuffer
  bind addr4 addr1
  bind addr2 m_gx_info
  store dword addr2 gx_info.fb_width rA
  store dword addr2 gx_info.fb_height rB
  lwreturn

GX.cliprect:
  lwreturn

GX.fillrect:
  stash sA rA sB rB sC rC
  tcall print-newline
  FILL_ROW:
  if rD < rF
    stash rA sA
    mul rA rD
    add rA rC
    assign rB rA
    mul rA 4
    mul rB gx_pixel_size
    FILL_PIXEL:
    if rC < rE
      assign addr4.offset rB
      block-store 4 addr4 0 xxA
      add rA 4
      add rB gx_pixel_size
      inc rC
      goto FILL_PIXEL
    inc rD
    stash rC sC 
    goto FILL_ROW
  stash rA sA rB sB
  lwreturn

# A post-compositing pixel shader
# 
# Per pixel, this multiplies the global colors by pixel blending factors
# Pixel blending factors are obtained by comparing pixel normals with global normals, subtracting the deviation from one, then multiplying the inverted deviation by pixel values
#
# For now, this is a software shader.
# At some point, it may be ported to GLSL and used as the final stage in a deferred rendering pipeline.

GX.render:
  # fetch dimensions
  load qword rA addr2 gx_info.fb_width
  load qword rB addr2 gx_info.fb_height
  load qword rC addr2 gx_info.width
  load qword rD addr2 gx_info.height
  assign rB rA
  mul rB rD
  mul rA 4
  mul rB 4
  mul rC 4
  assign rD rA
  sub rD rC
  
  # rA:  (fbwidth) * 4            [fb line size]
  # rB:  (fbwidth * height * 4)   [v-end]
  # rC:  (width * 4)              [line-end]
  # rD:  (fbwidth-width) * 4      ["h-blank"]
  
  assign rE 0
  
  xassign xA 0.0   0.0   0.0   0.0
  xassign xB 255.0 255.0 255.0 255.0
  
  block-load 2 xxC addr2 gx_info.g_normals
  
  DRAW_ROW:
  if rE < rB
    DRAW_PIXEL:
    if rE < rC
      shift-left rE 5
      assign addr4.offset rE
      block-load 4 xxK addr4 0
      shift-right rE 5
      xassign xE xA
      xassign xF xA
      
      # get negated absolute value of deviation between pixel normals and global normals
      xsub 2 xvM float32 xvC float32
      xsub 2 xvE float32 xvM float32
      xmin 2 xvM float32 xvE float32
      
      # Add one to obtain a "diffuse" value, clamp at 0
      xadd 2 xvM float32 1.0
      xmax 2 xvM float32 xA float32
      
      # multiply raw weights by channel values to obtain blend factors
      xmul 2 xvM float32 xvK float32
      
      # multiply each global color by the blending factors
      block-load 8 xxE addr2 gx_info.g_colors
      xmul 4 xvE float32 xM float32
      xmul 4 xvI float32 xN float32
      
      # mix the colors, scale to range 0-255, and clip to 255
      xadd 8 xA float32 xvE float32      
      xmul xA float32 xB float32
      xmin xA float32 xB float32
      
      # move it out of the way, re-initialize the next pixel,
      # and use the re-initailzied pixel to remove negative components from the output pixel
      xassign xI xA
      xmax xI float32 xA float32
      xassign xA 0.0 0.0 0.0 0.0
      
      # convert and repack to integer RGBA
      unpack float32.4 xE xI
      xassign xI int8 0 xE
      xassign xI int8 1 xF
      xassign xI int8 2 xG
      xassign xI int8 3 xH
      
      # write to framebuffer
      xassign rF xI int32 0
      assign addr3.offset rE
      store dword addr3 0 rF
      
      # iterate (next pixel in current row)
      add rE 4
      goto DRAW_PIXEL

    add rC rA
    add rE rD
    goto DRAW_ROW
  
  tcall sdl--upload-framebuffer
  tcall sdl--render
  lwreturn

GX.draw:
  
  lwreturn

GX.draw.fillrect:
  bind addr1 m_gx_drawprogram
  block-store 4 addr1 gx_program__standard.data xxA
  block-store 4 addr2 gx_info.rasterizer_data rA
  # input:
  # x1 y1 w  h  .  .

  # x1 y1 w  h  .  y1
  assign rF rB

  # x1 x2 y1 h  .  y1
  swap rB rC
  add rB rA
  
  # x1 x2 y1 h  y2 y1
  assign rE rD
  add rE rC
  
  # x1 x2 y1 x1 y2 y1
  assign rD rA

  # x  x2 y  x1 y2 y1
  dec rA
  block-store 6 addr2 gx_info.rasterizer_data rA
  
  #48 rasterizer_data
  #. 8 raster_x
  #8 raster_x2
  #8 raster_y
  #8 raster_x1
  #8 raster_y2
  #8 raster_y1

  assign rA 8
  assign rB GX.raster.AABox
  assign rC GX.shader.simple
  store qword addr1 gx_program__standard.first rA
  store qword addr1 gx_program__standard.f1 rB
  store qword addr1 gx_program__standard.f0 rC
  
  DRAW_LOOP:
  if rF == 1
    lwreturn
  assign rF 8
  lwcall GX.raster.AABox
  goto DRAW_LOOP

# Axis-aligned box rasterizer
GX.raster.AABox:
  # fetch rasterizer globals
  block-load 3 rA addr2 gx_info.rasterizer_data
  # rA: raster_x
  # rB: raster_x2
  # rC: raster_y
  
  # advance one pixel
  inc rA
  if rA == rB
    block-load 2 rA addr2 gx_info.raster_x1
    # rA: raster_x1
    # rB: raster_y2
    # rC: raster_y
    inc rC
    store qword addr2 gx_info.raster_y rC
    if rB == rC
      assign rF 1
      lwreturn
  store qword addr2 gx_info.raster_x rA
  
  # rA: raster_x
  # rB: buffer position
  # rC: raster_y
  load qword rB addr2 gx_info.fb_width
  mul rB rC
  add rB rA
  
  # should consider generating binary-log2 constants for struct sizes which are powers of two
  #shift-left rB 2
  #assign addr3.offset rB
  #shift-left rB 5
  #assign addr4.offset rB
  shift-left rB 7
  assign addr4.offset rB
  
  # rA: raster_x  (u)
  # rB: x         (absolute x)
  # rC: raster_y  (v)
  # rD: y         (absolute y)
  
  swap rA rB
  swap rB rD
  swap rC rD
  
  # rA: x         (absolute x)
  # rB: y         (absolute y)
  # rC: raster_x  (u)
  # rD: raster_y  (v)

  load qword rA addr2 gx_info.x
  load qword rB addr2 gx_info.y
  add rA rC
  add rB rD
  
  pack float32.4 xA rA
  store oword addr4 gx_pixel.x xA
  
  #store dword addr4 gx_pixel.x rB
  #store dword addr4 gx_pixel.y rD
  #store dword addr4 gx_pixel.u rA
  #store dword addr4 gx_pixel.v rC
  
  sub rF 8
  if rF == -8
    lwreturn
  load qword rE addr1 rF
  goto rE

GX.raster.AASquare:
  
  sub rF 8
  if rF == -8
    lwreturn
  load qword rE addr1 rF
  goto rE

GX.shader.simple:
  block-load 4 xxA addr1 gx_program__standard.data
  block-store 4 addr4 0 xxA
  
  sub rF 8
  if rF == -8
    lwreturn
  load qword rE addr1 rF
  goto rE



