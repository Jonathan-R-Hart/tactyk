# A bitmap font renderer for TACTYK
#
# This is intended for rendering text using 16x16 1-bit graphics, but as-written can handle a glyph size up to 16x28,
#   and includes a specified (but unimplemented) mechanism for rendering arbitrary color depth with multiple bit planes
#
# The intent of this is a bit beyond a simple demo:
#   The complexity of a text rendering engine gets factored out it it can be handled entirely within the virtual machine.
#   (and likewise the entire User Interface, program graphical representation, and program logic)

struct gx_info__text
  2048 program_alloc
  4096 general_alloc
  48 view_alloc
  128 rasterizer_alloc
  2592 ptxp_alloc
  6400 irrv_alloc
  256 text_alloc
  . 4 len
  4 position
  4 row
  4 col
  4 x
  4 y
  2 fragment
  2 value
  228 text

struct s_glyph
  8 key
  8 offset_x
  8 offset_y
  8 displacement
  32 data

# A bitmap "sprite"
# Each sprite uses 64 bytes of memory, with 8 reserved for properties and 56 reserved for pixels
# The pixel memory is a a 16x28 patch of 1-bit pixels laid out in row-major order.
# Pixels within a rows are in bitwise little endian order (the least significant bit is the left-most pixel)
#   and may be iterated with bitwise right-shift
# Properties:
#   next - a reference to another entry within a sprite sheet (to suypport the use of multiple bitmap components to render a sprite)
#   offset - signed pixel offset from base position to the left-most pixel in the first row
#   displacement - signed pixel offset to apply to the base position after a sprite is rendered (context-dependent interpretation)
#   rows - number of pixel rows to draw (ideally, this is a measurement of the number of non-empty rows in the bitmap)
#   value - lookup table index (also intended to help with chain-rendering)
struct s_bmp_16x28
  2 next
  1 offset_x
  1 offset_y
  1 displacement_x
  1 displacement_y
  1 rows
  1 value
  56 data

mem m_bmp_16x28 s_bmp_16x28 65536

# Load a memblock with data extracted from Unifont, arrange it in memory, and reformat it
BMPFNT_LD_TKPFONT:
  bind addr2 m_bmp_16x28
  assign rA 0
  assign rF addr1.element_bound
  sub rF 16
  
  assign xA 'Bound:
  tcall print-text-xa
  tcall print-space
  tcall print-int-f
  tcall print-newline
  
  BMPFNT_LD_UNIFONT.lp:
    if rA >= rF BMPFNT_LD_UNIFONT.ret
    
    # fetch the batch of of fields
    block-load 4 rB addr1 rA
    
    # As a side-effect of the bitmap iteration, relative positions are offset one pixel to the right, so it needs to be corrected for consistent positioning
    sub rC 1
    
    # select position in bitmap data block
    and rB h.ffff
    mul rB s_bmp_16x28_size
    assign addr2.offset rB
    store byte addr2 s_bmp_16x28.offset_x rC
    store byte addr2 s_bmp_16x28.offset_y rD
    store byte addr2 s_bmp_16x28.displacement_x rE
    
    # set a few defaults (recognized by the renderer for flexibility, but not handled or provided by the bdf extracter)
    spread rB 0 16 1
    store word addr2 s_bmp_16x28.next rB
    store byte addr2 s_bmp_16x28.displacement_y rB
    store byte addr2 s_bmp_16x28.rows rC
    store byte addr2 s_bmp_16x28.value rD
    
    # copy the bitmap
    # The bdf extractor only yields a 16x16 block
    #   A 16x12 segment will be left empty
    add rA 32
    block-load 2 xxA addr1 rA
    block-store 2 addr2 s_bmp_16x28.data xxA
    add rA 32

    goto BMPFNT_LD_UNIFONT.lp
  BMPFNT_LD_UNIFONT.ret:
  lwreturn

# take a max-8-char text chunk from register rA and initialize the text renderer with it
GX.text.bmp16x16.8bitENC.chunk8:
  stash sAl rF sAh rB sBl rC
  assign rD rA
  assign rE gx_info__text.text
  assign rF 0
  GX.text.bmp16x16.8bitENC.chunk8.lp:
  if rD == 0 GX.text.bmp16x16.8bitENC.prologue
  inc rF
  store byte addr2 rE rD
  shift-right rD 8
  add rE 2
  goto GX.text.bmp16x16.8bitENC.chunk8.lp

# take a max-16-char text chunk from register xA and initialize the text renderer with it
GX.text.bmp16x16.8bitENC.chunk16:
  stash sAl rF sAh rB sBl rC
  xassign rD xA int64 0
  assign rE gx_info__text.text
  assign rF 0
  
  GX.text.bmp16x16.8bitENC.chunk16.lp1:
  if rD == 0 GX.text.bmp16x16.8bitENC.chunk16.2
  inc rF
  store byte addr2 rE rD
  shift-right rD 8
  add rE 2
  goto GX.text.bmp16x16.8bitENC.chunk16.lp1
  
  GX.text.bmp16x16.8bitENC.chunk16.2:
  xassign rD xA int64 1
  
  GX.text.bmp16x16.8bitENC.chunk16.lp2:
  if rD == 0 GX.text.bmp16x16.8bitENC.prologue
  inc rF
  store byte addr2 rE rD
  shift-right rD 8
  add rE 2
  
  goto GX.text.bmp16x16.8bitENC.chunk16.lp2

GX.text.bmp16x16.8bitENC.prologue:
  assign rA rF
  stash rF sAl
  goto GX.text.bmp16x16

# text renderer setup
#  Not intended for direct invocation (due to an inconsistant interface)
GX.text.bmp16x16:
  bind addr1 m_bmp_16x28
  load word rB addr2 gx_info__text.text
  mul rB s_bmp_16x28_size
  assign addr1.offset rB
  load sbyte rD addr1 s_bmp_16x28.offset_x
  load sbyte rE addr1 s_bmp_16x28.offset_y
  
  stash rB sAh rC sBl
  add rB rD
  add rC rE
  store dword addr2 gx_info__text.len rA
  store dword addr2 gx_info__text.x rB
  store dword addr2 gx_info__text.y rC
  assign rD 0
  store dword addr2 gx_info__text.position rD
  store dword addr2 gx_info__text.row rD
  store dword addr2 gx_info__text.col rD
  # store dword addr2 gx_info__text.value rD

  load word rA addr1 s_bmp_16x28.data
  store word addr2 gx_info__text.fragment rA
  load word rA addr2 gx_info__text.value
  store word addr2 gx_info__text.value rA
  
  assign rA GX.text.bmp16x16.impl
  store qword addr2 rF rA
  add rF 8
  lwreturn

# text renderer
GX.text.bmp16x16.impl:
  load word rA addr2 gx_info__text.fragment
  load dword rC addr2 gx_info__text.x
  load dword rD addr2 gx_info__text.y
  load dword rE addr2 gx_info__text.row
  add rD rE
  load dword rE addr2 gx_info__text.col
  
  # if bit available
  GX.text.bmp16x16.scan:
  find-bit rB rA
    
    inc rB
    
    shift-right rA rB
    add rE rB
    store word addr2 gx_info__text.fragment rA
    store word addr2 gx_info__text.col rE
    
    # calculate the buffer index of the pixel
    load qword rB addr2 gx_info__view.fb_width
    mul rB rD
    add rB rE
    add rB rC
    shift-left rB 7
    
    # bind pixel
    assign addr4.offset rB
    
    load byte rA addr1 s_bmp_16x28.value
    
    # proceed to the next renderer operation
    add rF 8
    if rF == gx_info__program.end
      lwreturn
    load qword rE addr2 rF
    goto rE
  
  # next row
  load dword rA addr2 gx_info__text.row
  load byte rE addr1 s_bmp_16x28.rows
  inc rA
  
  # if the last row of pixels has been rendered, proceed to the next char
  if rA >= rE
    load dword rA addr2 gx_info__text.position
    inc rA
    store dword addr2 gx_info__text.position rA
    
    # if the last char has been rendered, exit the rendering function
    load dword rB addr2 gx_info__text.len
    if rA >= rB
      assign rF 1
      lwreturn
    
    # select the next position in the text
    mul rA 2
    add rA gx_info__text.text
    
    # select the glyph
    load word rA addr2 rA
    mul rA s_bmp_16x28_size
    assign addr1.offset rA
    
    # fetch the immediately required data for the next iteration and store it in the main renderer properties
    load word rA addr1 s_bmp_16x28.data
    store word addr2 gx_info__text.fragment rA
    load dword rB addr2 gx_info__text.y
    
    # apply displacement to obtain the offset of the first row
    load sbyte rE addr1 s_bmp_16x28.displacement_x
    load sbyte rD addr1 s_bmp_16x28.displacement_y
    add rC rE
    add rD rB
    store word addr2 gx_info__text.x rC
    store word addr2 gx_info__text.y rD
    
    # reset row/col position
    assign rE 0
    store dword addr2 gx_info__text.row rE
    store dword addr2 gx_info__text.col rE
    
    # proceed to the next renderer operation
    # (for the pixel which was selected above by "GX.text.bmp16x16.scan", not the newly staged pixel)
    add rF 8
    if rF == gx_info__program.end
      lwreturn
    load qword rE addr2 rF
    goto rE
  
  # if more rows to draw
  # reset column position and proceed to the next row
  assign rE 0  
  store dword addr2 gx_info__text.row rA
  store dword addr2 gx_info__text.col rE
  inc rD
  
  # fetch the next row of pixels
  mul rA 2
  add rA s_bmp_16x28.data
  load word rA addr1 rA
  store word addr2 gx_info__text.fragment rA

  # render the first pixel
  #  (there were no remaining pixels to render in the prior row, so immediately re-enter the loop and try again)
  goto GX.text.bmp16x16.scan











