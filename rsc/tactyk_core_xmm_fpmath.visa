
instruction square-root
  operand
    type xmmx
    $A $VALUE
  opt-operand
    type xmmx
    $B $VALUE
  select-template
    case X
      code
        sqrtsd $A, $A
    case XX
      code
        sqrtsd $A, $B

extend instruction load select-template
  case B128XAD
    sub tmp ra
    code
      mov rTEMPA_32, fs:[$CTX_ELEMENT_BOUND + random_const_FS]
      sub rTEMPA_32, 15
      cmp $OFFSET, rTEMPA
      errorge STATUS_ROGUE_POINTER
      cmp $OFFSET, 0
      errorlt STATUS_ROGUE_POINTER
      cmp $ADDRESS_REGISTER, 0
      erroreq STATUS_UNBOUND_MEMORY
      lfence
      movdqu $DEST__DATA_REG, [$ADDRESS_REGISTER+$OFFSET]
      $RESET_TEMP
  case B128XAI B128XAC
    sub tmp ra
    sub tmp rc
    code
      $LD_OFFSET_IMMEDIATE
      mov rTEMPA_32, fs:[$CTX_ELEMENT_BOUND + random_const_FS]
      sub rTEMPA_32, 15
      cmp rTEMPC, rTEMPA
      errorge STATUS_ROGUE_POINTER
      cmp rTEMPC, 0
      errorlt STATUS_ROGUE_POINTER
      cmp $ADDRESS_REGISTER, 0
      erroreq STATUS_UNBOUND_MEMORY
      lfence
      movdqu $DEST__DATA_REG, [$ADDRESS_REGISTER+rTEMPC]
      $RESET_TEMP
  
  case F64XAD
    sub tmp ra
    code
      mov rTEMPA_32, fs:[$CTX_ELEMENT_BOUND + random_const_FS]
      sub rTEMPA_32, 7
      cmp $OFFSET, rTEMPA
      errorge STATUS_ROGUE_POINTER
      cmp $OFFSET, 0
      errorlt STATUS_ROGUE_POINTER
      cmp $ADDRESS_REGISTER, 0
      erroreq STATUS_UNBOUND_MEMORY
      
      lfence
      
      movq $DEST__DATA_REG, [$ADDRESS_REGISTER+$OFFSET]
      $RESET_TEMP
  case F64XAI F64XAC
    sub tmp ra
    sub tmp rc
    code
      $LD_OFFSET_IMMEDIATE
      
      mov rTEMPA_32, fs:[$CTX_ELEMENT_BOUND + random_const_FS]
      sub rTEMPA_32, 7
      cmp rTEMPC, rTEMPA
      errorge STATUS_ROGUE_POINTER
      cmp rTEMPC, 0
      errorlt STATUS_ROGUE_POINTER
      cmp $ADDRESS_REGISTER, 0
      erroreq STATUS_UNBOUND_MEMORY
      
      lfence
      
      movq $DEST__DATA_REG, [$ADDRESS_REGISTER+rTEMPC]
      $RESET_TEMP
  case F64DAD
    sub tmp ra
    sub tmp xa
    code
      mov rTEMPA_32, fs:[$CTX_ELEMENT_BOUND + random_const_FS]
      sub rTEMPA_32, 7
      cmp $OFFSET, rTEMPA
      errorge STATUS_ROGUE_POINTER
      cmp $OFFSET, 0
      errorlt STATUS_ROGUE_POINTER
      cmp $ADDRESS_REGISTER, 0
      erroreq STATUS_UNBOUND_MEMORY
      
      lfence
      
      movq xTEMPA, [$ADDRESS_REGISTER+$OFFSET]
      cvttsd2si $DEST__DATA_REG, xTEMPA
      
      $RESET_TEMP

  case F64DAI F64DAC
    sub tmp ra
    sub tmp rc
    sub tmp xa
    code
      $LD_OFFSET_IMMEDIATE
      
      mov rTEMPA_32, fs:[$CTX_ELEMENT_BOUND + random_const_FS]
      sub rTEMPA_32, 7
      cmp rTEMPC, rTEMPA
      errorge STATUS_ROGUE_POINTER
      cmp rTEMPC, 0
      errorlt STATUS_ROGUE_POINTER
      cmp $ADDRESS_REGISTER, 0
      erroreq STATUS_UNBOUND_MEMORY
      
      lfence
      
      movq xTEMPA, [$ADDRESS_REGISTER+rTEMPC]
      cvttsd2si $DEST__DATA_REG, xTEMPA

      $RESET_TEMP
  
  case F32XAD
    sub tmp ra
    code
      mov rTEMPA_32, fs:[$CTX_ELEMENT_BOUND + random_const_FS]
      sub rTEMPA_32, 3
      cmp $OFFSET, rTEMPA
      errorge STATUS_ROGUE_POINTER
      cmp $OFFSET, 0
      errorlt STATUS_ROGUE_POINTER
      cmp $ADDRESS_REGISTER, 0
      erroreq STATUS_UNBOUND_MEMORY
      
      lfence
      
      cvtss2sd $DEST__DATA_REG, [$ADDRESS_REGISTER+$OFFSET]
      $RESET_TEMP
  case F32XAI F32XAC
    sub tmp ra
    sub tmp rc
    code
      $LD_OFFSET_IMMEDIATE
      
      mov rTEMPA_32, fs:[$CTX_ELEMENT_BOUND + random_const_FS]
      sub rTEMPA_32, 3
      cmp rTEMPC, rTEMPA
      errorge STATUS_ROGUE_POINTER
      cmp rTEMPC, 0
      errorlt STATUS_ROGUE_POINTER
      cmp $ADDRESS_REGISTER, 0
      erroreq STATUS_UNBOUND_MEMORY
      
      lfence
      
      cvtss2sd $DEST__DATA_REG, [$ADDRESS_REGISTER+rTEMPC]
      $RESET_TEMP
  case F32DAD
    sub tmp ra
    sub tmp xa
    code
      mov rTEMPA_32, fs:[$CTX_ELEMENT_BOUND + random_const_FS]
      sub rTEMPA_32, 3
      cmp $OFFSET, rTEMPA
      errorge STATUS_ROGUE_POINTER
      cmp $OFFSET, 0
      errorlt STATUS_ROGUE_POINTER
      cmp $ADDRESS_REGISTER, 0
      erroreq STATUS_UNBOUND_MEMORY
      
      lfence
      
      movd xTEMPA, [$ADDRESS_REGISTER+$OFFSET]
      cvttss2si $DEST__DATA_REG, xTEMPA
      
      $RESET_TEMP

  case F32DAI F32DAC
    sub tmp ra
    sub tmp rc
    sub tmp xa
    code
      $LD_OFFSET_IMMEDIATE
      
      mov rTEMPA_32, fs:[$CTX_ELEMENT_BOUND + random_const_FS]
      sub rTEMPA_32, 3
      cmp rTEMPC, rTEMPA
      errorge STATUS_ROGUE_POINTER
      cmp rTEMPC, 0
      errorlt STATUS_ROGUE_POINTER
      cmp $ADDRESS_REGISTER, 0
      erroreq STATUS_UNBOUND_MEMORY
      
      lfence
      
      movd xTEMPA, [$ADDRESS_REGISTER+rTEMPC]
      cvttss2si $DEST__DATA_REG, xTEMPA

      $RESET_TEMP

extend instruction store select-template
  case B128ADX
    sub tmp ra
    code
      mov rTEMPA_32, fs:[$CTX_ELEMENT_BOUND + random_const_FS]
      sub rTEMPA_32, 15
      cmp $OFFSET, rTEMPA
      errorge STATUS_ROGUE_POINTER
      cmp $OFFSET, 0
      errorlt STATUS_ROGUE_POINTER
      cmp $ADDRESS_REGISTER, 0
      erroreq STATUS_UNBOUND_MEMORY
      lfence
      movdqu [$ADDRESS_REGISTER+$OFFSET], $SRC
      $RESET_TEMP
  case B128AIX B128ACX
    sub tmp ra
    sub tmp rc
    code
      $LD_OFFSET_IMMEDIATE
      mov rTEMPA_32, fs:[$CTX_ELEMENT_BOUND + random_const_FS]
      sub rTEMPA_32, 15
      cmp rTEMPC, rTEMPA
      errorge STATUS_ROGUE_POINTER
      cmp rTEMPC, 0
      errorlt STATUS_ROGUE_POINTER
      cmp $ADDRESS_REGISTER, 0
      erroreq STATUS_UNBOUND_MEMORY
      lfence
      movdqu [$ADDRESS_REGISTER+rTEMPC], $SRC
      $RESET_TEMP
  
  case F64ADX
    sub tmp ra
    code
      mov rTEMPA_32, fs:[$CTX_ELEMENT_BOUND + random_const_FS]
      sub rTEMPA_32, 7
      cmp $OFFSET, rTEMPA
      errorge STATUS_ROGUE_POINTER
      cmp $OFFSET, 0
      errorlt STATUS_ROGUE_POINTER
      cmp $ADDRESS_REGISTER, 0
      erroreq STATUS_UNBOUND_MEMORY
      lfence
      movq [$ADDRESS_REGISTER+$OFFSET], $SRC
      $RESET_TEMP
  case F64AIX F64ACX
    sub tmp ra
    sub tmp rc
    code
      $LD_OFFSET_IMMEDIATE
      mov rTEMPA_32, fs:[$CTX_ELEMENT_BOUND + random_const_FS]
      sub rTEMPA_32, 7
      cmp rTEMPC, rTEMPA
      errorge STATUS_ROGUE_POINTER
      cmp rTEMPC, 0
      errorlt STATUS_ROGUE_POINTER
      cmp $ADDRESS_REGISTER, 0
      erroreq STATUS_UNBOUND_MEMORY
      lfence
      movq [$ADDRESS_REGISTER+rTEMPC], $SRC
      $RESET_TEMP
  
  case F32ADX
    sub tmp ra
    sub tmp xa
    code
      mov rTEMPA_32, fs:[$CTX_ELEMENT_BOUND + random_const_FS]
      sub rTEMPA_32, 3
      cmp $OFFSET, rTEMPA
      errorge STATUS_ROGUE_POINTER
      cmp $OFFSET, 0
      errorlt STATUS_ROGUE_POINTER
      cmp $ADDRESS_REGISTER, 0
      erroreq STATUS_UNBOUND_MEMORY
      lfence
      cvtsd2ss xTEMPA, $SRC
      movd [$ADDRESS_REGISTER+$OFFSET], xTEMPA
      $RESET_TEMP
  case F32AIX F32ACX
    sub tmp ra
    sub tmp rc
    sub tmp xa
    code
      $LD_OFFSET_IMMEDIATE
      mov rTEMPA_32, fs:[$CTX_ELEMENT_BOUND + random_const_FS]
      sub rTEMPA_32, 3
      cmp rTEMPC, rTEMPA
      errorge STATUS_ROGUE_POINTER
      cmp rTEMPC, 0
      errorlt STATUS_ROGUE_POINTER
      cmp $ADDRESS_REGISTER, 0
      erroreq STATUS_UNBOUND_MEMORY
      lfence
      cvtsd2ss xTEMPA, $SRC
      movd [$ADDRESS_REGISTER+rTEMPC], xTEMPA
      $RESET_TEMP

extend instruction assign select-template
  case DX
    code
      cvttsd2si $A, $B
  case DF DCf
    sub tmp ra
    sub tmp xa
    code
      $LD_B_IMMEDIATE_INDIRECT
      movq xTEMPA, rTEMPA
      cvttsd2si $A, xTEMPA
      $RESET_TEMP
  case XX
    code
      movq $A, $B
  case XD
    code
      cvtsi2sd $A, $B
  case XI XC
    sub tmp ra
    code
      $LD_B_IMMEDIATE_INDIRECT
      cvtsi2sd $A, rTEMPA
      $RESET_TEMP
  case XS
    sub tmp ra
    sub tmp rc
    code
      $LD_B_IMMEDIATE_INDIRECT
      $LD_B_HIGHBITS_IMMEDIATE_INDIRECT
      movq $A, rTEMPA
      pinsrq $A, rTEMPC, 3
      $RESET_TEMP
  case XF XCf
    sub tmp ra
    code
      $LD_B_IMMEDIATE_INDIRECT
      movq $A, rTEMPA
      $RESET_TEMP

extend subroutine simple_binary_instruction select-template
  case DX
    sub tmp ra
    code
      movq rTEMPA, $B
      p$INSTRUCTION $A, rTEMPA
      $RESET_TEMP
  case XD
    sub tmp xa
    code
      movq xTEMPA, $B
      p$INSTRUCTION $A, xTEMPA
      $RESET_TEMP
  case XI XC
    sub tmp ra
    sub tmp xa
    code
      $LD_B_IMMEDIATE
      movq xTEMPA, rTEMPA
      p$INSTRUCTION $A, xTEMPA
      $RESET_TEMP
  case XX
    code
      p$INSTRUCTION $A, $B

extend subroutine binary_instruction select-template
  case DX
    sub tmp xa
    code
      cvtsi2sd xTEMPA, $A
      %[$INSTRUCTION]sd xTEMPA, $B
      cvttsd2si $A, xTEMPA
      $RESET_TEMP
  case DF DCf
    sub tmp rc
    sub tmp xa
    sub tmp xb
    code
      $LD_B_IMMEDIATE_INDIRECT
      movq xTEMPB, rTEMPC
      cvtsi2sd xTEMPA, $A
      %[$INSTRUCTION]sd xTEMPA, xTEMPB
      cvttsd2si $A, xTEMPA
      $RESET_TEMP
  case XX
    code
      %[$INSTRUCTION]sd $A, $B
  case XD
    sub tmp xa
    code
      cvtsi2sd xTEMPA, $B
      %[$INSTRUCTION]sd $A, xTEMPA
      $RESET_TEMP
  case XI XC
    sub tmp rc
    sub tmp xa
    code
      $LD_B_IMMEDIATE_INDIRECT
      cvtsi2sd xTEMPA, rTEMPC
      %[$INSTRUCTION]sd $A, xTEMPA
      $RESET_TEMP
  case XCf XF
    sub tmp rc
    sub tmp xa
    code
      $LD_B_IMMEDIATE_INDIRECT
      movq xTEMPA, rTEMPC
      %[$INSTRUCTION]sd $A, xTEMPA
      $RESET_TEMP

extend instruction swap select-template
  case XD
    sub tmp xb
    code
      cvtsi2sd xTEMPB, $B
      cvttsd2si $B, $A
      movq $A, xTEMPB
      $RESET_TEMP
  case DX
    sub tmp xa
    code
      cvtsi2sd xTEMPA, $A
      cvttsd2si $A, $B
      movq $B, xTEMPA
      $RESET_TEMP
  case XX
    sub tmp xa
    code
      movq xTEMPA, $A
      movq $A, $B
      movq $B, xTEMPA
      $RESET_TEMP

extend instruction mul select-template
  case DX
    sub tmp xa
    code
      cvtsi2sd xTEMPA, $A
      mulsd xTEMPA, $B
      cvttsd2si $A, xTEMPA
      $RESET_TEMP
  case DF DCf
    sub tmp xa
    sub tmp xb
    sub tmp rc
    code
      $LD_B_IMMEDIATE_INDIRECT
      movq xTEMPB, rTEMPC
      cvtsi2sd xTEMPA, $A
      mulsd xTEMPA, xTEMPB
      cvttsd2si $A, xTEMPA
      $RESET_TEMP
  case XX
    code
      mulsd $A, $B
  case XD
    sub tmp xa
    code
      cvtsi2sd xTEMPA, $B
      mulsd $A, xTEMPA
      $RESET_TEMP
  case XI XC
    sub tmp xa
    sub tmp rc
    code
      $LD_B_IMMEDIATE_INDIRECT
      cvtsi2sd xTEMPA, rTEMPC
      mulsd $A, xTEMPA
      $RESET_TEMP
  case XCf XF
    sub tmp xa
    sub tmp rc
    code
      $LD_B_IMMEDIATE_INDIRECT
      movq xTEMPA, rTEMPC
      mulsd $A, xTEMPA
      $RESET_TEMP

extend instruction div select-template
  case DXN
    sub tmp xa
    code
      cvtsi2sd xTEMPA, $A
      divsd xTEMPA, $B
      cvttsd2si $A, xTEMPA
      $RESET_TEMP
  case DFN DCfN
    sub tmp xa
    sub tmp xb
    sub tmp rc
    code
      $LD_B_IMMEDIATE_INDIRECT
      movq xTEMPB, rTEMPC
      cvtsi2sd xTEMPA, $A
      divsd xTEMPA, xTEMPB
      cvttsd2si $A, xTEMPA
      $RESET_TEMP
  case XXN
    code
      divsd $A, $B
  case XDN
    sub tmp xa
    code
      cvtsi2sd xTEMPA, $B
      divsd $A, xTEMPA
      $RESET_TEMP
  case XIN XCN
    sub tmp xa
    sub tmp rc
    code
      $LD_B_IMMEDIATE_INDIRECT
      cvtsi2sd xTEMPA, rTEMPC
      divsd $A, xTEMPA
      $RESET_TEMP
  case XCfN XFN
    sub tmp xa
    sub tmp rc
    code
      $LD_B_IMMEDIATE_INDIRECT
      movq xTEMPA, rTEMPC
      divsd $A, xTEMPA
      $RESET_TEMP

# comparison with floats on xmmx registers
#  For packed floats, these all pass if any comparisons pass
#  These should work as expected for comparisons involving Individual floats
#   (for more fine-grained controls, you'll probably have to unpack and compare them individualls
#    It might be worthwhile to add a function which simply compares xmmx values and only extracts the
#    result)
# Comparisons of xmmx register with data register assumes that the xmmx register is a float and the data register
# is an integer
# Floating point comparisons wherein neither operand is stored on an xmmx register are unspported

extend subroutine test select-template
  case XTX
    sub tmp xa
    sub tmp ra
    code
      movsd xTEMPA, $A
      cmpsd xTEMPA, $B, $VPRED
      movq rTEMPA, xTEMPA
      cmp rTEMPA, 0
      jne .pass
  case DTX
    sub tmp xa
    sub tmp ra
    code
      cvtsi2sd xTEMPA, $A
      cmpsd xTEMPA, $B, $VPRED
      movq rTEMPA, xTEMPA
      cmp rTEMPA, 0
      jne .pass
  case FTX CfTX
    sub tmp xa
    sub tmp ra
    code
      $LD_IMMEDIATE_A_INDIRECT
      movq xTEMPA, rTEMPA
      cmpsd xTEMPA, $B, $VPRED
      movq rTEMPA, xTEMPA
      cmp rTEMPA, 0
      jne .pass
  case ITX CTX
    sub tmp xa
    sub tmp ra
    code
      $LD_IMMEDIATE_A_INDIRECT
      cvtsi2sd xTEMPA, rTEMPA
      cmpsd xTEMPA, $B, $VPRED
      movq rTEMPA, xTEMPA
      cmp rTEMPA, 0
      jne .pass
  case XTD
    sub tmp xa
    sub tmp ra
    code
      cvtsi2sd xTEMPA, $B
      cmpsd xTEMPA, $A, $VPREDCOMPLEMENT
      movq rTEMPA, xTEMPA
      cmp rTEMPA, 0
      jne .pass
  case XTF XTCf
    sub tmp xa
    sub tmp rc
    code
      $LD_IMMEDIATE_B
      movq xTEMPA, rTEMPC
      cmpsd xTEMPA, $A, $VPREDCOMPLEMENT
      movq rTEMPC, xTEMPA
      cmp rTEMPC, 0
      jne .pass
  case XTI XTC
    sub tmp xa
    sub tmp rc
    code
      $LD_IMMEDIATE_B_INDIRECT
      cvtsi2sd xTEMPA, rTEMPC
      cmpsd xTEMPA, $A, $VPREDCOMPLEMENT
      movq rTEMPC, xTEMPA
      cmp rTEMPC, 0
      jne .pass
  case DTF DTCf
    sub tmp xa
    sub tmp xb
    sub tmp rc
    code
      $LD_IMMEDIATE_B_INDIRECT
      cvtsi2sd xTEMPA, $A
      movq xTEMPB, rTEMPC
      movq rTEMPC, xTEMPA
      cmp rTEMPC, 0
      jne .pass
  case FTD CfTD
    sub tmp xa
    sub tmp xb
    sub tmp ra
    code
      $LD_IMMEDIATE_A_INDIRECT
      movq xTEMPA, rTEMPA
      movsd xTEMPB, $B
      movq rTEMPA, xTEMPA
      cmp rTEMPA, 0
      jne .pass

instruction transpose
  opt-operand
    select-operand
      case 32 i32 int32 f32 float32
        pick Fmt32
  operand
    type xmmx
    $M $VALUE
  sub tmp xa
  sub tmp xb
  select-template
    case Fmt32X X
      code
        movdqa xTEMPA, $M~1
        movdqa xTEMPB, $M~3
        insertps $M~1, $M~0,    0b01000000
        insertps $M~0, xTEMPA,  0b00010000
        insertps $M~1, $M~2,    0b01100000
        insertps $M~2, xTEMPA,  0b10010000
        insertps $M~3, $M~0,    0b11000000
        insertps $M~0, xTEMPB,  0b00110000
        insertps $M~3, $M~2,    0b11100000
        insertps $M~2, xTEMPB,  0b10110000
        
        movdqa xTEMPA, $M~0
        insertps $M~0, $M~2,    0b00100000
        insertps $M~2, xTEMPA,  0b10000000
        insertps $M~3, $M~1,    0b11010000
        insertps $M~1, xTEMPB,  0b01110000
        $RESET_TEMP

instruction dot
  opt-operand
    select-operand
      case f32 f32.4
        pick F32.4
  operand
    type xmmx
    $DEST $VALUE
  opt-operand
    select-operand
      case 0
       $INS_ARG 0b00000000
      case 1
        $INS_ARG 0b00010000
      case 2
        $INS_ARG 0b00100000
      case 3
        $INS_ARG 0b00110000
    pick I
  operand
    type xmmx
    $A $VALUE
  operand
    type xmmx
    $B $VALUE
  sub tmp xa
  select-template
    case F32.4XXX XXX
      code
        movdqa xTEMPA, $A
        dpps xTEMPA, $B, 0xf1
        cvtss2sd $DEST, xTEMPA
        $RESET_TEMP
    case F32.4XIXX XIXX
      code
        movdqa xTEMPA, $A
        dpps xTEMPA, $B, 0xf1
        insertps $DEST, xTEMPA, $INS_ARG
        $RESET_TEMP

instruction cross
  opt-operand
    select-operand
      case f32 f32.3
        pick F32
  operand
    type xmmx
    $DEST $VALUE
  operand
    type xmmx
    $A $VALUE
  operand
    type xmmx
    $B $VALUE
  sub tmp xa
  sub tmp xb
  select-template
    case XXX F32XXX
      code
        pshufd xTEMPA, $A, 0b11010010
        pshufd xTEMPB, $B, 0b11001001
        mulps  xTEMPB, xTEMPA
        pshufd xTEMPA, $B, 0b11010010
        pshufd $DEST,  $A, 0b11001001
        mulps $DEST, xTEMPA
        subps $DEST, xTEMPB
        $RESET_TEMP
