

# -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#   Copyright 2023, Jonathan Hart
#   This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation,
#   either version 3 of the License, or (at your option) any later version.
#   This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
#   PURPOSE. See the GNU General Public License for more details.
#   You should have received a copy of the GNU General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.
# -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------


# TACTYK Core Virtual ISA
# This is both the default configuration for TACTYK, as well as an example of how to use configuration-based virtual ISA specification

# low-level type specifications
# Types are determined with by testing.  Parameters for the first matching pattern are applied.

# General handling
#
# This file is loaded into the visa interpreter and stored in data structures matching the indentation
# Each (except for assembly code) is treated as a whitespace-delimited list of tokens.
# Except for assembly code (the "code" keyword), alls are a command, followed by a list of parameters.
#
# Visa specification is a simple domain-specific language for configuring tactyk.  It has subroutines, conditional
# exits, and an unusually sophisticated switch statement (substantially moreso than is typical of high level languages), but
# lacks complex conditions and loops.  Its only operations are pre-defined operator:
#   set variable          -- assign the content of a local variable to another local variable.  (for convenience and tersity, this is also the default operation)
#                            (note:  local variables are shared across all handlers which are invoked directly or indirectly by an instruction handler)
#   parse data            -- convert text to int (eventually this should expand to cover other types)
#   resolve symbol        -- search specified symbol tables for a named entry.
#   rewrite asm code      -- use string subtitution to insert local variables into asm code.
#   conditional fail      -- operator that exits the subroutine if the preceding operation (parse or resolve) failed and invokes the next alternative
#   selectors             -- tests invoked by the "select" operator to determine what block to invoke
#   specialized transform -- code manipulators that are not easily implemented through declarative / macro-like logic alone (for now, just immediate scrambling -- it requires random numbers
#                            and has a major variant if an 8-byte immediate is used)
#   ignore                -- another specialized handler for disregarding comments.

header tactyk_asmvm_header.asm

# enables all of aggressive binary executable randomization
settings
  $ABXR_SCRAMBLE_IMMEDIATES
  $ABXR_RANDOMIZE_EXECUTABLE

# addresses and data registers are recognized by reading code directly.
typespec address
  select-operand
    case @1 addr1
      value rADDR1
      $CTX_ADDR context.addr1
      $CTX_ARRAY_BOUND context.addr1_array_bound
      $CTX_ELEMENT_BOUND context.addr1_element_bound
      $CTX_MEMBLOCK_INDEX context.addr1_memblock_index
      $CTX_MEMBLOCK_TYPE context.addr1_type
    case @2 addr2
      value rADDR2
      $CTX_ADDR context.addr2
      $CTX_ARRAY_BOUND context.addr2_array_bound
      $CTX_ELEMENT_BOUND context.addr2_element_bound
      $CTX_MEMBLOCK_INDEX context.addr2_memblock_index
      $CTX_MEMBLOCK_TYPE context.addr2_type
    case @3 addr3
      value rADDR3
      $CTX_ADDR context.addr3
      $CTX_ARRAY_BOUND context.addr3_array_bound
      $CTX_ELEMENT_BOUND context.addr3_element_bound
      $CTX_MEMBLOCK_INDEX context.addr3_memblock_index
      $CTX_MEMBLOCK_TYPE context.addr3_type
    case @4 addr4
      value rADDR4
      $CTX_ADDR context.addr4
      $CTX_ARRAY_BOUND context.addr4_array_bound
      $CTX_ELEMENT_BOUND context.addr4_element_bound
      $CTX_MEMBLOCK_INDEX context.addr4_memblock_index
      $CTX_MEMBLOCK_TYPE context.addr4_type
  pick A

typespec data
  select-operand
    case a ra
      value rA
    case b rb
      value rB
    case c rc
      value rC
    case d rd
      value rD
    case e re
      value rE
    case f rf
      value rF
  pick D


# integers are recognized by casting to integer, then range-tested to obtain a byte width.
typespec integer
  int-operand
  pick I

typespec float
  float-operand
  pick F

# symbolic fields are handled by looking them up in symbol tables.
typespec branch
  label
  pick L

typespec const
  symbol const
  pick C

typespec fconst
  symbol fconst
  pick Cf

typespec memblock
  symbol mem
  pick M

typespec capi
  symbol capi
  pick Cfunc

typespec tapi
  symbol tapi
  pick Tfunc

typespec none
  nullarg
  pick N

typespec string
  string-operand
  pick S

typespec context-property
  select-operand
    case addr1.array_bound
      value context.addr1_array_bound
      $KW dword
    case addr1.element_bound
      value context.addr1_element_bound
      $KW dword
    case addr1.left
      value context.addr1_left
      $KW dword
    case addr1.right
      value context.addr1_right
      $KW dword
    case addr2.array_bound
      value context.addr2_array_bound
      $KW dword
    case addr2.element_bound
      value context.addr2_element_bound
      $KW dword
    case addr2.left
      value context.addr2_left
      $KW dword
    case addr2.right
      value context.addr2_right
      $KW dword
    case addr3.array_bound
      value context.addr3_array_bound
      $KW dword
    case addr3.element_bound
      value context.addr3_element_bound
      $KW dword
    case addr3.left
      value context.addr3_left
      $KW dword
    case addr3.right
      value context.addr3_right
      $KW dword
    case addr4.array_bound
      value context.addr4_array_bound
      $KW dword
    case addr4.element_bound
      value context.addr4_element_bound
      $KW dword
    case addr4.left
      value context.addr4_left
      $KW dword
    case addr4.right
      value context.addr4_right
      $KW dword
  pick Ctx

# set up a prototype paramter block 
typespec comparator
  select-operand
    case < lt
      value jl
      $VPRED 1
      $VPREDCOMPLEMENT 6
    case <= le
      value jle
      $VPRED 2
      $VPREDCOMPLEMENT 5
    case == eq
      value je
      $VPRED 0
      $VPREDCOMPLEMENT 0
    case >= ge
      value jge
      $VPRED 5
      $VPREDCOMPLEMENT 2
    case > gt
      value jg
      $VPRED 6
      $VPREDCOMPLEMENT 1
    case ~= != neq
      value jne
      $VPRED 4
      $VPREDCOMPLEMENT 4
  pick T

# immediate scrambling config
# This sets up the scrambling system whereby the script-provided immediate values are scrabled in executable memory and
# unscrambled when accessed.
# 
subroutine scramble
  select-kw2
    case byte word
      code $SC
        mov $SC_DEST, $SC_RAND
        xor $SC_DEST, $SC_DIFF
    case dword
      code $SC
        mov $SC_DEST, $SC_RAND
        xor %[$SC_DEST]_32, $SC_DIFF
    case qword
      code $SC
        mov $SC_DEST, $SC_RAND
        mov rTEMPD, $SC_DIFF
        xor $SC_DEST, rTEMPD
        xor rTEMPD, rTEMPD
        # mov $SC_DEST, $SC_RAND_HIGH
        # xor %[$SC_DEST]_32, $SC_DIFF_HIGH
        # shl $SC_DEST, 32
        # xor %[$SC_DEST]_32, $SC_RAND_LOW
        # xor %[$SC_DEST]_32, $SC_DIFF_LOW

instruction exit
  $KW dword
  scramble rTEMPA $LD_IPTR_IMMEDIATE $COMMAND_INDEX
  code
    $LD_IPTR_IMMEDIATE
    mov fs:[context.instruction_index], rTEMPA
    xor rTEMPA, rTEMPA
    mov fs:[context.status], dword STATUS_HALT
    store_context
    rdfsbase rax
    load_runtimecontext rax
    mov r14, [rax + context.runtime_registers + 40]
    mov r15, [rax + context.runtime_registers + 48]
    mov rax, STATUS_HALT
    ret

# Bind a memory block to an address register and update corresponding context entries
# NOTICE:  This instruction will need to be reviewed for spectre/meltdown mitigations 
#          (transfer of data from the memory block list to the address register & 
#          context fields is possibly sensitive).  
#          ((By design, all instructions may be preceded by any combination of gotos, 
#          conditional branches and by memory-indirect jumps via a read-only jump table 
#          containing all tactyk-pl provided instructions.  Register allocation is
#          global and programs are not permitted to make uncontrolled modifications to
#          anything but data reguisters and the data content of listed memory blocks.))

instruction bind
  operand
    type address
    $ADDRESS_REGISTER $VALUE
  operand
    type data memblock integer
    $SRC $VALUE
    $KWSRC $KW
    scramble rTEMPA $LD_SRC_IMMEDIATE
  select-template

    case AD
      code
        mov rTEMPA, $SRC
        
        cmp $SRC, 0
        errorlt STATUS_ROGUE_POINTER
        cmp rTEMPA, fs:[context.memblocks_count]
        errorge STATUS_ROGUE_POINTER
        
        lfence
        
        imul rTEMPA, 24
        add rTEMPA, fs:[context.memblocks]
        mov $ADDRESS_REGISTER, [rTEMPA]
        mov fs:[$CTX_ADDR], $ADDRESS_REGISTER

        mov rTEMPC, [rTEMPA+8]
        mov rTEMPD, [rTEMPA+16]
        mov fs:[$CTX_ADDR+8], rTEMPC
        mov fs:[$CTX_ADDR+16], rTEMPD
        
        xor rTEMPA, rTEMPA
        xor rTEMPC, rTEMPC
        xor rTEMPD, rTEMPD
        jmp $NEXT_INSTRUCTION
    
    case AM AI
      code
        $LD_SRC_IMMEDIATE
        
        cmp rTEMPA, 0
        errorlt STATUS_ROGUE_POINTER
        cmp rTEMPA, fs:[context.memblocks_count]
        errorge STATUS_ROGUE_POINTER
        
        lfence
        
        imul rTEMPA, 24
        add rTEMPA, fs:[context.memblocks]
        mov $ADDRESS_REGISTER, [rTEMPA]
        mov fs:[$CTX_ADDR], $ADDRESS_REGISTER
        
        mov rTEMPC, [rTEMPA+8]
        mov rTEMPD, [rTEMPA+16]
        mov fs:[$CTX_ADDR+8], rTEMPC
        mov fs:[$CTX_ADDR+16], rTEMPD
        
        xor rTEMPA, rTEMPA
        xor rTEMPC, rTEMPC
        xor rTEMPD, rTEMPD
        jmp $NEXT_INSTRUCTION
    
    # Memblock index bounds check is handled by the compiler, so this version probably would be valid.
    # However there also does not seem much point in having this variant, as memory block binding is not expected to be a frequent
    # operation outside of degenerate cases.  (If many objects need to be accessed, a large memory block holding an object pool should
    # be used)
    #
    # case AM 
    #  code
    #    $LD_SRC_IMMEDIATE
    #
    #    imul rTEMPA, 24
    #    add rTEMPA, fs:[context.memblocks]
    #    mov $ADDRESS_REGISTER, [rTEMPA]
    #    mov fs:[$CTX_ADDR], $ADDRESS_REGISTER
    #    
    #    mov rTEMPC, [rTEMPA+8]
    #    mov rTEMPD, [rTEMPA+16]
    #    mov fs:[$CTX_ADDR+8], rTEMPC
    #    mov fs:[$CTX_ADDR+16], rTEMPD
    #    
    #    xor rTEMPA, rTEMPA
    #    xor rTEMPC, rTEMPC
    #    xor rTEMPD, rTEMPD
    #    jmp $NEXT_INSTRUCTION

# Read a word from a memory block and write it to a register
# NOTICE:  This instruction will need to be reviewed for spectre/meltdown mitigations 
#          (transfer of data from the memory block list to the address register & 
#          context fields is possibly sensitive).  
#          ((By design, all instructions may be preceded by any combination of gotos, 
#          conditional branches and by memory-indirect jumps via a read-only jump table 
#          containing all tactyk-pl provided instructions.  Register allocation is
#          global and programs are not permitted to make uncontrolled modifications to
#          anything but data reguisters and the data content of listed memory blocks.))
instruction load
  operand
    select-operand
      case byte i8
        pick B
      case word i16
        pick W
      case dword i32
        pick D
      case qword i64
        pick Q
      case float
        pick X
  operand
    type data xmmx
    $DEST__DATA_REG $VALUE
  operand
    type address
    $ADDRESS_REGISTER $VALUE
  operand
    type data const integer
    $OFFSET $VALUE
    scramble rTEMPC $LD_OFFSET_IMMEDIATE
  select-template
    case QDAD
      code
        mov rTEMPA_32, fs:[$CTX_ELEMENT_BOUND]
        cmp $OFFSET, rTEMPA
        errorge STATUS_ROGUE_POINTER
        cmp $OFFSET, 0
        errorlt STATUS_ROGUE_POINTER
        
        lfence
        
        mov $DEST__DATA_REG, [$ADDRESS_REGISTER+$OFFSET]
        xor rTEMPA, rTEMPA
        jmp $NEXT_INSTRUCTION
    case QDAI QDAC
      code
        $LD_OFFSET_IMMEDIATE
        
        mov rTEMPA_32, fs:[$CTX_ELEMENT_BOUND]
        cmp rTEMPC, rTEMPA
        errorge STATUS_ROGUE_POINTER
        cmp rTEMPC, 0
        errorlt STATUS_ROGUE_POINTER
        
        lfence
        
        mov $DEST__DATA_REG, [$ADDRESS_REGISTER+rTEMPC]
        xor rTEMPA, rTEMPA
        xor rTEMPC, rTEMPC
        jmp $NEXT_INSTRUCTION
    case DDAD
      code
        mov rTEMPA_32, fs:[$CTX_ELEMENT_BOUND]
        cmp $OFFSET, rTEMPA
        errorge STATUS_ROGUE_POINTER
        cmp $OFFSET, 0
        errorlt STATUS_ROGUE_POINTER
        
        mov %[$DEST__DATA_REG]_32, dword [$ADDRESS_REGISTER+$OFFSET]
        xor rTEMPA, rTEMPA
        jmp $NEXT_INSTRUCTION
    case DDAI DDAC
      code
        $LD_OFFSET_IMMEDIATE
        
        mov rTEMPA_32, fs:[$CTX_ELEMENT_BOUND]
        cmp rTEMPC, rTEMPA
        errorge STATUS_ROGUE_POINTER
        cmp rTEMPC, 0
        errorlt STATUS_ROGUE_POINTER
        
        lfence
        
        mov %[$DEST__DATA_REG]_32, dword [$ADDRESS_REGISTER+rTEMPC]
        xor rTEMPA, rTEMPA
        xor rTEMPC, rTEMPC
        jmp $NEXT_INSTRUCTION
    case WDAD
      code
        mov rTEMPA_32, fs:[$CTX_ELEMENT_BOUND]
        cmp $OFFSET, rTEMPA
        errorge STATUS_ROGUE_POINTER
        cmp $OFFSET, 0
        errorlt STATUS_ROGUE_POINTER
        
        lfence
        
        movzx $DEST__DATA_REG, word [$ADDRESS_REGISTER+$OFFSET]
        xor rTEMPA, rTEMPA
        jmp $NEXT_INSTRUCTION
    case WDAI WDAC
      code
        $LD_OFFSET_IMMEDIATE

        mov rTEMPA_32, fs:[$CTX_ELEMENT_BOUND]
        cmp rTEMPC, rTEMPA
        errorge STATUS_ROGUE_POINTER
        cmp rTEMPC, 0
        errorlt STATUS_ROGUE_POINTER
        
        lfence
        
        movzx $DEST__DATA_REG, word [$ADDRESS_REGISTER+rTEMPC]
        xor rTEMPA, rTEMPA
        xor rTEMPC, rTEMPC
        jmp $NEXT_INSTRUCTION
    case BDAD
      code
        mov rTEMPA_32, fs:[$CTX_ELEMENT_BOUND]
        cmp $OFFSET, rTEMPA
        errorge STATUS_ROGUE_POINTER
        cmp $OFFSET, 0
        errorlt STATUS_ROGUE_POINTER
        
        lfence
        
        movzx $DEST__DATA_REG, byte [$ADDRESS_REGISTER+$OFFSET]
        xor rTEMPA, rTEMPA
        jmp $NEXT_INSTRUCTION
    case BDAI BDAC
      code
        $LD_OFFSET_IMMEDIATE
        
        mov rTEMPA_32, fs:[$CTX_ELEMENT_BOUND]
        cmp rTEMPC, rTEMPA
        errorge STATUS_ROGUE_POINTER
        cmp rTEMPC, 0
        errorlt STATUS_ROGUE_POINTER
        
        lfence
        
        movzx $DEST__DATA_REG, byte [$ADDRESS_REGISTER+rTEMPC]
        xor rTEMPA, rTEMPA
        xor rTEMPC, rTEMPC
        jmp $NEXT_INSTRUCTION

    case XXAD
      code
        mov rTEMPA_32, fs:[$CTX_ELEMENT_BOUND]
        cmp $OFFSET, rTEMPA
        errorge STATUS_ROGUE_POINTER
        cmp $OFFSET, 0
        errorlt STATUS_ROGUE_POINTER
        
        lfence
        
        movq $DEST__DATA_REG, [$ADDRESS_REGISTER+$OFFSET]
        xor rTEMPA, rTEMPA
        jmp $NEXT_INSTRUCTION
    case XXAI QXAC
      code
        $LD_OFFSET_IMMEDIATE
        
        mov rTEMPA_32, fs:[$CTX_ELEMENT_BOUND]
        cmp rTEMPC, rTEMPA
        errorge STATUS_ROGUE_POINTER
        cmp rTEMPC, 0
        errorlt STATUS_ROGUE_POINTER
        
        lfence
        
        movq $DEST__DATA_REG, [$ADDRESS_REGISTER+rTEMPC]
        xor rTEMPA, rTEMPA
        xor rTEMPC, rTEMPC
        jmp $NEXT_INSTRUCTION

instruction store
  operand
    select-operand
      case byte i8
        pick B
      case word i16
        pick W
      case dword i32
        pick D
      case qword i64
        pick Q
      case float
        pick X
  operand
    type address
    $ADDRESS_REGISTER $VALUE
  operand
    type data const integer
    $OFFSET $VALUE
    scramble rTEMPC $LD_OFFSET_IMMEDIATE
  operand
    type data xmmx
    $SRC $VALUE
    scramble rTEMPA $LD_SRC_IMMEDIATE
  select-template
    case QADD
      code
        mov rTEMPA_32, fs:[$CTX_ELEMENT_BOUND]
        cmp $OFFSET, rTEMPA
        errorge STATUS_ROGUE_POINTER
        cmp $OFFSET, 0
        errorlt STATUS_ROGUE_POINTER
        lfence
        mov [$ADDRESS_REGISTER+$OFFSET], $SRC
        xor rTEMPA, rTEMPA
        jmp $NEXT_INSTRUCTION
    case QAID QACD
      code
        $LD_OFFSET_IMMEDIATE
        mov rTEMPA_32, fs:[$CTX_ELEMENT_BOUND]
        cmp rTEMPC, rTEMPA
        errorge STATUS_ROGUE_POINTER
        cmp rTEMPC, 0
        errorlt STATUS_ROGUE_POINTER
        lfence
        mov [$ADDRESS_REGISTER+$OFFSET], $SRC
        xor rTEMPA, rTEMPA
        xor rTEMPC, rTEMPC
        jmp $NEXT_INSTRUCTION
    case QADI QADC
      code
        $LD_SRC_IMMEDIATE
        mov rTEMPD_32, fs:[$CTX_ELEMENT_BOUND]
        cmp $OFFSET, rTEMPD
        errorge STATUS_ROGUE_POINTER
        cmp $OFFSET, 0
        errorlt STATUS_ROGUE_POINTER
        lfence
        mov [$ADDRESS_REGISTER+$OFFSET], rTEMPA
        xor rTEMPA, rTEMPA
        xor rTEMPD, rTEMPD
        jmp $NEXT_INSTRUCTION
    case QAII QAIC QACI QACC
      code
        $LD_OFFSET_IMMEDIATE
        $LD_SRC_IMMEDIATE
        mov rTEMPD_32, fs:[$CTX_ELEMENT_BOUND]
        cmp rTEMPC, rTEMPD
        errorge STATUS_ROGUE_POINTER
        cmp rTEMPC, 0
        errorlt STATUS_ROGUE_POINTER
        lfence
        mov [$ADDRESS_REGISTER+$OFFSET], rTEMPA
        xor rTEMPA, rTEMPA
        xor rTEMPC, rTEMPC
        xor rTEMPD, rTEMPD
        jmp $NEXT_INSTRUCTION
    
    case DADD
      code
        mov rTEMPA_32, fs:[$CTX_ELEMENT_BOUND]
        cmp $OFFSET, rTEMPA
        errorge STATUS_ROGUE_POINTER
        cmp $OFFSET, 0
        errorlt STATUS_ROGUE_POINTER
        lfence
        mov dword [$ADDRESS_REGISTER+$OFFSET], %[$SRC]_32
        xor rTEMPA, rTEMPA
        jmp $NEXT_INSTRUCTION
    case DAID DACD
      code
        $LD_OFFSET_IMMEDIATE
        mov rTEMPA_32, fs:[$CTX_ELEMENT_BOUND]
        cmp rTEMPC, rTEMPA
        errorge STATUS_ROGUE_POINTER
        cmp rTEMPC, 0
        errorlt STATUS_ROGUE_POINTER
        lfence
        mov dword [$ADDRESS_REGISTER+$OFFSET], %[$SRC]_32
        xor rTEMPA, rTEMPA
        xor rTEMPC, rTEMPC
        jmp $NEXT_INSTRUCTION
    case DADI DADC
      code
        $LD_SRC_IMMEDIATE
        mov rTEMPD_32, fs:[$CTX_ELEMENT_BOUND]
        cmp $OFFSET, rTEMPD
        errorge STATUS_ROGUE_POINTER
        cmp $OFFSET, 0
        errorlt STATUS_ROGUE_POINTER
        lfence
        mov [$ADDRESS_REGISTER+$OFFSET], rTEMPA
        xor rTEMPA, rTEMPA
        xor rTEMPD, rTEMPD
        jmp $NEXT_INSTRUCTION
    case DAII DAIC DACI DACC
      code
        $LD_OFFSET_IMMEDIATE
        $LD_SRC_IMMEDIATE
        mov rTEMPD_32, fs:[$CTX_ELEMENT_BOUND]
        cmp rTEMPC, rTEMPD
        errorge STATUS_ROGUE_POINTER
        cmp rTEMPC, 0
        errorlt STATUS_ROGUE_POINTER
        lfence
        mov [$ADDRESS_REGISTER+$OFFSET], rTEMPA
        xor rTEMPA, rTEMPA
        xor rTEMPC, rTEMPC
        xor rTEMPD, rTEMPD
        jmp $NEXT_INSTRUCTION
    
    case WADD
      code
        mov rTEMPA_32, fs:[$CTX_ELEMENT_BOUND]
        cmp $OFFSET, rTEMPA
        errorge STATUS_ROGUE_POINTER
        cmp $OFFSET, 0
        errorlt STATUS_ROGUE_POINTER
        lfence
        mov word [$ADDRESS_REGISTER+$OFFSET], %[$SRC]_16
        xor rTEMPA, rTEMPA
        jmp $NEXT_INSTRUCTION
    case WAID WACD
      code
        $LD_OFFSET_IMMEDIATE
        mov rTEMPA_32, fs:[$CTX_ELEMENT_BOUND]
        cmp rTEMPC, rTEMPA
        errorge STATUS_ROGUE_POINTER
        cmp rTEMPC, 0
        errorlt STATUS_ROGUE_POINTER
        lfence
        mov word [$ADDRESS_REGISTER+$OFFSET], %[$SRC]_16
        xor rTEMPA, rTEMPA
        xor rTEMPC, rTEMPC
        jmp $NEXT_INSTRUCTION
    case WADI WADC
      code
        $LD_SRC_IMMEDIATE
        mov rTEMPD_32, fs:[$CTX_ELEMENT_BOUND]
        cmp $OFFSET, rTEMPD
        errorge STATUS_ROGUE_POINTER
        cmp $OFFSET, 0
        errorlt STATUS_ROGUE_POINTER
        lfence
        mov [$ADDRESS_REGISTER+$OFFSET], rTEMPA
        xor rTEMPA, rTEMPA
        xor rTEMPD, rTEMPD
        jmp $NEXT_INSTRUCTION
    case WAII WAIC WACI WACC
      code
        $LD_OFFSET_IMMEDIATE
        $LD_SRC_IMMEDIATE
        mov rTEMPD_32, fs:[$CTX_ELEMENT_BOUND]
        cmp rTEMPC, rTEMPD
        errorge STATUS_ROGUE_POINTER
        cmp rTEMPC, 0
        errorlt STATUS_ROGUE_POINTER
        lfence
        mov [$ADDRESS_REGISTER+$OFFSET], rTEMPA
        xor rTEMPA, rTEMPA
        xor rTEMPC, rTEMPC
        xor rTEMPD, rTEMPD
        jmp $NEXT_INSTRUCTION
        
    case BADD
      code
        mov rTEMPA_32, fs:[$CTX_ELEMENT_BOUND]
        cmp $OFFSET, rTEMPA
        errorge STATUS_ROGUE_POINTER
        cmp $OFFSET, 0
        errorlt STATUS_ROGUE_POINTER
        lfence
        mov byte [$ADDRESS_REGISTER+$OFFSET], %[$SRC]_8
        xor rTEMPA, rTEMPA
        jmp $NEXT_INSTRUCTION
    case BAID BACD
      code
        $LD_OFFSET_IMMEDIATE
        mov rTEMPA_32, fs:[$CTX_ELEMENT_BOUND]
        cmp rTEMPC, rTEMPA
        errorge STATUS_ROGUE_POINTER
        cmp rTEMPC, 0
        errorlt STATUS_ROGUE_POINTER
        lfence
        mov byte [$ADDRESS_REGISTER+$OFFSET], %[$SRC]_8
        xor rTEMPA, rTEMPA
        xor rTEMPC, rTEMPC
        jmp $NEXT_INSTRUCTION
    case BADI BADC
      code
        $LD_SRC_IMMEDIATE
        mov rTEMPD_32, fs:[$CTX_ELEMENT_BOUND]
        cmp $OFFSET, rTEMPD
        errorge STATUS_ROGUE_POINTER
        cmp $OFFSET, 0
        errorlt STATUS_ROGUE_POINTER
        lfence
        mov [$ADDRESS_REGISTER+$OFFSET], rTEMPA
        xor rTEMPA, rTEMPA
        xor rTEMPD, rTEMPD
        jmp $NEXT_INSTRUCTION
    case BAII BAIC BACI BACC
      code
        $LD_OFFSET_IMMEDIATE
        $LD_SRC_IMMEDIATE
        mov rTEMPD_32, fs:[$CTX_ELEMENT_BOUND]
        cmp rTEMPC, rTEMPD
        errorge STATUS_ROGUE_POINTER
        cmp rTEMPC, 0
        errorlt STATUS_ROGUE_POINTER
        lfence
        mov [$ADDRESS_REGISTER+$OFFSET], rTEMPA
        xor rTEMPA, rTEMPA
        xor rTEMPC, rTEMPC
        xor rTEMPD, rTEMPD
        jmp $NEXT_INSTRUCTION

    case XADX
      code
        mov rTEMPA_32, fs:[$CTX_ELEMENT_BOUND]
        cmp $OFFSET, rTEMPA
        errorge STATUS_ROGUE_POINTER
        cmp $OFFSET, 0
        errorlt STATUS_ROGUE_POINTER
        lfence
        movq [$ADDRESS_REGISTER+$OFFSET], $SRC
        xor rTEMPA, rTEMPA
        jmp $NEXT_INSTRUCTION
    case XAIX XACX
      code
        $LD_OFFSET_IMMEDIATE
        mov rTEMPA_32, fs:[$CTX_ELEMENT_BOUND]
        cmp rTEMPC, rTEMPA
        errorge STATUS_ROGUE_POINTER
        cmp rTEMPC, 0
        errorlt STATUS_ROGUE_POINTER
        lfence
        movq [$ADDRESS_REGISTER+$OFFSET], $SRC
        xor rTEMPA, rTEMPA
        xor rTEMPC, rTEMPC
        jmp $NEXT_INSTRUCTION

instruction pop
  operand
    type data
    $DEST__DATA_REG $VALUE
  operand
    type address
    $ADDRESS_REGISTER $VALUE
  code
    mov $DEST__DATA_REG, [$ADDRESS_REGISTER]
    mov rTEMPA, $ADDRESS_REGISTER
    sub rTEMPA, 8
    cmp rTEMPA, fs:[$CTX_ADDR]
    errorlt STATUS_MEMORY_UNDERFLOW
    lfence
    sub $ADDRESS_REGISTER, 8
    xor rTEMPA, rTEMPA
    jmp $NEXT_INSTRUCTION

instruction push
  operand
    type address
    $ADDRESS_REGISTER $VALUE
  operand
    type data integer const
    $SRC__DATA_REGISTER $VALUE
    scramble rTEMPC $LD_SRC_IMMEDIATE
  select-template
    case AD
      code
        mov rTEMPA, $ADDRESS_REGISTER
        sub rTEMPA, fs:[$CTX_ADDR]
        add rTEMPA, 8
        cmp rTEMPA, fs:[$CTX_ARRAY_BOUND]
        errorge STATUS_MEMORY_OVERFLOW
        add $ADDRESS_REGISTER, 8
        mov [$ADDRESS_REGISTER], $SRC__DATA_REGISTER
        xor rTEMPA, rTEMPA
        jmp $NEXT_INSTRUCTION
    case AI AC
      code
        $LD_SRC_IMMEDIATE
        mov rTEMPA, $ADDRESS_REGISTER
        sub rTEMPA, fs:[$CTX_ADDR]
        add rTEMPA, 8
        cmp rTEMPA, fs:[$CTX_ARRAY_BOUND]
        errorge STATUS_MEMORY_OVERFLOW
        add $$ADDRESS_REGISTER, 8
        mov [$ADDRESS_REGISTER], rTEMPC
        xor rTEMPA, rTEMPA
        jmp $NEXT_INSTRUCTION
        

instruction swap
  operand 
    type data xmmx
    $A $VALUE
  operand
    type data xmmx
    $B $VALUE
  select-template
    case DD
      code
        xchg $A, $B
        jmp $NEXT_INSTRUCTION
    case XD
      code
        cvtsi2sd xTEMPB, $B
        cvttsd2si $B, $A
        movq $A, xTEMPB
        pxor xTEMPB, xTEMPB
        jmp $NEXT_INSTRUCTION
    case DX
      code
        cvtsi2sd xTEMPA, $A
        cvttsd2si $A, $B
        movq $B, xTEMPA
        pxor xTEMPA, xTEMPA
        jmp $NEXT_INSTRUCTION
    case XX
      code
        movq xTEMPA, $A
        movq $B, $A
        movq $A, xTEMPA
        pxor xTEMPA, xTEMPA
        jmp $NEXT_INSTRUCTION

subroutine simple_unary_instruction
  operand 
    type data
    $A $VALUE
  code
    $INSTRUCTION $A
    jmp $NEXT_INSTRUCTION

subroutine simple_binary_instruction
  operand 
    type data
    $A $VALUE
  operand
    type data const integer
    $B $VALUE
    scramble rTEMPA $LD_B_IMMEDIATE
  select-template
    case DD
      code 
        $INSTRUCTION $A, $B
        jmp $NEXT_INSTRUCTION
    case DI DC
      code 
        $LD_B_IMMEDIATE
        $INSTRUCTION $A, rTEMPA
        xor rTEMPA, rTEMPA
        jmp $NEXT_INSTRUCTION

subroutine binary_instruction
  operand
    type data xmmx
    $A $VALUE
  operand
    type data xmmx const fconst integer float
    $B $VALUE
    scramble rTEMPA $LD_B_IMMEDIATE
  select-template
    case DD
      code
        $INSTRUCTION $A, $B
        jmp $NEXT_INSTRUCTION
    case DI DC
      code
        $LD_B_IMMEDIATE
        $INSTRUCTION $A, rTEMPA
        xor rTEMPA, rTEMPA
        jmp $NEXT_INSTRUCTION
    case DX
      code
        cvtsi2sd xTEMPA, $A
        %[$INSTRUCTION]sd xTEMPA, $B
        cvttsd2si $A, xTEMPA
        pxor xTEMPA, xTEMPA
        jmp $NEXT_INSTRUCTION
    case DF DCf
      code
        $LD_B_IMMEDIATE
        cvtsi2sd xTEMPB, rTEMPA
        cvtsi2sd xTEMPA, $A
        %[$INSTRUCTION]sd xTEMPA, $B
        cvttsd2si $A, xTEMPA
        xor rTEMPA, rTEMPA
        pxor xTEMPA, xTEMPA
        jmp $NEXT_INSTRUCTION
    case XX
      code
        %[$INSTRUCTION]sd $A, $B
        jmp $NEXT_INSTRUCTION
    case XD
      code
        cvtsi2sd xTEMPA, $B
        %[$INSTRUCTION]sd $A, xTEMPA
        pxor xTEMPA, xTEMPA
        jmp $NEXT_INSTRUCTION
    case XI XC
      code
        $LD_B_IMMEDIATE
        cvtsi2sd xTEMPA, rTEMPA
        %[$INSTRUCTION]sd $A, xTEMPA
        xor rTEMPA, rTEMPA
        pxor xTEMPA, xTEMPA
        jmp $NEXT_INSTRUCTION
    case XCf XF
      code
        $LD_B_IMMEDIATE
        movq xTEMPA, rTEMPA
        %[$INSTRUCTION]sd $A, xTEMPA
        xor rTEMPA, rTEMPA
        pxor xTEMPA, xTEMPA
        jmp $NEXT_INSTRUCTION

instruction add
  $INSTRUCTION add
  sub binary_instruction

instruction sub
  $INSTRUCTION sub
  sub binary_instruction

instruction and
  $INSTRUCTION and
  sub simple_binary_instruction

instruction or
  $INSTRUCTION or
  sub simple_binary_instruction

instruction xor
  $INSTRUCTION xor
  sub simple_binary_instruction

#
typespec address-offset
  select-operand
    case addr1.offset
      $ADDRESS_REGISTER rADDR1
      $CTX_ADDRESS context.addr1
      $CTX_ADDRESS_BOUND context.addr1_array_bound
    case addr2.offset
      $ADDRESS_REGISTER rADDR2
      $CTX_ADDRESS context.addr2
      $CTX_ADDRESS_BOUND context.addr2_array_bound
    case addr3.offset
      $ADDRESS_REGISTER rADDR3
      $CTX_ADDRESS context.addr3
      $CTX_ADDRESS_BOUND context.addr3_array_bound
    case addr4.offset
      $ADDRESS_REGISTER rADDR4
      $CTX_ADDRESS context.addr4
      $CTX_ADDRESS_BOUND context.addr4_array_bound
  pick O

instruction assign
  operand 
    type data xmmx address-offset
    $A $VALUE
  operand
    type data xmmx const fconst address-offset context-property integer float string
    $B $VALUE
    scramble rTEMPA $LD_B_IMMEDIATE
    scramble rTEMPC $LD_B_HIGHBITS_IMMEDIATE $VALUE_UPPER
  select-template
    case OD
      cmp $B, 0
      errorlt
      cmp $B, fs:[$CTX_ADDRESS_BOUND]
      errorge STATUS_ROGUE_POINTER
      cmp $B, 0
      errorlt STATUS_ROGUE_POINTER
      lfence
      mov $ADDRESS_REGISTER, $B
      jmp $NEXT_INSTRUCTION
    case DO
      code
        mov $A, $ADDRESS_REGISTER
        sub $A, fs:[$CTX_ADDRESS]
        jmp $NEXT_INSTRUCTION
    case DD
      code 
        mov $A, $B
        jmp $NEXT_INSTRUCTION
    case DI DC DS
      code 
        $LD_B_IMMEDIATE
        mov $A, rTEMPA
        xor rTEMPA, rTEMPA
        jmp $NEXT_INSTRUCTION
    case DCtx
      select-kw
        case dword
          code
            mov %[$A]_32, fs:[$B]
            jmp $NEXT_INSTRUCTION
    case DX
      code
        cvttsd2si $A, $B
        jmp $NEXT_INSTRUCTION
    case DF DCf
      code
        $LD_B_IMMEDIATE
        movq xTEMPA, rTEMPA
        cvttsd2si, $A, xTEMPA
        jmp $NEXT_INSTRUCTION
    case XX
      code
        movq $A, $B
        jmp $NEXT_INSTRUCTION
    case XD
      code
        cvtsi2sd $A, $B
        jmp $NEXT_INSTRUCTION
    case XI XC
      code
        $LD_B_IMMEDIATE
        cvtsi2sd $A, rTEMPA
        xor rTEMPA, rTEMPA
        jmp $NEXT_INSTRUCTION
    case XS
      code
        $LD_B_IMMEDIATE
        $LD_B_HIGHBITS_IMMEDIATE
        movq $A, rTEMPA
        pinsrq $A, rTEMPC, 3
        xor rTEMPA, rTEMPA
        xor rTEMPC, rTEMPC
        jmp $NEXT_INSTRUCTION
    case XF XCf
      code
        $LD_B_IMMEDIATE
        movq $A, rTEMPA
        xor rTEMPA, rTEMPA
        jmp $NEXT_INSTRUCTION
      

instruction mul
  operand
    type data xmmx
    $A $VALUE
  operand
    type data xmmx const fconst integer float
    $B $VALUE
    scramble rTEMPC $LD_B_IMMEDIATE
  select-template
    case DD
      code
        mov rTEMPA, $A
        imul $B
        mov $A, rTEMPA
        xor rTEMPA, rTEMPA
        jmp $NEXT_INSTRUCTION
    case DI DC
      code
        $LD_B_IMMEDIATE
        mov rTEMPA, $A
        imul rTEMPC
        mov $A, rTEMPA
        xor rTEMPA, rTEMPA
        xor rTEMPC, rTEMPC
        jmp $NEXT_INSTRUCTION
    case DX
      code
        cvtsi2sd xTEMPA, $A
        mulsd xTEMPA, $B
        cvttsd2si $A, xTEMPA
        pxor xTEMPA, xTEMPA
        jmp $NEXT_INSTRUCTION
    case DF DCf
      code
        $LD_B_IMMEDIATE
        movq xTEMPB, rTEMPC
        cvtsi2sd xTEMPA, $A
        mulsd xTEMPA, xTEMPB
        cvttsd2si $A, xTEMPA
        pxor xTEMPA, xTEMPA
        pxor xTEMPB, xTEMPB
        xor rTEMPC, rTEMPC
        jmp $NEXT_INSTRUCTION
    case XX
      code
        mulsd $A, $B
        jmp $NEXT_INSTRUCTION
    case XD
      code
        cvtsi2sd xTEMPA, $B
        mulsd $A, xTEMPA
        pxor xTEMPA, xTEMPA
        jmp $NEXT_INSTRUCTION
    case XI XC
      code
        $LD_B_IMMEDIATE
        cvtsi2sd xTEMPA, rTEMPC
        mulsd $A, xTEMPA
        xor rTEMPC, rTEMPC
        pxor xTEMPA, xTEMPA
        jmp $NEXT_INSTRUCTION
    case XCf XF
      code
        $LD_B_IMMEDIATE
        movq xTEMPA, rTEMPC
        mulsd $A, xTEMPA
        xor rTEMPA, rTEMPA
        pxor xTEMPA, xTEMPA
        jmp $NEXT_INSTRUCTION

instruction div
  operand
    type data xmmx
    $A $VALUE
  operand
    type data xmmx const fconst integer float
    $B $VALUE
    scramble rTEMPC $LD_B_IMMEDIATE
  select-template
    case DD
      code
        mov rTEMPA, $A
        cqo
        idiv $B
        mov $A, rTEMPA
        xor rTEMPA, rTEMPA
        xor rTEMPD, rTEMPD
        jmp $NEXT_INSTRUCTION
    case DI DC
      code
        $LD_B_IMMEDIATE
        mov rTEMPA, $A
        cqo
        idiv rTEMPC
        mov $A, rTEMPA
        xor rTEMPA, rTEMPA
        xor rTEMPC, rTEMPC
        xor rTEMPD, rTEMPD
        jmp $NEXT_INSTRUCTION
    case DX
      code
        $LD_B_IMMEDIATE
        cvtsi2sd xTEMPA, $A
        cvtsi2sd xTEMPB, rTEMPC
        divsd xTEMPA, xTEMPB
        cvttsd2si $A, xTEMPA
        pxor xTEMPA, xTEMPA
        pxor xTEMPB, xTEMPB
        pxor rTEMPC, rTEMPC
        jmp $NEXT_INSTRUCTION
    case DF DCf
      code
        $LD_B_IMMEDIATE
        movq xTEMPB, rTEMPC
        cvtsi2sd xTEMPA, $A
        divsd xTEMPA, xTEMPB
        cvttsd2si $A, xTEMPA
        xor rTEMPA, rTEMPA
        pxor xTEMPA, xTEMPA
        pxor xTEMPB, xTEMPB
        pxor rTEMPC, rTEMPC
        jmp $NEXT_INSTRUCTION
    case XX
      code
        divsd $A, $B
        jmp $NEXT_INSTRUCTION
    case XD
      code
        cvtsi2sd xTEMPA, $B
        divsd $A, xTEMPA
        pxor xTEMPA, xTEMPA
        jmp $NEXT_INSTRUCTION
    case XI XC
      code
        $LD_B_IMMEDIATE
        cvtsi2sd xTEMPA, rTEMPC
        divsd $A, xTEMPA
        xor rTEMPA, rTEMPA
        pxor xTEMPA, xTEMPA
        jmp $NEXT_INSTRUCTION
    case XCf XF
      code
        $LD_B_IMMEDIATE
        movq xTEMPA, rTEMPA
        divsd $A, xTEMPA
        xor rTEMPA, rTEMPA
        pxor xTEMPA, xTEMPA
        jmp $NEXT_INSTRUCTION

subroutine shift
  operand 
    type data
    $A $VALUE
  operand
    type data integer const
    $B $VALUE
    scramble rTEMPC $LD_B_IMMEDIATE
  select-template
    case DD
      code 
        mov rcx, $B
        $INSTRUCTION $A, rcx
        xor rcx, rcx
        jmp $NEXT_INSTRUCTION
    case DI DC
      code 
        $LD_B_IMMEDIATE
        $INSTRUCTION $A, cl
        xor rTEMPC, rTEMPC
        jmp $NEXT_INSTRUCTION

instruction shift-left
  $INSTRUCTION shl
  sub shift

instruction shift-right
  $INSTRUCTION shr
  sub shift

instruction rotate-left
  $INSTRUCTION rol
  sub shift

instruction rotate-right
  $INSTRUCTION ror
  sub shift

instruction inc
  $INSTRUCTION inc
  sub simple_unary_instruction

instruction dec
  $INSTRUCTION dec
  sub simple_unary_instruction

instruction goto
  operand
    type branch
    $JTARGET $VALUE
  select-template
    case L
      code
        jmp $JTARGET

instruction tcall
  operand
    type tapi
    $A $VALUE
  code
    store_context    
    
    ; align the data registers with the unix call
    rdfsbase rdi
    mov rsi, rB
    mov rdx, rC
    mov rcx, rD
    ;rE, rF are aligned

    rdfsbase r14
    
    load_runtimecontext r14
    ;mov rax, fs:[context.controlstate]
    ;mov r12, [rax + controlstate.runtime_registers + 56]
    ;mov r13, [rax + controlstate.runtime_registers + 64]
    ;wrfsbase r12
    ;wrgsbase r13
    ;mov rbx, [rax + controlstate.runtime_registers + 0]
    ;mov rbp, [rax + controlstate.runtime_registers + 8]
    ;mov rsp, [rax + controlstate.runtime_registers + 16]
    ;mov r12, [rax + controlstate.runtime_registers + 24]
    ;mov r13, [rax + controlstate.runtime_registers + 32]
    
    xor rax, rax
    xor r10, r10
    xor r11, r11
    
    push rbp
    mov r10, $A
    call r10
    
    pop rbp
    validate_context_pointer r14
    load_context r14
    
    xor rTEMPA, rTEMPA
    xor rTEMPC, rTEMPC
    xor rTEMPD, rTEMPD
    
    jmp $NEXT_INSTRUCTION
    

instruction ccall
  operand
    type data capi
    $A $VALUE
  operand
    type capi none
    $B $VALUE
  select-template
    case CfuncN
      code
        store_context
        
        ; align the data registers with the unix call
        mov rdi, rA
        mov rsi, rB
        mov rdx, rC
        mov rcx, rD
        ;rE, rF are already aligned
        
        rdfsbase r14
        load_runtimecontext r14
        
        ;mov rTEMPA, fs:[context.controlstate]

        ;mov r12, [r14 + controlstate.runtime_registers + 56]
        ;mov r13, [r14 + controlstate.runtime_registers + 64]
        ;wrfsbase r12
        ;wrgsbase r13
        ;mov rbx, [r14 + controlstate.runtime_registers + 0]
        ;mov rbp, [r14 + controlstate.runtime_registers + 8]
        ;mov rsp, [r14 + controlstate.runtime_registers + 16]
        ;mov r12, [r14 + controlstate.runtime_registers + 24]
        ;mov r13, [r14 + controlstate.runtime_registers + 32]
        
        push rbp
        mov r10, $A
        call r10
        
        pop rbp
        validate_context_pointer r14
        load_context r14
        
        xor rTEMPA, rTEMPA
        xor rTEMPC, rTEMPC
        xor rTEMPD, rTEMPD
        
        jmp $NEXT_INSTRUCTION
    case DCfunc
      code
        store_context
        
        ; align the data registers with the unix call
        mov rdi, rA
        mov rsi, rB
        mov rdx, rC
        mov rcx, rD
        ;rE, rF are already aligned
        
        rdfsbase r14
        load_runtimecontext r14
        
        ;mov rTEMPA, fs:[context.controlstate]
        ;mov r12, [rTEMPA + controlstate.runtime_registers + 56]
        ;mov r13, [rTEMPA + controlstate.runtime_registers + 64]
        ;wrfsbase r12
        ;wrgsbase r13
        ;mov rbx, [rTEMPA + controlstate.runtime_registers + 0]
        ;mov rbp, [rTEMPA + controlstate.runtime_registers + 8]
        ;mov rsp, [rTEMPA + controlstate.runtime_registers + 16]
        ;mov r12, [rTEMPA + controlstate.runtime_registers + 24]
        ;mov r13, [rTEMPA + controlstate.runtime_registers + 32]
        
        push rbp
        mov r10, $B
        call r10
        
        pop rbp
        mov rTEMPD, rTEMPA
        
        validate_context_pointer r14
        load_context r14
        
        mov $A, rTEMPD
        
        xor rTEMPA, rTEMPA
        xor rTEMPC, rTEMPC
        xor rTEMPD, rTEMPD
        
        jmp $NEXT_INSTRUCTION
    case CfuncCfunc DN
      error

instruction if
  opt-operand
    type vec-float-format
  operand
    type xmmx data integer const fconst float
    $A $VALUE
    scramble rTEMPA $LD_IMMEDIATE_A
  operand
    type comparator
    $CJUMP $VALUE
  operand
    type xmmx data integer const fconst float
    $B $VALUE
    scramble rTEMPC $LD_IMMEDIATE_B
  operand
    type branch
    $JTARGET $VALUE
  select-template
    case DTDL
      code
        cmp $A, $B
        $CJUMP .pass
        jmp $NEXT_INSTRUCTION
        .pass:
        jmp $JTARGET
    case DTIL DTCL
      code
        $LD_IMMEDIATE_B
        cmp $A, rTEMPC
        $CJUMP .pass
        xor rTEMPC, rTEMPC
        jmp $NEXT_INSTRUCTION
        .pass:
        xor rTEMPC, rTEMPC
        jmp $JTARGET
    case ITDL CTDL
      code
        $LD_IMMEDIATE_A
        cmp rTEMPA, $B
        $CJUMP .pass
        xor rTEMPA, rTEMPA
        jmp $NEXT_INSTRUCTION
        .pass:
        xor rTEMPA, rTEMPA
        jmp $JTARGET
    case ITIL ITCL CTIL CTCL
      code
        $LD_IMMEDIATE_A
        $LD_IMMEDIATE_B
        cmp rTEMPA, rTEMPC
        $CJUMP .pass
        xor rTEMPA, rTEMPA
        xor rTEMPC, rTEMPC
        jmp $NEXT_INSTRUCTION
        .pass:
        xor rTEMPA, rTEMPA
        xor rTEMPC, rTEMPC
        jmp $JTARGET
    
    # comparison with floats on xmmx registers
    #  For packed floats, these all pass if any comparisons pass
    #  These should work as expected for comparisons involving Individual floats
    #   (for more fine-grained controls, you'll probably have to unpack and compare them individualls
    #    It might be worthwhile to add a function which simply compares xmmx values and only extracts the
    #    result)
    # Comparisons of xmmx register with data register assumes that the xmmx register is a float and the data register
    # is an integer
    # Floating point comparisons wherein neither operand is stored on an xmmx register are unspported
    #   (due to only one xmmx temp register reserved)
    case XTXL
      code
        mov$VECFMT xTEMPA, $A
        cmp$VECFMT xTEMPA, $B, $VPRED
        movq rTEMPA, xTEMPA
        cmp rTEMPA, 0
        jne .pass
        xor rTEMPA, rTEMPA
        pxor xTEMPA, xTEMPA
        jmp $NEXT_INSTRUCTION
        .pass:
        xor rTEMPA, rTEMPA
        pxor xTEMPA, xTEMPA
        jmp $JTARGET
    case DTXL
      code
        cvtsi2$VECFMT xTEMPA, $A
        cmp$VECFMT xTEMPA, $B, $VPRED
        movq rTEMPA, xTEMPA
        cmp rTEMPA, 0
        jne .pass
        xor rTEMPA, rTEMPA
        pxor xTEMPA, xTEMPA
        jmp $NEXT_INSTRUCTION
        .pass:
        xor rTEMPA, rTEMPA
        pxor xTEMPA, xTEMPA
        jmp $JTARGET
    case FTXL CfTXL
      code
        $LD_IMMEDIATE_A
        movq xTEMPA, rTEMPA
        cmp$VECFMT xTEMPA, $B, $VPRED
        movq rTEMPA, xTEMPA
        cmp rTEMPA, 0
        jne .pass
        xor rTEMPA, rTEMPA
        pxor xTEMPA, xTEMPA
        jmp $NEXT_INSTRUCTION
        .pass:
        xor rTEMPA, rTEMPA
        pxor xTEMPA, xTEMPA
        jmp $JTARGET
    case ITXL CTXL
      code
        $LD_IMMEDIATE_A
        cvtsi2$VECFMT xTEMPA, rTEMPA
        cmp$VECFMT xTEMPA, $B, $VPRED
        movq rTEMPA, xTEMPA
        cmp rTEMPA, 0
        jne .pass
        xor rTEMPA, rTEMPA
        pxor xTEMPA, xTEMPA
        jmp $NEXT_INSTRUCTION
        .pass:
        xor rTEMPA, rTEMPA
        pxor xTEMPA, xTEMPA
        jmp $JTARGET
    case XTDL
      code
        cvtsi2$VECFMT xTEMPA, $B
        cmp$VECFMT xTEMPA, $A, $VPREDCOMPLEMENT
        movq rTEMPA, xTEMPA
        cmp rTEMPA, 0
        jne .pass
        xor rTEMPA, rTEMPA
        pxor xTEMPA, xTEMPA
        jmp $NEXT_INSTRUCTION
        .pass:
        xor rTEMPA, rTEMPA
        pxor xTEMPA, xTEMPA
        jmp $JTARGET
    case XTFL XTCfL
      code
        $LD_IMMEDIATE_B
        movq xTEMPA, rTEMPC
        cmp$VECFMT xTEMPA, $A, $VPREDCOMPLEMENT
        movq rTEMPA, xTEMPA
        cmp rTEMPA, 0
        jne .pass
        xor rTEMPA, rTEMPA
        xor rTEMPC, rTEMPC
        pxor xTEMPA, xTEMPA
        jmp $NEXT_INSTRUCTION
        .pass:
        xor rTEMPA, rTEMPA
        xor rTEMPC, rTEMPC
        pxor xTEMPA, xTEMPA
        jmp $JTARGET
    case XTIL XTCL
      code
        $LD_IMMEDIATE_B
        cvtsi2$VECFMT xTEMPA, rTEMPC
        cmp$VECFMT xTEMPA, $A, $VPREDCOMPLEMENT
        movq rTEMPA, xTEMPA
        cmp rTEMPA, 0
        jne .pass
        xor rTEMPA, rTEMPA
        xor rTEMPC, rTEMPC
        pxor xTEMPA, xTEMPA
        jmp $NEXT_INSTRUCTION
        .pass:
        xor rTEMPA, rTEMPA
        xor rTEMPC, rTEMPC
        pxor xTEMPA, xTEMPA
        jmp $JTARGET
    
    case DTFL DTCfL
      code
        $LD_IMMEDIATE_B
        cvtsi2$VECFMT xTEMPA, $A
        movq xTEMPB, rTEMPC
        movq rTEMPA, xTEMPA
        cmp rTEMPA, 0
        jne .pass
        xor rTEMPA, rTEMPA
        xor rTEMPC, rTEMPC
        pxor xTEMPA, xTEMPA
        pxor xTEMPB, xTEMPB
        jmp $NEXT_INSTRUCTION
        .pass:
        xor rTEMPA, rTEMPA
        xor rTEMPC, rTEMPC
        pxor xTEMPA, xTEMPA
        pxor xTEMPB, xTEMPB
        jmp $JTARGET
    case FTDL CfTDL
      code
        $LD_IMMEDIATE_A
        movq xTEMPA, rTEMPA
        mov$VECFMT xTEMPB, $B
        movq rTEMPA, xTEMPA
        cmp rTEMPA, 0
        jne .pass
        xor rTEMPA, rTEMPA
        xor rTEMPC, rTEMPC
        pxor xTEMPA, xTEMPA
        pxor xTEMPB, xTEMPB
        jmp $NEXT_INSTRUCTION
        .pass:
        xor rTEMPA, rTEMPA
        xor rTEMPC, rTEMPC
        pxor xTEMPA, xTEMPA
        pxor xTEMPB, xTEMPB
        jmp $JTARGET
    case FTIL FTCL CfTIL CfTCL
      code
        $LD_IMMEDIATE_A
        $LD_IMMEDIATE_B
        movq xTEMPA, rTEMPA
        mov$VECFMT xTEMPB, rTEMPC
        movq rTEMPA, xTEMPA
        cmp rTEMPA, 0
        jne .pass
        xor rTEMPA, rTEMPA
        xor rTEMPC, rTEMPC
        pxor xTEMPA, xTEMPA
        pxor xTEMPB, xTEMPB
        jmp $NEXT_INSTRUCTION
        .pass:
        xor rTEMPA, rTEMPA
        xor rTEMPC, rTEMPC
        pxor xTEMPA, xTEMPA
        pxor xTEMPB, xTEMPB
        jmp $JTARGET
    # maximum silliness
    case FTFL CfTFL FTCfL CfTCfL
      code
        $LD_IMMEDIATE_A
        $LD_IMMEDIATE_B
        movq xTEMPA, rTEMPA
        movq xTEMPB, rTEMPC
        movq rTEMPA, xTEMPA
        cmp rTEMPA, 0
        jne .pass
        xor rTEMPA, rTEMPA
        xor rTEMPC, rTEMPC
        pxor xTEMPA, xTEMPA
        pxor xTEMPB, xTEMPB
        jmp $NEXT_INSTRUCTION
        .pass:
        xor rTEMPA, rTEMPA
        xor rTEMPC, rTEMPC
        pxor xTEMPA, xTEMPA
        pxor xTEMPB, xTEMPB
        jmp $JTARGET

instruction cpuclocks
  code
    rdtsc
    shl rTEMPD, 32
    or rTEMPA, rTEMPD
    mov fs:[context.diagnostic_out+0], rTEMPA
    xor rTEMPA, rTEMPA
    xor rTEMPD, rTEMPD
    jmp $NEXT_INSTRUCTION

instruction stash
  operand
  flags
    contains a1
      code
        mov gs:[microcontext.a1], rA
    contains a2
      code
        mov gs:[microcontext.a2], rA
    contains a3
      code
        mov gs:[microcontext.a3], rA
    contains b1
      code
        mov gs:[microcontext.b1], rB
    contains b2
      code
        mov gs:[microcontext.b2], rB
    contains b3
      code
        mov gs:[microcontext.b3], rB
    contains c1
      code
        mov gs:[microcontext.c1], rC
    contains c2
      code
        mov gs:[microcontext.c2], rC
    contains c3
      code
        mov gs:[microcontext.c3], rC
    contains d1
      code
        mov gs:[microcontext.d1], rD
    contains d2
      code
        mov gs:[microcontext.d2], rD
    contains d3
      code
        mov gs:[microcontext.d3], rD
    contains e1
      code
        mov gs:[microcontext.e1], rE
    contains e2
      code
        mov gs:[microcontext.e2], rE
    contains e3
      code
        mov gs:[microcontext.e3], rE
    contains f1
      code
        mov gs:[microcontext.f1], rF
    contains f2
      code
        mov gs:[microcontext.f2], rF
    contains f3
      code
        mov gs:[microcontext.f3], rF
    contains x1a
      code
        movq gs:[microcontext.x1a], xA
    contains x1b
      code
        movq gs:[microcontext.x1b], xB
    contains x1c
      code
        movq gs:[microcontext.x1c], xC
    contains x1d
      code
        movq gs:[microcontext.x1d], xD
    contains x1e
      code
        movq gs:[microcontext.x1e], xE
    contains x1f
      code
        movq gs:[microcontext.x1f], xF
    contains x1g
      code
        movq gs:[microcontext.x1g], xG
    contains x1h
      code
        movq gs:[microcontext.x1h], xH
    contains x1i
      code
        movq gs:[microcontext.x1i], xI
    contains x1j
      code
        movq gs:[microcontext.x1j], xJ
    contains x1k
      code
        movq gs:[microcontext.x1k], xK
    contains x1l
      code
        movq gs:[microcontext.x1l], xL
    contains x1m
      code
        movq gs:[microcontext.x1m], xM
    contains x1n
      code
        movq gs:[microcontext.x1n], xN
    #contains x1o
    #  code
    #    movq gs:[microcontext.x1o], xO
    #contains x1p
    #  code
    #    movq gs:[microcontext.x1p], xP
    
    contains x2a
      code
        movq gs:[microcontext.x2a], xA
    contains x2b
      code
        movq gs:[microcontext.x2b], xB
    contains x2c
      code
        movq gs:[microcontext.x2c], xC
    contains x2d
      code
        movq gs:[microcontext.x2d], xD
    contains x2e
      code
        movq gs:[microcontext.x2e], xE
    contains x2f
      code
        movq gs:[microcontext.x2f], xF
    contains x2g
      code
        movq gs:[microcontext.x2g], xG
    contains x2h
      code
        movq gs:[microcontext.x2h], xH
    contains x2i
      code
        movq gs:[microcontext.x2i], xI
    contains x2j
      code
        movq gs:[microcontext.x2j], xJ
    contains x2k
      code
        movq gs:[microcontext.x2k], xK
    contains x2l
      code
        movq gs:[microcontext.x2l], xL
    contains x2m
      code
        movq gs:[microcontext.x2m], xM
    contains x2n
      code
        movq gs:[microcontext.x2n], xN
    #contains x2o
    #  code
    #    movq gs:[microcontext.x2o], xO
    #contains x2p
    #  code
    #    movq gs:[microcontext.x2p], xP
    
    contains xa
      code
        movdqu gs:[microcontext.xa], xA
    contains xb
      code
        movdqu gs:[microcontext.xb], xB
    contains xc
      code
        movdqu gs:[microcontext.xc], xC
    contains xd
      code
        movdqu gs:[microcontext.xd], xD
    contains xe
      code
        movdqu gs:[microcontext.xe], xE
    contains xf
      code
        movdqu gs:[microcontext.xf], xF
    contains xg
      code
        movdqu gs:[microcontext.xg], xG
    contains xh
      code
        movdqu gs:[microcontext.xh], xH
    contains xi
      code
        movdqu gs:[microcontext.xi], xI
    contains xj
      code
        movdqu gs:[microcontext.xj], xJ
    contains xk
      code
        movdqu gs:[microcontext.xk], xK
    contains xl
      code
        movdqu gs:[microcontext.xl], xL
    contains xm
      code
        movdqu gs:[microcontext.xm], xM
    contains xn
      code
        movdqu gs:[microcontext.xn], xN
    #contains xo
    #  code
    #    movdqu gs:[microcontext.xo], xO
    #contains xp
    #  code
    #    movdqu gs:[microcontext.xp], xP
  code
    jmp $NEXT_INSTRUCTION

instruction unstash
  operand
  flags
    contains a1
      code
        mov rA, gs:[microcontext.a1]
    contains a2
      code
        mov rA, gs:[microcontext.a2]
    contains a3
      code
        mov rA, gs:[microcontext.a3]
    contains b1
      code
        mov rB, gs:[microcontext.b1]
    contains b2
      code
        mov rB, gs:[microcontext.b2]
    contains b3
      code
        mov rB, gs:[microcontext.b3]
    contains c1
      code
        mov rC, gs:[microcontext.c1]
    contains c2
      code
        mov rC, gs:[microcontext.c2]
    contains c3
      code
        mov rC, gs:[microcontext.c3]
    contains d1
      code
        mov rD, gs:[microcontext.d1]
    contains d2
      code
        mov rD, gs:[microcontext.d2]
    contains d3
      code
        mov rD, gs:[microcontext.d3]
    contains e1
      code
        mov rE, gs:[microcontext.e1]
    contains e2
      code
        mov rE, gs:[microcontext.e2]
    contains e3
      code
        mov rE, gs:[microcontext.e3]
    contains f1
      code
        mov rF, gs:[microcontext.f1]
    contains f2
      code
        mov rF, gs:[microcontext.f2]
    contains f3
      code
        mov rF, gs:[microcontext.f3]
    contains x1a
      code
        movq xA, gs:[microcontext.x1a]
    contains x1b
      code
        movq xB, gs:[microcontext.x1b]
    contains x1c
      code
        movq xC, gs:[microcontext.x1c]
    contains x1d
      code
        movq xD, gs:[microcontext.x1d]
    contains x1e
      code
        movq xE, gs:[microcontext.x1e]
    contains x1f
      code
        movq xF, gs:[microcontext.x1f]
    contains x1g
      code
        movq xG, gs:[microcontext.x1g]
    contains x1h
      code
        movq xH, gs:[microcontext.x1h]
    contains x1i
      code
        movq xI, gs:[microcontext.x1i]
    contains x1j
      code
        movq xJ, gs:[microcontext.x1j]
    contains x1k
      code
        movq xK, gs:[microcontext.x1k]
    contains x1l
      code
        movq xL, gs:[microcontext.x1l]
    contains x1m
      code
        movq xM, gs:[microcontext.x1m]
    contains x1n
      code
        movq xN, gs:[microcontext.x1n]
    #contains x1o
    #  code
    #    movq xO, gs:[microcontext.x1o]
    #contains x1p
    #  code
    #    movq xP, gs:[microcontext.x1p]
    
    contains x2a
      code
        movq xA, gs:[microcontext.x2a]
    contains x2b
      code
        movq xB, gs:[microcontext.x2b]
    contains x2c
      code
        movq xC, gs:[microcontext.x2c]
    contains x2d
      code
        movq xD, gs:[microcontext.x2d]
    contains x2e
      code
        movq xE, gs:[microcontext.x2e]
    contains x2f
      code
        movq xF, gs:[microcontext.x2f]
    contains x2g
      code
        movq xG, gs:[microcontext.x2g]
    contains x2h
      code
        movq xH, gs:[microcontext.x2h]
    contains x2i
      code
        movq xI, gs:[microcontext.x2i]
    contains x2j
      code
        movq xJ, gs:[microcontext.x2j]
    contains x2k
      code
        movq xK, gs:[microcontext.x2k]
    contains x2l
      code
        movq xL, gs:[microcontext.x2l]
    contains x2m
      code
        movq xM, gs:[microcontext.x2m]
    contains x2n
      code
        movq xN, gs:[microcontext.x2n]
    contains x2o
      code
        movq xO, gs:[microcontext.x2o]
    #contains x2p
    #  code
    #    movq xP, gs:[microcontext.x2p]

    contains xa
      code
        movdqu xA, gs:[microcontext.xa]
    contains xb
      code
        movdqu xB, gs:[microcontext.xb]
    contains xc
      code
        movdqu xC, gs:[microcontext.xc]
    contains xd
      code
        movdqu xD, gs:[microcontext.xd]
    contains xe
      code
        movdqu xE, gs:[microcontext.xe]
    contains xf
      code
        movdqu xF, gs:[microcontext.xf]
    contains xg
      code
        movqdqu xG, gs:[microcontext.xg]
    contains xh
      code
        movqdqu xH, gs:[microcontext.xh]
    contains xi
      code
        movqdqu xI, gs:[microcontext.xi]
    contains xj
      code
        movdqu xJ, gs:[microcontext.xj]
    contains xk
      code
        movdqu xK, gs:[microcontext.xk]
    contains xl
      code
        movdqu xL, gs:[microcontext.xl]
    contains xm
      code
        movdqu xM, gs:[microcontext.xm]
    contains xn
      code
        movdqu xN, gs:[microcontext.xn]
    #contains xo
    #  code
    #    movdqu xO, gs:[microcontext.xo]
    #contains xp
    #  code
    #    movdqu xP, gs:[microcontext.xp]
    
  code
    jmp $NEXT_INSTRUCTION

instruction lwcall
  operand
    type branch
    $JTARGET $VALUE
    scramble rTEMPC $LD_RETURN_TARGET $COMMAND_INDEX_NEXT
  code
    $LD_RETURN_TARGET
    inc rLWCSI_16
    movzx rTEMPA, rLWCSI_16
    shl rTEMPA, 2
    add rTEMPA, fs:[context.lwcall_stack_address]
    mov dword [rTEMPA], rTEMPC_32
    xor rTEMPA, rTEMPA
    xor rTEMPC, rTEMPC
    jmp $JTARGET

instruction lwreturn
  code
    movzx rMAPPER, rLWCSI_16
    cmp rLWCSI_16, fs:[context.lwcall_floor]
    errorlt STATUS_STACK_UNDERFLOW
    shl rMAPPER, 2
    add rMAPPER, fs:[context.lwcall_stack_address]
    mov rMAPPER_32, [rMAPPER]
    ;cmp rMAPPER, fs:[context.instruction_count]
    ;errorge STATUS_ROGUE_BRANCH
    dec rLWCSI_16
    shl rMAPPER, 3
    add rMAPPER, fs:[context.program_map]
    jmp [rMAPPER]

instruction mctxpush
  code
    inc rMCSI_16
    movzx rTEMPA, rMCSI_16
    shl rTEMPA, microcontext_size_bits
    add rTEMPA, fs:[context.microcontext_stack_address]
    wrgsbase rTEMPA
    xor rTEMPA, rTEMPA
    jmp $NEXT_INSTRUCTION

instruction mctxpop
  code
    dec rMCSI_16
    movzx rTEMPA, rMCSI_16
    shl rTEMPA, microcontext_size_bits
    add rTEMPA, fs:[context.microcontext_stack_address]
    wrgsbase rTEMPA
    xor rTEMPA, rTEMPA
    jmp $NEXT_INSTRUCTION

instruction tvmpush
  operand
    type data const integer
    $PROG_HANDLE $VALUE
    scramble rTEMPA $LD_IMMEDIATE_PROG_HANDLE
  operand
    type data const integer
    $FUNC_HANDLE $VALUE
    scramble rTEMPA $LD_IMMEDIATE_FUNC_HANDLE
  select-template
    case DD
      code
        mov rTEMPC, fs:[context.stack]
        mov rTEMPA, [rTEMPC + tactyk_stack.stack_lock]
        cmp rTEMPA, 0
        errorneq STATUS_INVALID_TVMJUMP
        mov qword [rTEMPC + tactyk_stack.stack_lock], 1
        mov rTEMPA, [rTEMPC + tactyk_stack.stack_position]
        inc rTEMPA
        cmp rTEMPA, stacksize
        errorge STATUS_INVALID_TVMJUMP_STATE
        mov [rTEMPC + tactyk_stack.stack_position], rTEMPA

        ; rTEMPC -> stack entry pointer
        imul rTEMPA, tvmstackentry_size
        add rTEMPC, tactyk_stack.stack
        add rTEMPC, rTEMPA
        
        mov rTEMPA, fs:[context.floor]
        mov rMAPPER, fs:[context.program_map]
        mov [rTEMPC + tvmstackentry.source_program], rMAPPER
        mov [rTEMPC + tvmstackentry.source_stack_floor], rTEMPA
        xor rMAPPER, rMAPPER
        
        ; validate $PROG_HANDLE
        ; rTEMPA -> program index
        mov rTEMPA, $PROG_HANDLE
        cmp rTEMPA, 0
        errorlt STATUS_INVALID_TVMJUMP
        mov rTEMPD, fs:[context.vm]
        cmp rTEMPA, [rTEMPD + tactyk_vm.program_count]
        errorge STATUS_INVALID_TVMJUMP
        
        ; rTEMPD -> program declaration
        mov rTEMPD, [rTEMPD + tactyk_vm.program_list]
        imul rTEMPA, program_dec_size
        add rTEMPD, rTEMPA
        
        ; obtain target jump tables.
        mov rTEMPA, [rTEMPD + program_dec.instruction_jumptable]
        mov rMAPPER, [rTEMPD + program_dec.function_jumptable]
        mov [rTEMPC + tvmstackentry.target_program], rTEMPA
        mov [rTEMPC + tvmstackentry.target_function_jumptable], rMAPPER
        
        ; validate $FUNC_HANDLE
        ;mov fs:[ctx.extra], rTEMPD
        mov rTEMPA, $FUNC_HANDLE
        ;mov rTEMPD, fs:[ctx.extra]
        cmp rTEMPA, 0
        errorlt STATUS_INVALID_TVMJUMP
        cmp rTEMPA, [rTEMPD + program_dec.function_count]
        errorge STATUS_INVALID_TVMJUMP        
        mov [rTEMPC + tvmstackentry.target_jump_index], rTEMPA
        
        xor rTEMPA, rTEMPA
        xor rTEMPC, rTEMPC
        xor rTEMPD, rTEMPD
        xor rMAPPER, rMAPPER
        
        ; the only thing missing here is the return index (not avaialble until the actual jump).
        jmp $NEXT_INSTRUCTION

instruction tvmjump
  $KW dword
  scramble rTEMPA $LD_CMDNEXT_IMMEDIATE $COMMAND_INDEX_NEXT
  code
    mov dword fs:[context.lwcall_floor], rLWCSI_32
    mov dword fs:[context.microcontext_floor], rMCSI_32
    
    mov rTEMPC, fs:[context.stack]
    mov rTEMPA, [rTEMPC + tactyk_stack.stack_lock]
    cmp rTEMPA, 1
    errorneq STATUS_INVALID_TVMJUMP
    mov qword [rTEMPC + tactyk_stack.stack_lock], 0
    mov rTEMPA, [rTEMPC + tactyk_stack.stack_position]
    
    ; rTEMPC -> stack entry pointer
    imul rTEMPA, tvmstackentry_size
    add rTEMPC, tactyk_stack.stack
    add rTEMPC, rTEMPA
    
    $LD_CMDNEXT_IMMEDIATE
    mov [rTEMPC + tvmstackentry.source_return_index], rTEMPA
    
    ; load the target context
    mov rTEMPA, [rTEMPC + tvmstackentry.target_program]
    mov fs:[context.program_map], rTEMPA
    
    ; prepare the jump
    mov rMAPPER, [rTEMPC + tvmstackentry.target_jump_index]
    shl rMAPPER, 3
    add rMAPPER, [rTEMPC + tvmstackentry.target_function_jumptable]
    
    ; go!
    xor rTEMPA, rTEMPA
    xor rTEMPC, rTEMPC
    jmp [rMAPPER]

instruction tvmreturn
  code
    mov rTEMPC, fs:[context.stack]
    mov rTEMPA, [rTEMPC + tactyk_stack.stack_lock]
    cmp rTEMPA, 0
    errorneq STATUS_INVALID_TVMJUMP
    mov rTEMPA, [rTEMPC + tactyk_stack.stack_position]
    cmp rTEMPA, 0
    errorlt STATUS_STACK_UNDERFLOW
    mov rTEMPD, rTEMPA
    dec rTEMPA
    mov [rTEMPC + tactyk_stack.stack_position], rTEMPA
    
    ; rTEMPC -> stack entry pointer
    imul rTEMPD, tvmstackentry_size
    add rTEMPC, tactyk_stack.stack
    add rTEMPC, rTEMPD
    
    ; restore the caller context
    mov rTEMPD, [rTEMPC + tvmstackentry.source_stack_floor]
    mov fs:[context.floor], rTEMPD
    mov rMAPPER, [rTEMPC + tvmstackentry.source_program]
    mov fs:[context.program_map], rMAPPER
    
    ; prepare a return jump
    mov rTEMPA, [rTEMPC + tvmstackentry.source_return_index]
    shl rTEMPA, 3
    add rMAPPER, rTEMPA
    
    ; zero out the stack entry (or delete this if too much paranoia)
    mov qword [rTEMPC + tvmstackentry.source_program], 0
    mov qword [rTEMPC + tvmstackentry.source_return_index], 0
    mov qword [rTEMPC + tvmstackentry.source_stack_floor], 0
    mov qword [rTEMPC + tvmstackentry.target_program], 0
    mov qword [rTEMPC + tvmstackentry.target_jump_index], 0
    
    
    xor rTEMPA, rTEMPA
    xor rTEMPC, rTEMPC
    xor rTEMPD, rTEMPD
    jmp [rMAPPER]

typespec vec-float-format
  $VECFMT sd
  select-operand
    case pd PD
      $VECFMT pd
    case ps PS
      $VECFMT ps
    case pd SD
      $VECFMT sd
    case ps SS
      $VECFMT ss

typespec xmmx
  select-operand
    case x0 xmm0 xa
      value xmm0
    case x1 xmm1 xb
      value xmm1
    case x2 xmm2 xc
      value xmm2
    case x3 xmm3 xd
      value xmm3
    case x4 xmm4 xe
      value xmm4
    case x5 xmm5 xf
      value xmm5
    case x6 xmm6 xg
      value xmm6
    case x7 xmm7 xh
      value xmm7
    case x8 xmm8 xi
      value xmm8
    case x9 xmm9 xj
      value xmm9
    case x10 xmm10 xk
      value xmm10
    case x11 xmm11 xl
      value xmm11
    case x12 xmm12 xm
      value xmm12
    case x13 xmm13 xn
      value xmm13
  pick X

typespec vec-transform
  select-operand
    case itof
      pick Itof
    case float
    case ftoi
      pick Ftoi

instruction vec-in
  opt-operand
    type vec-transform
  operand
    type xmmx
    $DEST $VALUE
  operand
    type data xmmx address integer float const
    $SOURCE $VALUE
    scramble rTEMPA $LD_SOURCE_IMMEDIATE
  operand
    type integer const none
    scramble rTEMPC $LD_OFFSET_IMMEDIATE
  select-template
    # load a floating point from a data register or transfer between xmm registers
    case XXN XDN
      code
        movq $DEST, $SOURCE
        jmp $NEXT_INSTRUCTION
    
    case XFN
      code
        $LD_SOURCE_IMMEDIATE
        movq $DEST, rTEMPA
        xor rTEMPA, rTEMPA
        jmp $NEXT_INSTRUCTION
      
    # load floating point value(s) from memory
    case XAI XAC
      code
        $LD_OFFSET_IMMEDIATE
        mov rTEMPA_32, fs:[$CTX_ELEMENT_BOUND]
        cmp rTEMPC, rTEMPA
        errorge STATUS_ROGUE_POINTER
        cmp rTEMPC, 0
        errorlt STATUS_ROGUE_POINTER
        lfence
        movq $DEST, [$SOURCE+rTEMPC]
        xor rTEMPC, rTEMPC
        jmp $NEXT_INSTRUCTION
    
    case ItofXIN ItofXCN
      code
        $LD_SOURCE_IMMEDIATE
        cvtsi2sd $DEST, rTEMPA
        xor rTEMPA, rTEMPA
        jmp $NEXT_INSTRUCTION
    # load an integer value from a data register, convert it to a float
    case ItofXDN
      code
        CVTSI2SD $DEST, $SOURCE
        jmp $NEXT_INSTRUCTION
    
    # load floating point value(s) from memory
    case ItofXAI ItofXAC
      code
        $LD_OFFSET_IMMEDIATE
        mov rTEMPA_32, fs:[$CTX_ELEMENT_BOUND]
        cmp rTEMPC, rTEMPA
        errorge STATUS_ROGUE_POINTER
        cmp rTEMPC, 0
        errorlt STATUS_ROGUE_POINTER
        lfence
        cvtsi2sd $DEST, [$SOURCE+rTEMPC]
        xor rTEMPC, rTEMPC
        jmp $NEXT_INSTRUCTION
        
instruction vec-out
  opt-operand
    type vec-transform
  operand
    type data address
    $DST $VALUE
  operand
    type xmmx integer const
    $B $VALUE
    scramble rTEMPC $LD_OFFSET_IMMEDIATE
  operand
    type xmmx none
    $SOURCE $VALUE
  select-template
    case DXN
      code
        movq $DST, $B
        jmp $NEXT_INSTRUCTION
    case AIX ACX
      code
        $LD_OFFSET_IMMEDIATE
        mov rTEMPA_32, fs:[$CTX_ELEMENT_BOUND]
        cmp rTEMPC, rTEMPA
        errorge STATUS_ROGUE_POINTER
        cmp rTEMPC, 0
        errorlt STATUS_ROGUE_POINTER
        lfence
        
        movq [$DST+rTEMPC], $SOURCE
        xor rTEMPA, rTEMPA
        xor rTEMPC, rTEMPC
        jmp $NEXT_INSTRUCTION
    case FtoiDXN
      code
        CVTTSD2SI $DST, $B
        jmp $NEXT_INSTRUCTION
    case FtoiAIX FtoiACX
      code
        $LD_OFFSET_IMMEDIATE
        mov rTEMPA_32, fs:[$CTX_ELEMENT_BOUND]
        cmp rTEMPC, rTEMPA
        errorge STATUS_ROGUE_POINTER
        cmp rTEMPC, 0
        errorlt STATUS_ROGUE_POINTER
        lfence
        CVTTSD2SI rTEMPA, $SOURCE
        mov [$DST+rTEMPC], rTEMPA
        xor rTEMPA, rTEMPA
        xor rTEMPC, rTEMPC
        jmp $NEXT_INSTRUCTION

instruction vec-add
  opt-operand
    type vec-float-format
  operand
    type xmmx
    $A $VALUE
  operand
    type xmmx
    $B $VALUE
  code
    add$VECFMT $A, $B
    jmp $NEXT_INSTRUCTION

instruction vec-sub
  opt-operand
    type vec-float-format
  operand
    type xmmx
    $A $VALUE
  operand
    type xmmx
    $B $VALUE
  code
    sub$VECFMT $A, $B
    jmp $NEXT_INSTRUCTION

instruction vec-mul
  opt-operand
    type vec-float-format
  operand
    type xmmx
    $A $VALUE
  operand
    type xmmx
    $B $VALUE
  code
    mul$VECFMT $A, $B
    jmp $NEXT_INSTRUCTION

instruction vec-div
  opt-operand
    type vec-float-format
  operand
    type xmmx
    $A $VALUE
  operand
    type xmmx
    $B $VALUE
  code
    div$VECFMT $A, $B
    jmp $NEXT_INSTRUCTION

instruction vec-transfer
  opt-operand
    type vec-float-format
  operand
    type xmmx
    $A $VALUE
  operand
    type xmmx
    $B $VALUE
  code
    mov$VECFMT $A, $B
    jmp $NEXT_INSTRUCTION

















