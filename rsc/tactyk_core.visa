# -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#   Copyright 2023, Jonathan Hart
#   This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation,
#   either version 3 of the License, or (at your option) any later version.
#   This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
#   PURPOSE. See the GNU General Public License for more details.
#   You should have received a copy of the GNU General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.
# -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------


# TACTYK Core Virtual ISA
# This is both the default configuration for TACTYK, as well as an example of how to use configuration-based virtual ISA specification

# low-level type specifications
# Types are determined with by testing.  Parameters for the first matching pattern are applied.

# General handling
#
# This file is loaded into the visa interpreter and stored in data structures matching the indentation
# Each (except for assembly code) is treated as a whitespace-delimited list of tokens.
# Except for assembly code (the "code" keyword), alls are a command, followed by a list of parameters.
#
# Visa specification is a simple domain-specific language for configuring tactyk.  It has subroutines, conditional
# exits, and an unusually sophisticated switch statement (substantially moreso than is typical of high level languages), but
# lacks complex conditions and loops.  Its only operations are pre-defined operator:
#   set variable          -- assign the content of a local variable to another local variable.  (for convenience and tersity, this is also the default operation)
#                            (note:  local variables are shared across all handlers which are invoked directly or indirectly by an instruction handler)
#   parse data            -- convert text to int (eventually this should expand to cover other types)
#   resolve symbol        -- search specified symbol tables for a named entry.
#   rewrite asm code      -- use string subtitution to insert local variables into asm code.
#   conditional fail      -- operator that exits the subroutine if the preceding operation (parse or resolve) failed and invokes the next alternative
#   selectors             -- tests invoked by the "select" operator to determine what block to invoke
#   specialized transform -- code manipulators that are not easily implemented through declarative / macro-like logic alone (for now, just immediate scrambling -- it requires random numbers
#                            and has a major variant if an 8-byte immediate is used)
#   ignore                -- another specialized handler for disregarding comments.

header tactyk_asmvm_header.asm

# enables all of aggressive binary executable randomization
settings
  $ABXR_SCRAMBLE_IMMEDIATES
  $ABXR_RANDOMIZE_EXECUTABLE

# addresses and data registers are recognized by reading code directly.
typespec address
  select-operand
    case @1 addr1 rADDR1
      value rADDR1
      $CTX_ADDR context.addr1
      $CTX_ARRAY_BOUND context.addr1_array_bound
      $CTX_ELEMENT_BOUND context.addr1_element_bound
      $CTX_MEMBLOCK_INDEX context.addr1_memblock_index
    case @2 addr2 rADDR2
      value rADDR2
      $CTX_ADDR context.addr2
      $CTX_ARRAY_BOUND context.addr2_array_bound
      $CTX_ELEMENT_BOUND context.addr2_element_bound
      $CTX_MEMBLOCK_INDEX context.addr2_memblock_index
    case @3 addr3 rADDR3
      value rADDR3
      $CTX_ADDR context.addr3
      $CTX_ARRAY_BOUND context.addr3_array_bound
      $CTX_ELEMENT_BOUND context.addr3_element_bound
      $CTX_MEMBLOCK_INDEX context.addr3_memblock_index
    case @4 addr4 rADDR4
      value rADDR4
      $CTX_ADDR context.addr4
      $CTX_ARRAY_BOUND context.addr4_array_bound
      $CTX_ELEMENT_BOUND context.addr4_element_bound
      $CTX_MEMBLOCK_INDEX context.addr4_memblock_index
  pick A

typespec data
  select-operand
    case a ra rA
      value rA
    case b rb rB
      value rB
    case c rc rC
      value rC
    case d rd rD
      value rD
    case e re rE
      value rE
    case f rf rF
      value rF
  pick D

typespec word
  select-operand
    case byte i8
      pick B
    case word i16
      pick W
    case dword i32
      pick D
    case qword i64
      pick Q
    case float
      pick X

typespec stackreg
  select-operand
    case mctx.pos mcxtstack.pos mctx.position mcxtstack.position
      value rMCSI
      $STACK_FLOOR context.microcontext_floor
    case lwcs.pos lwcstack.pos lwcs.position lwcstack.position
      value rLWCSI
      $STACK_FLOOR context.lwcall_floor
  pick Sreg


# integers are recognized by casting to integer, then range-tested to obtain a byte width.
typespec integer
  int-operand
  pick I

typespec float
  float-operand
  pick F

# symbolic fields are handled by looking them up in symbol tables.
typespec branch
  symbol label
  pick L

typespec const
  symbol const
  pick C

typespec fconst
  symbol fconst
  pick Cf

typespec memblock
  symbol mem
  pick M

typespec capi
  symbol capi
  pick Cfunc

typespec tapi
  symbol tapi
  pick Tfunc

typespec none
  nullarg
  pick N

typespec string
  string-operand
  pick S

typespec context-property
  select-operand
    case addr1.array_bound
      value context.addr1_array_bound
      $KW dword
    case addr1.element_bound
      value context.addr1_element_bound
      $KW dword
    case addr1.index
      value context.addr1_memblock_index
      $KW dword
    case addr1.offset
      value context.addr1_offset
      $KW dword
    case addr2.array_bound
      value context.addr2_array_bound
      $KW dword
    case addr2.element_bound
      value context.addr2_element_bound
      $KW dword
    case addr2.index
      value context.addr2_memblock_index
      $KW dword
    case addr2.offset
      value context.addr2_offset
      $KW dword
    case addr3.array_bound
      value context.addr3_array_bound
      $KW dword
    case addr3.element_bound
      value context.addr3_element_bound
      $KW dword
    case addr3.index
      value context.addr3_memblock_index
      $KW dword
    case addr3.offset
      value context.addr3_offset
      $KW dword
    case addr4.array_bound
      value context.addr4_array_bound
      $KW dword
    case addr4.element_bound
      value context.addr4_element_bound
      $KW dword
    case addr4.index
      value context.addr4_memblock_index
      $KW dword
    case addr4.offset
      value context.addr4_offset
      $KW dword
  pick Ctx

# set up a prototype paramter block 
typespec comparator
  select-operand
    case < lt
      value jl
      $VPRED 1
      $VPREDCOMPLEMENT 6
    case <= le
      value jle
      $VPRED 2
      $VPREDCOMPLEMENT 5
    case == eq
      value je
      $VPRED 0
      $VPREDCOMPLEMENT 0
    case >= ge
      value jge
      $VPRED 5
      $VPREDCOMPLEMENT 2
    case > gt
      value jg
      $VPRED 6
      $VPREDCOMPLEMENT 1
    case ~= != neq
      value jne
      $VPRED 4
      $VPREDCOMPLEMENT 4
  pick T

# immediate scrambling config
# This sets up the scrambling system whereby the script-provided immediate values are scrabled in executable memory and
# unscrambled when accessed.
# 
subroutine scramble
  select-kw2
    case byte word
      code $SC
        mov $SC_DEST, $SC_RAND
        xor $SC_DEST, $SC_DIFF
    case dword
      code $SC
        mov $SC_DEST, $SC_RAND
        xor %[$SC_DEST]_32, $SC_DIFF
    case qword
      code $SC
        mov $SC_DEST, $SC_RAND
        mov rTEMPD, $SC_DIFF
        xor $SC_DEST, rTEMPD
        xor rTEMPD, rTEMPD
        # mov $SC_DEST, $SC_RAND_HIGH
        # xor %[$SC_DEST]_32, $SC_DIFF_HIGH
        # shl $SC_DEST, 32
        # xor %[$SC_DEST]_32, $SC_RAND_LOW
        # xor %[$SC_DEST]_32, $SC_DIFF_LOW

instruction exit
  $KW dword
  scramble rTEMPA $LD_IPTR_IMMEDIATE $COMMAND_INDEX
  code
    $LD_IPTR_IMMEDIATE
    mov fs:[context.instruction_index + random_const_FS], rTEMPA
    xor rTEMPA, rTEMPA
    mov fs:[context.status + random_const_FS], dword STATUS_HALT
    store_context
    rdfsbase rax
    add rax, random_const_FS
    load_runtimecontext rax
    mov r14, [rax + context.runtime_registers + 40]
    mov r15, [rax + context.runtime_registers + 48]
    mov rax, STATUS_HALT
    ret

instruction break
  $KW dword
  scramble rTEMPA $LD_IPTR_IMMEDIATE $COMMAND_INDEX_NEXT
  code
    $LD_IPTR_IMMEDIATE
    mov fs:[context.instruction_index + random_const_FS], rTEMPA
    xor rTEMPA, rTEMPA
    mov fs:[context.status + random_const_FS], dword STATUS_SUSPEND
    store_context
    rdfsbase rax
    add rax, random_const_FS
    load_runtimecontext rax
    mov r14, [rax + context.runtime_registers + 40]
    mov r15, [rax + context.runtime_registers + 48]
    mov rax, STATUS_SUSPEND
    ret

# Bind a memory block to an address register and update corresponding context entries
# NOTICE:  This instruction will need to be reviewed for spectre/meltdown mitigations 
#          (transfer of data from the memory block list to the address register & 
#          context fields is possibly sensitive).  
#          ((By design, all instructions may be preceded by any combination of gotos, 
#          conditional branches and by memory-indirect jumps via a read-only jump table 
#          containing all tactyk-pl provided instructions.  Register allocation is
#          global and programs are not permitted to make uncontrolled modifications to
#          anything but data reguisters and the data content of listed memory blocks.))

instruction bind
  operand
    type address
    $ADDRESS_REGISTER $VALUE
  operand
    type data memblock integer
    $SRC $VALUE
    $KWSRC $KW
    scramble rTEMPA $LD_SRC_IMMEDIATE
  select-template

    case AD
      code
        mov rTEMPA, $SRC
        
        cmp $SRC, 0
        errorlt STATUS_ROGUE_POINTER
        cmp rTEMPA, fs:[context.memblocks_count + random_const_FS]
        errorge STATUS_ROGUE_POINTER
        
        lfence
        
        imul rTEMPA, 24
        add rTEMPA, fs:[context.memblocks + random_const_FS]
        mov $ADDRESS_REGISTER, [rTEMPA]
        mov fs:[$CTX_ADDR + random_const_FS], $ADDRESS_REGISTER

        mov rTEMPC, [rTEMPA+8]
        mov rTEMPD, [rTEMPA+16]
        mov fs:[$CTX_ADDR+8 + random_const_FS], rTEMPC
        mov fs:[$CTX_ADDR+16 + random_const_FS], rTEMPD
        
        xor rTEMPA, rTEMPA
        xor rTEMPC, rTEMPC
        xor rTEMPD, rTEMPD
        jmp $NEXT_INSTRUCTION
    
    case AM AI
      code
        $LD_SRC_IMMEDIATE
        
        cmp rTEMPA, 0
        errorlt STATUS_ROGUE_POINTER
        cmp rTEMPA, fs:[context.memblocks_count + random_const_FS]
        errorge STATUS_ROGUE_POINTER
        
        lfence
        
        imul rTEMPA, 24
        add rTEMPA, fs:[context.memblocks + random_const_FS]
        mov $ADDRESS_REGISTER, [rTEMPA]
        mov fs:[$CTX_ADDR + random_const_FS], $ADDRESS_REGISTER
        
        mov rTEMPC, [rTEMPA+8]
        mov rTEMPD, [rTEMPA+16]
        mov fs:[$CTX_ADDR+8 + random_const_FS], rTEMPC
        mov fs:[$CTX_ADDR+16 + random_const_FS], rTEMPD
        
        xor rTEMPA, rTEMPA
        xor rTEMPC, rTEMPC
        xor rTEMPD, rTEMPD
        jmp $NEXT_INSTRUCTION
    
    # Memblock index bounds check is handled by the compiler, so this version probably would be valid.
    # However there also does not seem much point in having this variant, as memory block binding is not expected to be a frequent
    # operation outside of degenerate cases.  (If many objects need to be accessed, a large memory block holding an object pool should
    # be used)
    #
    # case AM 
    #  code
    #    $LD_SRC_IMMEDIATE
    #
    #    imul rTEMPA, 24
    #    add rTEMPA, fs:[context.memblocks + random_const_FS]
    #    mov $ADDRESS_REGISTER, [rTEMPA]
    #    mov fs:[$CTX_ADDR + random_const_FS], $ADDRESS_REGISTER
    #    
    #    mov rTEMPC, [rTEMPA+8]
    #    mov rTEMPD, [rTEMPA+16]
    #    mov fs:[$CTX_ADDR+8 + random_const_FS], rTEMPC
    #    mov fs:[$CTX_ADDR+16 + random_const_FS], rTEMPD
    #    
    #    xor rTEMPA, rTEMPA
    #    xor rTEMPC, rTEMPC
    #    xor rTEMPD, rTEMPD
    #    jmp $NEXT_INSTRUCTION

# Read a word from a memory block and write it to a register
# NOTICE:  This instruction will need to be reviewed for spectre/meltdown mitigations 
#          (transfer of data from the memory block list to the address register & 
#          context fields is possibly sensitive).  
#          ((By design, all instructions may be preceded by any combination of gotos, 
#          conditional branches and by memory-indirect jumps via a read-only jump table 
#          containing all tactyk-pl provided instructions.  Register allocation is
#          global and programs are not permitted to make uncontrolled modifications to
#          anything but data reguisters and the data content of listed memory blocks.))
instruction load
  operand
    type word
  operand
    type data xmmx
    $DEST__DATA_REG $VALUE
  operand
    type address
    $ADDRESS_REGISTER $VALUE
  operand
    type data const integer
    $OFFSET $VALUE
    scramble rTEMPC $LD_OFFSET_IMMEDIATE
  select-template
    case QDAD
      code
        mov rTEMPA_32, fs:[$CTX_ELEMENT_BOUND + random_const_FS]
        sub rTEMPA_32, 7
        cmp $OFFSET, rTEMPA
        errorge STATUS_ROGUE_POINTER
        cmp $OFFSET, 0
        errorlt STATUS_ROGUE_POINTER
        
        lfence
        
        mov $DEST__DATA_REG, [$ADDRESS_REGISTER+$OFFSET]
        xor rTEMPA, rTEMPA
        jmp $NEXT_INSTRUCTION
    case QDAI QDAC
      code
        $LD_OFFSET_IMMEDIATE
        
        mov rTEMPA_32, fs:[$CTX_ELEMENT_BOUND + random_const_FS]
        sub rTEMPA_32, 7
        cmp rTEMPC, rTEMPA
        errorge STATUS_ROGUE_POINTER
        cmp rTEMPC, 0
        errorlt STATUS_ROGUE_POINTER
        
        lfence
        
        mov $DEST__DATA_REG, [$ADDRESS_REGISTER+rTEMPC]
        xor rTEMPA, rTEMPA
        xor rTEMPC, rTEMPC
        jmp $NEXT_INSTRUCTION
    case DDAD
      code
        mov rTEMPA_32, fs:[$CTX_ELEMENT_BOUND + random_const_FS]
        sub rTEMPA_32, 3
        cmp $OFFSET, rTEMPA
        errorge STATUS_ROGUE_POINTER
        cmp $OFFSET, 0
        errorlt STATUS_ROGUE_POINTER
        
        mov %[$DEST__DATA_REG]_32, dword [$ADDRESS_REGISTER+$OFFSET]
        xor rTEMPA, rTEMPA
        jmp $NEXT_INSTRUCTION
    case DDAI DDAC
      code
        $LD_OFFSET_IMMEDIATE
        
        mov rTEMPA_32, fs:[$CTX_ELEMENT_BOUND + random_const_FS]
        sub rTEMPA_32, 3
        cmp rTEMPC, rTEMPA
        errorge STATUS_ROGUE_POINTER
        cmp rTEMPC, 0
        errorlt STATUS_ROGUE_POINTER
        
        lfence
        
        mov %[$DEST__DATA_REG]_32, dword [$ADDRESS_REGISTER+rTEMPC]
        xor rTEMPA, rTEMPA
        xor rTEMPC, rTEMPC
        jmp $NEXT_INSTRUCTION
    case WDAD
      code
        mov rTEMPA_32, fs:[$CTX_ELEMENT_BOUND + random_const_FS]
        dec rTEMPA_32
        cmp $OFFSET, rTEMPA
        errorge STATUS_ROGUE_POINTER
        cmp $OFFSET, 0
        errorlt STATUS_ROGUE_POINTER
        
        lfence
        
        movzx $DEST__DATA_REG, word [$ADDRESS_REGISTER+$OFFSET]
        xor rTEMPA, rTEMPA
        jmp $NEXT_INSTRUCTION
    case WDAI WDAC
      code
        $LD_OFFSET_IMMEDIATE

        mov rTEMPA_32, fs:[$CTX_ELEMENT_BOUND + random_const_FS]
        dec rTEMPA_32
        cmp rTEMPC, rTEMPA
        errorge STATUS_ROGUE_POINTER
        cmp rTEMPC, 0
        errorlt STATUS_ROGUE_POINTER
        
        lfence
        
        movzx $DEST__DATA_REG, word [$ADDRESS_REGISTER+rTEMPC]
        xor rTEMPA, rTEMPA
        xor rTEMPC, rTEMPC
        jmp $NEXT_INSTRUCTION
    case BDAD
      code
        mov rTEMPA_32, fs:[$CTX_ELEMENT_BOUND + random_const_FS]
        cmp $OFFSET, rTEMPA
        errorge STATUS_ROGUE_POINTER
        cmp $OFFSET, 0
        errorlt STATUS_ROGUE_POINTER
        
        lfence
        
        movzx $DEST__DATA_REG, byte [$ADDRESS_REGISTER+$OFFSET]
        xor rTEMPA, rTEMPA
        jmp $NEXT_INSTRUCTION
    case BDAI BDAC
      code
        $LD_OFFSET_IMMEDIATE
        
        mov rTEMPA_32, fs:[$CTX_ELEMENT_BOUND + random_const_FS]
        cmp rTEMPC, rTEMPA
        errorge STATUS_ROGUE_POINTER
        cmp rTEMPC, 0
        errorlt STATUS_ROGUE_POINTER
        
        lfence
        
        movzx $DEST__DATA_REG, byte [$ADDRESS_REGISTER+rTEMPC]
        xor rTEMPA, rTEMPA
        xor rTEMPC, rTEMPC
        jmp $NEXT_INSTRUCTION
    
    case XXAD
      code
        mov rTEMPA_32, fs:[$CTX_ELEMENT_BOUND + random_const_FS]
        sub rTEMPA_32, 7
        cmp $OFFSET, rTEMPA
        errorge STATUS_ROGUE_POINTER
        cmp $OFFSET, 0
        errorlt STATUS_ROGUE_POINTER
        
        lfence
        
        movq $DEST__DATA_REG, [$ADDRESS_REGISTER+$OFFSET]
        xor rTEMPA, rTEMPA
        jmp $NEXT_INSTRUCTION
    case XXAI XXAC
      code
        $LD_OFFSET_IMMEDIATE
        
        mov rTEMPA_32, fs:[$CTX_ELEMENT_BOUND + random_const_FS]
        sub rTEMPA_32, 7
        cmp rTEMPC, rTEMPA
        errorge STATUS_ROGUE_POINTER
        cmp rTEMPC, 0
        errorlt STATUS_ROGUE_POINTER
        
        lfence
        
        movq $DEST__DATA_REG, [$ADDRESS_REGISTER+rTEMPC]
        xor rTEMPA, rTEMPA
        xor rTEMPC, rTEMPC
        jmp $NEXT_INSTRUCTION
    case XDAD
      code
        mov rTEMPA_32, fs:[$CTX_ELEMENT_BOUND + random_const_FS]
        sub rTEMPA_32, 7
        cmp $OFFSET, rTEMPA
        errorge STATUS_ROGUE_POINTER
        cmp $OFFSET, 0
        errorlt STATUS_ROGUE_POINTER
        
        lfence
        
        movq xTEMPA, [$ADDRESS_REGISTER+$OFFSET]
        cvttsd2si $DEST__DATA_REG, xTEMPA
        
        xor rTEMPA, rTEMPA
        pxor xTEMPA, xTEMPA
        jmp $NEXT_INSTRUCTION

    case XDAI XDAC
      code
        $LD_OFFSET_IMMEDIATE
        
        mov rTEMPA_32, fs:[$CTX_ELEMENT_BOUND + random_const_FS]
        sub rTEMPA_32, 7
        cmp rTEMPC, rTEMPA
        errorge STATUS_ROGUE_POINTER
        cmp rTEMPC, 0
        errorlt STATUS_ROGUE_POINTER
        
        lfence
        
        movq xTEMPA, [$ADDRESS_REGISTER+rTEMPC]
        cvttsd2si $DEST__DATA_REG, xTEMPA

        xor rTEMPA, rTEMPA
        xor rTEMPC, rTEMPC
        pxor xTEMPA, xTEMPA
        jmp $NEXT_INSTRUCTION

instruction store
  operand
    type word
  operand
    type address
    $ADDRESS_REGISTER $VALUE
  operand
    type data const integer
    $OFFSET $VALUE
    scramble rTEMPC $LD_OFFSET_IMMEDIATE
  operand
    type data xmmx
    $SRC $VALUE
    scramble rTEMPA $LD_SRC_IMMEDIATE
  select-template
    case QADD
      code
        mov rTEMPA_32, fs:[$CTX_ELEMENT_BOUND + random_const_FS]
        sub rTEMPA_32, 7
        cmp $OFFSET, rTEMPA
        errorge STATUS_ROGUE_POINTER
        cmp $OFFSET, 0
        errorlt STATUS_ROGUE_POINTER
        lfence
        mov [$ADDRESS_REGISTER+$OFFSET], $SRC
        xor rTEMPA, rTEMPA
        jmp $NEXT_INSTRUCTION
    case QAID QACD
      code
        $LD_OFFSET_IMMEDIATE
        mov rTEMPA_32, fs:[$CTX_ELEMENT_BOUND + random_const_FS]
        sub rTEMPA_32, 7
        cmp rTEMPC, rTEMPA
        errorge STATUS_ROGUE_POINTER
        cmp rTEMPC, 0
        errorlt STATUS_ROGUE_POINTER
        lfence
        mov [$ADDRESS_REGISTER+rTEMPC], $SRC
        xor rTEMPA, rTEMPA
        xor rTEMPC, rTEMPC
        jmp $NEXT_INSTRUCTION
    
    case DADD
      code
        mov rTEMPA_32, fs:[$CTX_ELEMENT_BOUND + random_const_FS]
        sub rTEMPA_32, 3
        cmp $OFFSET, rTEMPA
        errorge STATUS_ROGUE_POINTER
        cmp $OFFSET, 0
        errorlt STATUS_ROGUE_POINTER
        lfence
        mov dword [$ADDRESS_REGISTER+$OFFSET], %[$SRC]_32
        xor rTEMPA, rTEMPA
        jmp $NEXT_INSTRUCTION
    case DAID DACD
      code
        $LD_OFFSET_IMMEDIATE
        mov rTEMPA_32, fs:[$CTX_ELEMENT_BOUND + random_const_FS]
        sub rTEMPA_32, 3
        cmp rTEMPC, rTEMPA
        errorge STATUS_ROGUE_POINTER
        cmp rTEMPC, 0
        errorlt STATUS_ROGUE_POINTER
        lfence
        mov dword [$ADDRESS_REGISTER+rTEMPC], %[$SRC]_32
        xor rTEMPA, rTEMPA
        xor rTEMPC, rTEMPC
        jmp $NEXT_INSTRUCTION
    
    case WADD
      code
        mov rTEMPA_32, fs:[$CTX_ELEMENT_BOUND + random_const_FS]
        dec rTEMPA_32
        cmp $OFFSET, rTEMPA
        errorge STATUS_ROGUE_POINTER
        cmp $OFFSET, 0
        errorlt STATUS_ROGUE_POINTER
        lfence
        mov word [$ADDRESS_REGISTER+$OFFSET], %[$SRC]_16
        xor rTEMPA, rTEMPA
        jmp $NEXT_INSTRUCTION
    case WAID WACD
      code
        $LD_OFFSET_IMMEDIATE
        mov rTEMPA_32, fs:[$CTX_ELEMENT_BOUND + random_const_FS]
        dec rTEMPA_32
        cmp rTEMPC, rTEMPA
        errorge STATUS_ROGUE_POINTER
        cmp rTEMPC, 0
        errorlt STATUS_ROGUE_POINTER
        lfence
        mov word [$ADDRESS_REGISTER+rTEMPC], %[$SRC]_16
        xor rTEMPA, rTEMPA
        xor rTEMPC, rTEMPC
        jmp $NEXT_INSTRUCTION
    
    case BADD
      code
        mov rTEMPA_32, fs:[$CTX_ELEMENT_BOUND + random_const_FS]
        cmp $OFFSET, rTEMPA
        errorge STATUS_ROGUE_POINTER
        cmp $OFFSET, 0
        errorlt STATUS_ROGUE_POINTER
        lfence
        mov byte [$ADDRESS_REGISTER+$OFFSET], %[$SRC]_8
        xor rTEMPA, rTEMPA
        jmp $NEXT_INSTRUCTION
    case BAID BACD
      code
        $LD_OFFSET_IMMEDIATE
        mov rTEMPA_32, fs:[$CTX_ELEMENT_BOUND + random_const_FS]
        cmp rTEMPC, rTEMPA
        errorge STATUS_ROGUE_POINTER
        cmp rTEMPC, 0
        errorlt STATUS_ROGUE_POINTER
        lfence
        mov byte [$ADDRESS_REGISTER+rTEMPC], %[$SRC]_8
        xor rTEMPA, rTEMPA
        xor rTEMPC, rTEMPC
        jmp $NEXT_INSTRUCTION
    
    case XADX
      code
        mov rTEMPA_32, fs:[$CTX_ELEMENT_BOUND + random_const_FS]
        sub rTEMPA_32, 7
        cmp $OFFSET, rTEMPA
        errorge STATUS_ROGUE_POINTER
        cmp $OFFSET, 0
        errorlt STATUS_ROGUE_POINTER
        lfence
        movq [$ADDRESS_REGISTER+$OFFSET], $SRC
        xor rTEMPA, rTEMPA
        jmp $NEXT_INSTRUCTION
    case XAIX XACX
      code
        $LD_OFFSET_IMMEDIATE
        mov rTEMPA_32, fs:[$CTX_ELEMENT_BOUND + random_const_FS]
        sub rTEMPA_32, 7
        cmp rTEMPC, rTEMPA
        errorge STATUS_ROGUE_POINTER
        cmp rTEMPC, 0
        errorlt STATUS_ROGUE_POINTER
        lfence
        movq [$ADDRESS_REGISTER+rTEMPC], $SRC
        xor rTEMPA, rTEMPA
        xor rTEMPC, rTEMPC
        jmp $NEXT_INSTRUCTION

instruction pop
  operand
    type data
    $DEST__DATA_REG $VALUE
  operand
    type address
    $ADDRESS_REGISTER $VALUE
  code
    mov rTEMPA, $ADDRESS_REGISTER
    sub rTEMPA, 8
    cmp rTEMPA, fs:[$CTX_ADDR + random_const_FS]
    errorlt STATUS_MEMORY_UNDERFLOW
    lfence
    sub $ADDRESS_REGISTER, 8
    mov $DEST__DATA_REG, [$ADDRESS_REGISTER]
    xor rTEMPA, rTEMPA
    jmp $NEXT_INSTRUCTION

instruction push
  operand
    type address
    $ADDRESS_REGISTER $VALUE
  operand
    type data integer const
    $SRC__DATA_REGISTER $VALUE
    scramble rTEMPC $LD_SRC_IMMEDIATE
  select-template
    case AD
      code
        mov rTEMPA, $ADDRESS_REGISTER
        sub rTEMPA, fs:[$CTX_ADDR + random_const_FS]
        add rTEMPA, 8
        cmp rTEMPA, fs:[$CTX_ARRAY_BOUND + random_const_FS]
        errorge STATUS_MEMORY_OVERFLOW
        mov [$ADDRESS_REGISTER], $SRC__DATA_REGISTER
        add $ADDRESS_REGISTER, 8
        xor rTEMPA, rTEMPA
        jmp $NEXT_INSTRUCTION
    case AI AC
      code
        $LD_SRC_IMMEDIATE
        mov rTEMPA, $ADDRESS_REGISTER
        sub rTEMPA, fs:[$CTX_ADDR + random_const_FS]
        add rTEMPA, 8
        cmp rTEMPA, fs:[$CTX_ARRAY_BOUND + random_const_FS]
        errorge STATUS_MEMORY_OVERFLOW
        mov [$ADDRESS_REGISTER], rTEMPC
        add $ADDRESS_REGISTER, 8
        xor rTEMPA, rTEMPA
        jmp $NEXT_INSTRUCTION
        

instruction swap
  operand 
    type data xmmx
    $A $VALUE
  operand
    type data xmmx
    $B $VALUE
  select-template
    case DD
      code
        xchg $A, $B
        jmp $NEXT_INSTRUCTION
    case XD
      code
        cvtsi2sd xTEMPB, $B
        cvttsd2si $B, $A
        movq $A, xTEMPB
        pxor xTEMPB, xTEMPB
        jmp $NEXT_INSTRUCTION
    case DX
      code
        cvtsi2sd xTEMPA, $A
        cvttsd2si $A, $B
        movq $B, xTEMPA
        pxor xTEMPA, xTEMPA
        jmp $NEXT_INSTRUCTION
    case XX
      code
        movq xTEMPA, $A
        movq $A, $B
        movq $B, xTEMPA
        pxor xTEMPA, xTEMPA
        jmp $NEXT_INSTRUCTION

subroutine simple_unary_instruction
  operand 
    type data
    $A $VALUE
  code
    $INSTRUCTION $A
    jmp $NEXT_INSTRUCTION

subroutine simple_binary_instruction
  operand 
    type data
    $A $VALUE
  operand
    type data const integer
    $B $VALUE
    scramble rTEMPA $LD_B_IMMEDIATE
  select-template
    case DD
      code 
        $INSTRUCTION $A, $B
        jmp $NEXT_INSTRUCTION
    case DI DC
      code 
        $LD_B_IMMEDIATE
        $INSTRUCTION $A, rTEMPA
        xor rTEMPA, rTEMPA
        jmp $NEXT_INSTRUCTION

subroutine binary_instruction
  operand
    type data xmmx
    $A $VALUE
  operand
    type data xmmx const fconst integer float
    $B $VALUE
    scramble rTEMPC $LD_B_IMMEDIATE
  select-template
    case DD
      code
        $INSTRUCTION $A, $B
        jmp $NEXT_INSTRUCTION
    case DI DC
      code
        $LD_B_IMMEDIATE
        $INSTRUCTION $A, rTEMPC
        xor rTEMPC, rTEMPC
        jmp $NEXT_INSTRUCTION
    case DX
      code
        cvtsi2sd xTEMPA, $A
        %[$INSTRUCTION]sd xTEMPA, $B
        cvttsd2si $A, xTEMPA
        pxor xTEMPA, xTEMPA
        jmp $NEXT_INSTRUCTION
    case DF DCf
      code
        $LD_B_IMMEDIATE
        movq xTEMPB, rTEMPC
        cvtsi2sd xTEMPA, $A
        %[$INSTRUCTION]sd xTEMPA, xTEMPB
        cvttsd2si $A, xTEMPA
        xor rTEMPC, rTEMPC
        pxor xTEMPA, xTEMPA
        pxor xTEMPB, xTEMPB
        jmp $NEXT_INSTRUCTION
    case XX
      code
        %[$INSTRUCTION]sd $A, $B
        jmp $NEXT_INSTRUCTION
    case XD
      code
        cvtsi2sd xTEMPA, $B
        %[$INSTRUCTION]sd $A, xTEMPA
        pxor xTEMPA, xTEMPA
        jmp $NEXT_INSTRUCTION
    case XI XC
      code
        $LD_B_IMMEDIATE
        cvtsi2sd xTEMPA, rTEMPC
        %[$INSTRUCTION]sd $A, xTEMPA
        xor rTEMPC, rTEMPC
        pxor xTEMPA, xTEMPA
        jmp $NEXT_INSTRUCTION
    case XCf XF
      code
        $LD_B_IMMEDIATE
        movq xTEMPA, rTEMPC
        %[$INSTRUCTION]sd $A, xTEMPA
        xor rTEMPC, rTEMPC
        pxor xTEMPA, xTEMPA
        jmp $NEXT_INSTRUCTION

instruction add
  $INSTRUCTION add
  sub binary_instruction

instruction sub
  $INSTRUCTION sub
  sub binary_instruction

instruction and
  $INSTRUCTION and
  sub simple_binary_instruction

instruction or
  $INSTRUCTION or
  sub simple_binary_instruction

instruction xor
  $INSTRUCTION xor
  sub simple_binary_instruction


typespec address-offset
  select-operand
    case addr1.offset
      $ADDRESS_REGISTER rADDR1
      $CTX_ADDRESS context.addr1
      $CTX_ADDRESS_BOUND context.addr1_array_bound
    case addr2.offset
      $ADDRESS_REGISTER rADDR2
      $CTX_ADDRESS context.addr2
      $CTX_ADDRESS_BOUND context.addr2_array_bound
    case addr3.offset
      $ADDRESS_REGISTER rADDR3
      $CTX_ADDRESS context.addr3
      $CTX_ADDRESS_BOUND context.addr3_array_bound
    case addr4.offset
      $ADDRESS_REGISTER rADDR4
      $CTX_ADDRESS context.addr4
      $CTX_ADDRESS_BOUND context.addr4_array_bound
  pick O

instruction assign
  operand 
    type data xmmx address-offset
    $A $VALUE
  operand
    type data xmmx stackreg const fconst address-offset context-property integer float string
    $B $VALUE
    scramble rTEMPA $LD_B_IMMEDIATE
    scramble rTEMPC $LD_B_HIGHBITS_IMMEDIATE $VALUE_UPPER
  select-template
    case OD
      code
        cmp $B, fs:[$CTX_ADDRESS_BOUND + random_const_FS]
        errorge STATUS_ROGUE_POINTER
        cmp $B, 0
        errorlt STATUS_ROGUE_POINTER
        lfence
        mov $ADDRESS_REGISTER, $B
        add $ADDRESS_REGISTER, fs:[$CTX_ADDRESS + random_const_FS]
        jmp $NEXT_INSTRUCTION
    case OI OC
      code
        $LD_B_IMMEDIATE
        cmp rTEMPA, fs:[$CTX_ADDRESS_BOUND + random_const_FS]
        errorge STATUS_ROGUE_POINTER
        cmp rTEMPA, 0
        errorlt STATUS_ROGUE_POINTER
        lfence
        mov $ADDRESS_REGISTER, rTEMPA
        add $ADDRESS_REGISTER, fs:[$CTX_ADDRESS + random_const_FS]
        xor rTEMPA, rTEMPA
        jmp $NEXT_INSTRUCTION
    case DO
      code
        mov $A, $ADDRESS_REGISTER
        sub $A, fs:[$CTX_ADDRESS + random_const_FS]
        jmp $NEXT_INSTRUCTION
    case DD
      code 
        mov $A, $B
        jmp $NEXT_INSTRUCTION
    case DSreg
      code
        mov %[$A]_16, %[$B]_16
        sub %[$A]_16, word fs:[$STACK_FLOOR + random_const_FS]
        jmp $NEXT_INSTRUCTION
    case DI DC DS
      code 
        $LD_B_IMMEDIATE
        mov $A, rTEMPA
        xor rTEMPA, rTEMPA
        jmp $NEXT_INSTRUCTION
    case DCtx
      select-kw
        case dword
          code
            mov %[$A]_32, fs:[$B + random_const_FS]
            jmp $NEXT_INSTRUCTION
    case DX
      code
        cvttsd2si $A, $B
        jmp $NEXT_INSTRUCTION
    case DF DCf
      code
        $LD_B_IMMEDIATE
        movq xTEMPA, rTEMPA
        cvttsd2si $A, xTEMPA
        xor rTEMPA, rTEMPA
        pxor xTEMPA, xTEMPA
        jmp $NEXT_INSTRUCTION
    case XX
      code
        movq $A, $B
        jmp $NEXT_INSTRUCTION
    case XD
      code
        cvtsi2sd $A, $B
        jmp $NEXT_INSTRUCTION
    case XI XC
      code
        $LD_B_IMMEDIATE
        cvtsi2sd $A, rTEMPA
        xor rTEMPA, rTEMPA
        jmp $NEXT_INSTRUCTION
    case XS
      code
        $LD_B_IMMEDIATE
        $LD_B_HIGHBITS_IMMEDIATE
        movq $A, rTEMPA
        pinsrq $A, rTEMPC, 3
        xor rTEMPA, rTEMPA
        xor rTEMPC, rTEMPC
        jmp $NEXT_INSTRUCTION
    case XF XCf
      code
        $LD_B_IMMEDIATE
        movq $A, rTEMPA
        xor rTEMPA, rTEMPA
        jmp $NEXT_INSTRUCTION
      

instruction mul
  operand
    type data xmmx
    $A $VALUE
  operand
    type data xmmx const fconst integer float
    $B $VALUE
    scramble rTEMPC $LD_B_IMMEDIATE
  select-template
    case DD
      code
        mov rTEMPA, $A
        imul $B
        mov $A, rTEMPA
        xor rTEMPA, rTEMPA
        jmp $NEXT_INSTRUCTION
    case DI DC
      code
        $LD_B_IMMEDIATE
        mov rTEMPA, $A
        imul rTEMPC
        mov $A, rTEMPA
        xor rTEMPA, rTEMPA
        xor rTEMPC, rTEMPC
        jmp $NEXT_INSTRUCTION
    case DX
      code
        cvtsi2sd xTEMPA, $A
        mulsd xTEMPA, $B
        cvttsd2si $A, xTEMPA
        pxor xTEMPA, xTEMPA
        jmp $NEXT_INSTRUCTION
    case DF DCf
      code
        $LD_B_IMMEDIATE
        movq xTEMPB, rTEMPC
        cvtsi2sd xTEMPA, $A
        mulsd xTEMPA, xTEMPB
        cvttsd2si $A, xTEMPA
        pxor xTEMPA, xTEMPA
        pxor xTEMPB, xTEMPB
        xor rTEMPC, rTEMPC
        jmp $NEXT_INSTRUCTION
    case XX
      code
        mulsd $A, $B
        jmp $NEXT_INSTRUCTION
    case XD
      code
        cvtsi2sd xTEMPA, $B
        mulsd $A, xTEMPA
        pxor xTEMPA, xTEMPA
        jmp $NEXT_INSTRUCTION
    case XI XC
      code
        $LD_B_IMMEDIATE
        cvtsi2sd xTEMPA, rTEMPC
        mulsd $A, xTEMPA
        xor rTEMPC, rTEMPC
        pxor xTEMPA, xTEMPA
        jmp $NEXT_INSTRUCTION
    case XCf XF
      code
        $LD_B_IMMEDIATE
        movq xTEMPA, rTEMPC
        mulsd $A, xTEMPA
        xor rTEMPA, rTEMPA
        pxor xTEMPA, xTEMPA
        jmp $NEXT_INSTRUCTION

instruction div
  operand
    type data xmmx
    $A $VALUE
  operand
    type data xmmx const fconst integer float
    $B $VALUE
    scramble rTEMPC $LD_B_IMMEDIATE
  operand
    type branch none
    $DIVZ_TARGET $VALUE
  select-template
    case DDN
      code
        cmp $B, 0
        erroreq STATUS_DIVISION_BY_ZERO
        mov rTEMPA, $A
        cqo
        idiv $B
        mov $A, rTEMPA
        xor rTEMPA, rTEMPA
        xor rTEMPD, rTEMPD
        jmp $NEXT_INSTRUCTION
    case DIN DCN
      code
        $LD_B_IMMEDIATE
        cmp rTEMPC, 0
        erroreq STATUS_DIVISION_BY_ZERO
        mov rTEMPA, $A
        cqo
        idiv rTEMPC
        mov $A, rTEMPA
        xor rTEMPA, rTEMPA
        xor rTEMPC, rTEMPC
        xor rTEMPD, rTEMPD
        jmp $NEXT_INSTRUCTION
    case DDL
      code
        cmp $B, 0
        je $DIVZ_TARGET
        mov rTEMPA, $A
        cqo
        idiv $B
        mov $A, rTEMPA
        xor rTEMPA, rTEMPA
        xor rTEMPD, rTEMPD
        jmp $NEXT_INSTRUCTION
    case DIL DCL
      code
        $LD_B_IMMEDIATE
        cmp rTEMPC, 0
        je $DIVZ_TARGET
        mov rTEMPA, $A
        cqo
        idiv rTEMPC
        mov $A, rTEMPA
        xor rTEMPA, rTEMPA
        xor rTEMPC, rTEMPC
        xor rTEMPD, rTEMPD
        jmp $NEXT_INSTRUCTION
    case DXN
      code
        cvtsi2sd xTEMPA, $A
        divsd xTEMPA, $B
        cvttsd2si $A, xTEMPA
        pxor xTEMPA, xTEMPA
        jmp $NEXT_INSTRUCTION
    case DFN DCfN
      code
        $LD_B_IMMEDIATE
        movq xTEMPB, rTEMPC
        cvtsi2sd xTEMPA, $A
        divsd xTEMPA, xTEMPB
        cvttsd2si $A, xTEMPA
        xor rTEMPA, rTEMPA
        pxor xTEMPA, xTEMPA
        pxor xTEMPB, xTEMPB
        xor rTEMPC, rTEMPC
        jmp $NEXT_INSTRUCTION
    case XXN
      code
        divsd $A, $B
        jmp $NEXT_INSTRUCTION
    case XDN
      code
        cvtsi2sd xTEMPA, $B
        divsd $A, xTEMPA
        pxor xTEMPA, xTEMPA
        jmp $NEXT_INSTRUCTION
    case XIN XCN
      code
        $LD_B_IMMEDIATE
        cvtsi2sd xTEMPA, rTEMPC
        divsd $A, xTEMPA
        xor rTEMPA, rTEMPA
        pxor xTEMPA, xTEMPA
        jmp $NEXT_INSTRUCTION
    case XCfN XFN
      code
        $LD_B_IMMEDIATE
        movq xTEMPA, rTEMPC
        divsd $A, xTEMPA
        xor rTEMPA, rTEMPA
        pxor xTEMPA, xTEMPA
        jmp $NEXT_INSTRUCTION

subroutine shift
  operand 
    type data
    $A $VALUE
  operand
    type data integer const
    $B $VALUE
    scramble rTEMPC $LD_B_IMMEDIATE
  select-template
    case DD
      code 
        mov rcx, $B
        $INSTRUCTION $A, cl
        xor rcx, rcx
        jmp $NEXT_INSTRUCTION
    case DI DC
      code 
        $LD_B_IMMEDIATE
        $INSTRUCTION $A, cl
        xor rTEMPC, rTEMPC
        jmp $NEXT_INSTRUCTION

instruction shift-left
  $INSTRUCTION shl
  sub shift

instruction shift-right
  $INSTRUCTION shr
  sub shift

instruction rotate-left
  $INSTRUCTION rol
  sub shift

instruction rotate-right
  $INSTRUCTION ror
  sub shift

instruction inc
  $INSTRUCTION inc
  sub simple_unary_instruction

instruction dec
  $INSTRUCTION dec
  sub simple_unary_instruction

instruction not
  $INSTRUCTION not
  sub simple_unary_instruction

instruction negate
  $INSTRUCTION neg
  sub simple_unary_instruction

instruction goto
  operand
    type branch
    $JTARGET $VALUE
  select-template
    case L
      code
        jmp $JTARGET

instruction tcall
  operand
    type tapi
    $A $VALUE
  code
    store_context    
    
    ; align the data registers with the unix call
    ; rdfsbase rdi
    ; add rdi, random_const_FS
    mov rsi, rB
    mov rdx, rC
    mov rcx, rD
    ;rE, rF are aligned

    rdfsbase r14
    add r14, random_const_FS
    mov rdi, r14
    load_runtimecontext r14
    
    xor rax, rax
    xor r10, r10
    xor r11, r11
    
    push rbp
    mov r10, $A
    call r10
    
    pop rbp
    validate_context_pointer r14
    sub r14, random_const_FS
    load_context r14
    
    xor rTEMPA, rTEMPA
    xor rTEMPC, rTEMPC
    xor rTEMPD, rTEMPD
    
    jmp $NEXT_INSTRUCTION
    

instruction ccall
  operand
    type data capi
    $A $VALUE
  operand
    type capi none
    $B $VALUE
  select-template
    case CfuncN
      code
        store_context
        
        ; align the data registers with the unix call
        mov rdi, rA
        mov rsi, rB
        mov rdx, rC
        mov rcx, rD
        ;rE, rF are already aligned
        
        rdfsbase r14
        add r14, random_const_FS
        load_runtimecontext r14
        
        push rbp
        mov r10, $A
        call r10
        
        pop rbp
        
        validate_context_pointer r14
        sub r14, random_const_FS
        
        load_context r14
        
        xor rTEMPA, rTEMPA
        xor rTEMPC, rTEMPC
        xor rTEMPD, rTEMPD
        
        jmp $NEXT_INSTRUCTION
    case DCfunc
      code
        store_context
        
        ; align the data registers with the unix call
        mov rdi, rA
        mov rsi, rB
        mov rdx, rC
        mov rcx, rD
        ;rE, rF are already aligned
        
        rdfsbase r14
        add r14, random_const_FS
        load_runtimecontext r14
        
        push rbp
        mov r10, $B
        call r10
        
        pop rbp
        mov rTEMPD, rTEMPA
        
        validate_context_pointer r14
        sub r14, random_const_FS
        
        load_context r14
        
        mov $A, rTEMPD
        
        xor rTEMPA, rTEMPA
        xor rTEMPC, rTEMPC
        xor rTEMPD, rTEMPD
        
        jmp $NEXT_INSTRUCTION
    case CfuncCfunc DN
      error

instruction if
  opt-operand
    type vec-float-format
  operand
    type xmmx data integer const fconst float
    $A $VALUE
    scramble rTEMPA $LD_IMMEDIATE_A
  operand
    type comparator
    $CJUMP $VALUE
  operand
    type xmmx data integer const fconst float
    $B $VALUE
    scramble rTEMPC $LD_IMMEDIATE_B
  operand
    type branch
    $JTARGET $VALUE
  select-template
    case DTDL
      code
        cmp $A, $B
        $CJUMP .pass
        jmp $NEXT_INSTRUCTION
        .pass:
        jmp $JTARGET
    case DTIL DTCL
      code
        $LD_IMMEDIATE_B
        cmp $A, rTEMPC
        $CJUMP .pass
        xor rTEMPC, rTEMPC
        jmp $NEXT_INSTRUCTION
        .pass:
        xor rTEMPC, rTEMPC
        jmp $JTARGET
    case ITDL CTDL
      code
        $LD_IMMEDIATE_A
        cmp rTEMPA, $B
        $CJUMP .pass
        xor rTEMPA, rTEMPA
        jmp $NEXT_INSTRUCTION
        .pass:
        xor rTEMPA, rTEMPA
        jmp $JTARGET
    
    # comparison with floats on xmmx registers
    #  For packed floats, these all pass if any comparisons pass
    #  These should work as expected for comparisons involving Individual floats
    #   (for more fine-grained controls, you'll probably have to unpack and compare them individualls
    #    It might be worthwhile to add a function which simply compares xmmx values and only extracts the
    #    result)
    # Comparisons of xmmx register with data register assumes that the xmmx register is a float and the data register
    # is an integer
    # Floating point comparisons wherein neither operand is stored on an xmmx register are unspported
    case XTXL
      code
        mov$VECFMT xTEMPA, $A
        cmp$VECFMT xTEMPA, $B, $VPRED
        movq rTEMPA, xTEMPA
        cmp rTEMPA, 0
        jne .pass
        xor rTEMPA, rTEMPA
        pxor xTEMPA, xTEMPA
        jmp $NEXT_INSTRUCTION
        .pass:
        xor rTEMPA, rTEMPA
        pxor xTEMPA, xTEMPA
        jmp $JTARGET
    case DTXL
      code
        cvtsi2$VECFMT xTEMPA, $A
        cmp$VECFMT xTEMPA, $B, $VPRED
        movq rTEMPA, xTEMPA
        cmp rTEMPA, 0
        jne .pass
        xor rTEMPA, rTEMPA
        pxor xTEMPA, xTEMPA
        jmp $NEXT_INSTRUCTION
        .pass:
        xor rTEMPA, rTEMPA
        pxor xTEMPA, xTEMPA
        jmp $JTARGET
    case FTXL CfTXL
      code
        $LD_IMMEDIATE_A
        movq xTEMPA, rTEMPA
        cmp$VECFMT xTEMPA, $B, $VPRED
        movq rTEMPA, xTEMPA
        cmp rTEMPA, 0
        jne .pass
        xor rTEMPA, rTEMPA
        pxor xTEMPA, xTEMPA
        jmp $NEXT_INSTRUCTION
        .pass:
        xor rTEMPA, rTEMPA
        pxor xTEMPA, xTEMPA
        jmp $JTARGET
    case ITXL CTXL
      code
        $LD_IMMEDIATE_A
        cvtsi2$VECFMT xTEMPA, rTEMPA
        cmp$VECFMT xTEMPA, $B, $VPRED
        movq rTEMPA, xTEMPA
        cmp rTEMPA, 0
        jne .pass
        xor rTEMPA, rTEMPA
        pxor xTEMPA, xTEMPA
        jmp $NEXT_INSTRUCTION
        .pass:
        xor rTEMPA, rTEMPA
        pxor xTEMPA, xTEMPA
        jmp $JTARGET
    case XTDL
      code
        cvtsi2$VECFMT xTEMPA, $B
        cmp$VECFMT xTEMPA, $A, $VPREDCOMPLEMENT
        movq rTEMPA, xTEMPA
        cmp rTEMPA, 0
        jne .pass
        xor rTEMPA, rTEMPA
        pxor xTEMPA, xTEMPA
        jmp $NEXT_INSTRUCTION
        .pass:
        xor rTEMPA, rTEMPA
        pxor xTEMPA, xTEMPA
        jmp $JTARGET
    case XTFL XTCfL
      code
        $LD_IMMEDIATE_B
        movq xTEMPA, rTEMPC
        cmp$VECFMT xTEMPA, $A, $VPREDCOMPLEMENT
        movq rTEMPA, xTEMPA
        cmp rTEMPA, 0
        jne .pass
        xor rTEMPA, rTEMPA
        xor rTEMPC, rTEMPC
        pxor xTEMPA, xTEMPA
        jmp $NEXT_INSTRUCTION
        .pass:
        xor rTEMPA, rTEMPA
        xor rTEMPC, rTEMPC
        pxor xTEMPA, xTEMPA
        jmp $JTARGET
    case XTIL XTCL
      code
        $LD_IMMEDIATE_B
        cvtsi2$VECFMT xTEMPA, rTEMPC
        cmp$VECFMT xTEMPA, $A, $VPREDCOMPLEMENT
        movq rTEMPA, xTEMPA
        cmp rTEMPA, 0
        jne .pass
        xor rTEMPA, rTEMPA
        xor rTEMPC, rTEMPC
        pxor xTEMPA, xTEMPA
        jmp $NEXT_INSTRUCTION
        .pass:
        xor rTEMPA, rTEMPA
        xor rTEMPC, rTEMPC
        pxor xTEMPA, xTEMPA
        jmp $JTARGET
    
    case DTFL DTCfL
      code
        $LD_IMMEDIATE_B
        cvtsi2$VECFMT xTEMPA, $A
        movq xTEMPB, rTEMPC
        movq rTEMPA, xTEMPA
        cmp rTEMPA, 0
        jne .pass
        xor rTEMPA, rTEMPA
        xor rTEMPC, rTEMPC
        pxor xTEMPA, xTEMPA
        pxor xTEMPB, xTEMPB
        jmp $NEXT_INSTRUCTION
        .pass:
        xor rTEMPA, rTEMPA
        xor rTEMPC, rTEMPC
        pxor xTEMPA, xTEMPA
        pxor xTEMPB, xTEMPB
        jmp $JTARGET
    case FTDL CfTDL
      code
        $LD_IMMEDIATE_A
        movq xTEMPA, rTEMPA
        mov$VECFMT xTEMPB, $B
        movq rTEMPA, xTEMPA
        cmp rTEMPA, 0
        jne .pass
        xor rTEMPA, rTEMPA
        xor rTEMPC, rTEMPC
        pxor xTEMPA, xTEMPA
        pxor xTEMPB, xTEMPB
        jmp $NEXT_INSTRUCTION
        .pass:
        xor rTEMPA, rTEMPA
        xor rTEMPC, rTEMPC
        pxor xTEMPA, xTEMPA
        pxor xTEMPB, xTEMPB
        jmp $JTARGET

instruction cpuclocks
  code
    rdtsc
    shl rTEMPD, 32
    or rTEMPA, rTEMPD
    mov fs:[context.diagnostic_out+0 + random_const_FS], rTEMPA
    xor rTEMPA, rTEMPA
    xor rTEMPD, rTEMPD
    jmp $NEXT_INSTRUCTION

typespec stash-addr
  select-operand
    case s-addr1 stash-addr1
      value addr1
    case s-addr2 stash-addr2
      value addr2
    case s-addr3 stash-addr3
      value addr3
    case s-addr4 stash-addr4
      value addr4
  pick Sa

typespec stash-item
  select-operand
    case sa sA
      value al
    case sb sB
      value bl
    case sc sC
      value cl
    case sd sD
      value dl
    case se sE
      value el
    
    case sf sF
      value fl
    case sg sG
      value gl
    case sh sH
      value hl
    case si sI
      value il
    case sj sJ
      value jl

    case sk sK
      value kl
    case sl sL
      value ll
    case sm sM
      value ml
    case sn sN
      value nl
    case so sO
      value ol

    case sp sP
      value pl
    case sq sQ
      value ql
    case sr sR
      value rl
    case ss sS
      value sl
    case st sT
      value tl

    case su sU
      value ul
    case sv sV
      value vl
    case sw sW
      value wl
    case sx sX
      value xl
    case sy sY
      value yl
    case sz sZ
      value zl
  pick Si

typespec stash-item-low
  select-operand
    case sal sAl
      value al
    case sbl sBl
      value bl
    case scl sCl
      value cl
    case sdl sDl
      value dl
    case sel sEl
      value el
    
    case sfl sFl
      value fl
    case sgl sGl
      value gl
    case shl sHl
      value hl
    case sil sIl
      value il
    case sjl sJl
      value jl

    case skl sKl
      value kl
    case sll sLl
      value ll
    case sml sMl
      value ml
    case snl sNl
      value nl
    case sol sOl
      value ol

    case spl sPl
      value pl
    case sql sQl
      value ql
    case srl sRl
      value rl
    case ssl sSl
      value sl
    case stl sTl
      value tl

    case sul sUl
      value ul
    case svl sVl
      value vl
    case swl sWl
      value wl
    case sxl sXl
      value xl
    case syl sYl
      value yl
    case szl sZl
      value zl
  pick Sil

typespec stash-item-high
  select-operand
    case sah sAh
      value ah
    case sbh sBh
      value bh
    case sch sCh
      value ch
    case sdh sDh
      value dh
    case seh sEh
      value eh
    
    case sfh sFh
      value fh
    case sgh sGh
      value gh
    case shh sHh
      value hh
    case sih sIh
      value ih
    case sjh sJh
      value jh

    case skh sKh
      value kh
    case slh sLh
      value lh
    case smh sMh
      value mh
    case snh sNh
      value nh
    case soh sOh
      value oh

    case sph sPh
      value ph
    case sqh sQh
      value qh
    case srh sRh
      value rh
    case ssh sSh
      value sh
    case sth sTh
      value th

    case suh sUh
      value uh
    case svh sVh
      value vh
    case swh sWh
      value wh
    case sxh sXh
      value xh
    case syh sYh
      value yh
    case szh sZh
      value zh
  pick Sih

instruction stash
  composite 16 permute-code no-duplicates
    opt-operand
      select-operand
        case swap
          pick W
    operand
      type data xmmx address stash-addr stash-item stash-item-low stash-item-high
      $DEST $VALUE
    operand
      type data xmmx address stash-addr stash-item stash-item-low stash-item-high
      $SRC $VALUE
    select-template
      case SiD SilD SihD
        code
          mov gs:[microcontext.$DEST+random_const_GS], $SRC
      case DSi DSil DSih
        code
          mov $DEST, gs:[microcontext.$SRC+random_const_GS]
      case SilX SihX
        code
          movq gs:[microcontext.$DEST+random_const_GS], $SRC
      case XSil XSih
        code
          movq $DEST, gs:[microcontext.$SRC+random_const_GS]
      case SiX
        code
          movdqu gs:[microcontext.$DEST+random_const_GS], $SRC
      case XSi
        code
          movdqu $DEST, gs:[microcontext.$SRC+random_const_GS]
      case SiSi
        code
          movdqu xTEMPA, gs:[microcontext.$SRC+random_const_GS]
          movdqu gs:[microcontext.$DEST+random_const_GS], xTEMPA
          pxor xTEMPA, xTEMPA
      case SilSil SilSih SihSil SihSih SilSi SihSi SiSil SiSih
        code
          mov rTEMPA, gs:[microcontext.$SRC+random_const_GS]
          mov gs:[microcontext.$DEST+random_const_GS], rTEMPA
          xor rTEMPA, rTEMPA
      case WSiD WSilD WSihD
        code
          xchg gs:[microcontext.$DEST+random_const_GS], $SRC
      case WDSi WDSil WDSih
        code
          xchg $DEST, gs:[microcontext.$SRC+random_const_GS]
      case WSilX WSihX
        code
          movq xTEMPA, $SRC
          movq $SRC, gs:[microcontext.$DEST+random_const_GS]
          movq gs:[microcontext.$DEST+random_const_GS], xTEMPA
          pxor xTEMPA, xTEMPA
      case WXSil WXSih
        code
          movq xTEMPA, $DEST
          movq $DEST, gs:[microcontext.$SRC+random_const_GS]
          movq gs:[microcontext.$SRC+random_const_GS], xTEMPA
          pxor xTEMPA, xTEMPA
      case WSiX
        code
          movdqu xTEMPA, $SRC
          movdqu $SRC, gs:[microcontext.$DEST+random_const_GS]
          movdqu gs:[microcontext.$DEST+random_const_GS], xTEMPA
          pxor xTEMPA, xTEMPA
      case WXSi
        code
          movdqu xTEMPA, $DEST
          movdqu $DEST, gs:[microcontext.$SRC+random_const_GS]
          movdqu gs:[microcontext.$SRC+random_const_GS], xTEMPA
          pxor xTEMPA, xTEMPA
      case WSiSi
        code
          movdqu xTEMPA, gs:[microcontext.$SRC+random_const_GS]
          movdqu xTEMPB, gs:[microcontext.$DEST+random_const_GS]
          movdqu gs:[microcontext.$SRC+random_const_GS], xTEMPB
          movdqu gs:[microcontext.$DEST+random_const_GS], xTEMPA
          pxor xTEMPA, xTEMPA
          pxor xTEMPB, xTEMPB
      case WSilSil WSilSih WSihSil WSihSih WSilSi WSihSi WSiSil WSiSih
        code
          mov rTEMPA, gs:[microcontext.$SRC+random_const_GS]
          xchg rTEMPA, gs:[microcontext.$DEST+random_const_GS]
          mov gs:[microcontext.$SRC+random_const_GS], rTEMPA
          xor rTEMPA, rTEMPA
      case SaA
        code
          mov rTEMPA, fs:[$CONTEXT_ADDR + random_const_FS]
          mov gs:[microcontext.$DEST+random_const_GS], rTEMPA
          negate rTEMPA
          add rTEMPA, $SRC
          mov dword gs:[microcontext.$DEST+20+random_const_GS], %[$SRC]_32
          mov rTEMPC, fs:[$CTX_ELEMENT_BOUND + random_const_FS]
          mov gs:[microcontext.$DEST+8+random_const_GS], rTEMPC
          mov rTEMPD_32, dword fs:[$CTX_MEMBLOCK_INDEX + random_const_FS]
          mov dword gs:[microcontext.$DEST+16+random_const_GS], rTEMPD_32
          xor rTEMPA, rTEMPA
          xor rTEMPC, rTEMPC
          xor rTEMPD, rTEMPD
      case ASa
        code
          mov rTEMPA, gs:[microcontext.$SRC+random_const_GS]
          mov fs:[$CONTEST_ADDR + random_const_FS]
          mov $DEST, rTEMPA
          add $DEST, dword gs:[microcontext.$SRC+20+random_const_GS]
          mov rTEMPC, gs:[microcontext.$SRC+8+random_const_GS]
          mov fs:[$CTX_ELEMENT_BOUND + random_const_FS], rTEMPC
          mov rTEMPD_32, dword gs:[microcontext.$SRC+16+random_const_GS]
          mov dword fs:[$CTX_MEMBLOCK_INDEX + random_const_FS], rTEMPD_16
          xor rTEMPA, rTEMPA
          xor rTEMPC, rTEMPC
          xor rTEMPD, rTEMPD
  code
    jmp $NEXT_INSTRUCTION

instruction lwcall
  operand
    type branch
    $JTARGET $VALUE
    scramble rTEMPC $LD_RETURN_TARGET $COMMAND_INDEX_NEXT
  code
    $LD_RETURN_TARGET
    cmp rLWCSI, lwcall_stack_max
    errorge STATUS_STACK_OVERFLOW
    mov rTEMPA, rLWCSI
    shl rTEMPA, 2
    add rTEMPA, fs:[context.lwcall_stack_address + random_const_FS]
    mov dword [rTEMPA], rTEMPC_32
    inc rLWCSI
    xor rTEMPA, rTEMPA
    xor rTEMPC, rTEMPC
    jmp $JTARGET

instruction lwreturn
  code
    cmp rLWCSI_16, fs:[context.lwcall_floor + random_const_FS]
    errorle STATUS_STACK_UNDERFLOW
    dec rLWCSI
    mov rMAPPER, rLWCSI
    shl rMAPPER, 2
    add rMAPPER, fs:[context.lwcall_stack_address + random_const_FS]
    mov rMAPPER_32, [rMAPPER]
    ;cmp rMAPPER, fs:[context.instruction_count + random_const_FS]
    ;errorge STATUS_ROGUE_BRANCH
    shl rMAPPER, 3
    add rMAPPER, fs:[context.program_map + random_const_FS]
    jmp [rMAPPER]

instruction mctxpush
  code
    cmp rMCSI, 65535
    errorge STATUS_STACK_OVERFLOW
    inc rMCSI_16
    movzx rTEMPA, rMCSI_16
    shl rTEMPA, microcontext_size_bits
    add rTEMPA, fs:[context.microcontext_stack_address + random_const_FS]
    sub rTEMPA, random_const_GS
    wrgsbase rTEMPA
    xor rTEMPA, rTEMPA
    jmp $NEXT_INSTRUCTION

instruction mctxpop
  code
    cmp rMCSI_16, word fs:[context.microcontext_floor + random_const_FS]
    errorle STATUS_STACK_UNDERFLOW
    dec rMCSI_16
    movzx rTEMPA, rMCSI_16
    shl rTEMPA, microcontext_size_bits
    add rTEMPA, fs:[context.microcontext_stack_address + random_const_FS]
    sub rTEMPA, random_const_GS
    wrgsbase rTEMPA
    xor rTEMPA, rTEMPA
    jmp $NEXT_INSTRUCTION

instruction mctxjump
  operand
    type data const integer
    $TARGET $VALUE
    scramble rTEMPA $LD_IMMEDIATE_TARGET
  select-template
    case D
      code
        mov rTEMPA, $TARGET
        mov rTEMPC_32, dword fs:[context.microcontext_floor + random_const_FS]
        add rTEMPA, rTEMPC
        cmp rTEMPA, rTEMPC
        errorlt STATUS_STACK_UNDERFLOW
        cmp rTEMPA, microcontext_stack_size
        errorgt STATUS_STACK_OVERFLOW
        mov rMCSI, rTEMPA
        shl rTEMPA, microcontext_size_bits
        add rTEMPA, fs:[context.microcontext_stack_address + random_const_FS]
        sub rTEMPA, random_const_GS
        wrgsbase rTEMPA
        xor rTEMPA, rTEMPA
        xor rTEMPC, rTEMPC
        jmp $NEXT_INSTRUCTION
    case I C
      code
        $LD_IMMEDIATE_TARGET
        mov rTEMPC_32, dword fs:[context.microcontext_floor + random_const_FS]
        add rTEMPA, rTEMPC
        cmp rTEMPA, rTEMPC
        errorlt STATUS_STACK_UNDERFLOW
        cmp rTEMPA, microcontext_stack_size
        errorgt STATUS_STACK_OVERFLOW
        mov rMCSI, rTEMPA
        shl rTEMPA, microcontext_size_bits
        add rTEMPA, fs:[context.microcontext_stack_address + random_const_FS]
        sub rTEMPA, random_const_GS
        wrgsbase rTEMPA
        xor rTEMPA, rTEMPA
        xor rTEMPC, rTEMPC
        jmp $NEXT_INSTRUCTION

instruction tvmpush
  operand
    type data const integer
    $PROG_HANDLE $VALUE
    scramble rMAPPER $LD_IMMEDIATE_PROG_HANDLE
  operand
    type data const integer
    $FUNC_HANDLE $VALUE
    scramble rTEMPA $LD_IMMEDIATE_FUNC_HANDLE
  select-template
    case DD
      code
        mov rTEMPC, fs:[context.stack + random_const_FS]
        mov rTEMPA, [rTEMPC + tactyk_stack.stack_lock]
        cmp rTEMPA, 0
        errorneq STATUS_INVALID_TVMJUMP_STATE
        mov qword [rTEMPC + tactyk_stack.stack_lock], 1
        mov rTEMPA, [rTEMPC + tactyk_stack.stack_position]
        inc rTEMPA
        cmp rTEMPA, stacksize
        errorge STATUS_STACK_OVERFLOW
        mov [rTEMPC + tactyk_stack.stack_position], rTEMPA

        ; rTEMPC -> stack entry pointer
        imul rTEMPA, tvmstackentry_size
        add rTEMPC, tactyk_stack.stack
        add rTEMPC, rTEMPA
        
        mov rTEMPA, fs:[context.floor + random_const_FS]
        mov rMAPPER, fs:[context.program_map + random_const_FS]
        mov [rTEMPC + tvmstackentry.source_program], rMAPPER
        mov [rTEMPC + tvmstackentry.source_stack_floor], rTEMPA
        mov rTEMPD_32, fs:[context.instruction_count + random_const_FS]
        mov [rTEMPC + tvmstackentry.source_max_iptr], rTEMPD_32
        mov rTEMPD, fs:[context.memblocks + random_const_FS]
        mov [rTEMPC + tvmstackentry.source_memblocks], rTEMPD
        mov rTEMPD, fs:[context.memblocks_count + random_const_FS]
        mov [rTEMPC + tvmstackentry.source_memblocks_count], rTEMPD
        
        mov rMAPPER, $PROG_HANDLE
        mov rTEMPA, $FUNC_HANDLE
        
        ; validate $PROG_HANDLE
        cmp rMAPPER, 0
        errorlt STATUS_INVALID_TVMJUMP
        mov rTEMPD, fs:[context.vm + random_const_FS]
        cmp rMAPPER, [rTEMPD + tactyk_vm.program_count]
        errorge STATUS_INVALID_TVMJUMP
        
        ; rTEMPD -> program declaration
        mov rTEMPD, [rTEMPD + tactyk_vm.program_list]
        imul rMAPPER, program_dec_size
        add rTEMPD, rMAPPER
        
        ; validate $FUNC_HANDLE
        cmp rTEMPA, 0
        errorlt STATUS_INVALID_TVMJUMP
        cmp rTEMPA, [rTEMPD + program_dec.function_count]
        errorge STATUS_INVALID_TVMJUMP
        mov [rTEMPC + tvmstackentry.target_jump_index], rTEMPA_32
        
        ; obtain target jump tables.
        mov rTEMPA, [rTEMPD + program_dec.instruction_jumptable]
        mov rMAPPER, [rTEMPD + program_dec.function_jumptable]
        mov [rTEMPC + tvmstackentry.target_program], rTEMPA
        mov [rTEMPC + tvmstackentry.target_function_jumptable], rMAPPER
        mov rTEMPA, [rTEMPD + program_dec.instruction_count]
        mov [rTEMPC + tvmstackentry.dest_max_iptr], rTEMPA_32
        mov rTEMPA, [rTEMPD + program_dec.memblocks]
        mov [rTEMPC + tvmstackentry.target_memblocks], rTEMPA
        mov rTEMPA, [rTEMPD + program_dec.memblocks_count]
        mov [rTEMPC + tvmstackentry.target_memblocks_count], rTEMPA
        
        xor rTEMPA, rTEMPA
        xor rTEMPC, rTEMPC
        xor rTEMPD, rTEMPD
        xor rMAPPER, rMAPPER
        
        ; the only thing missing here is the return index (not avaialble until the actual jump).
        jmp $NEXT_INSTRUCTION
    
    case II IC CI CC
      code
        mov rTEMPC, fs:[context.stack + random_const_FS]
        mov rTEMPA, [rTEMPC + tactyk_stack.stack_lock]
        cmp rTEMPA, 0
        errorneq STATUS_INVALID_TVMJUMP_STATE
        mov qword [rTEMPC + tactyk_stack.stack_lock], 1
        mov rTEMPA, [rTEMPC + tactyk_stack.stack_position]
        inc rTEMPA
        cmp rTEMPA, stacksize
        errorge STATUS_STACK_OVERFLOW
        mov [rTEMPC + tactyk_stack.stack_position], rTEMPA

        ; rTEMPC -> stack entry pointer
        imul rTEMPA, tvmstackentry_size
        add rTEMPC, tactyk_stack.stack
        add rTEMPC, rTEMPA
        
        mov rTEMPA, fs:[context.floor + random_const_FS]
        mov rMAPPER, fs:[context.program_map + random_const_FS]
        mov [rTEMPC + tvmstackentry.source_program], rMAPPER
        mov [rTEMPC + tvmstackentry.source_stack_floor], rTEMPA
        mov rTEMPD_32, fs:[context.instruction_count + random_const_FS]
        mov [rTEMPC + tvmstackentry.source_max_iptr], rTEMPD_32
        mov rTEMPD, fs:[context.memblocks + random_const_FS]
        mov [rTEMPC + tvmstackentry.source_memblocks], rTEMPD
        mov rTEMPD, fs:[context.memblocks_count + random_const_FS]
        mov [rTEMPC + tvmstackentry.source_memblocks_count], rTEMPD
        
        $LD_IMMEDIATE_PROG_HANDLE
        $LD_IMMEDIATE_FUNC_HANDLE
        
        ; validate $PROG_HANDLE
        cmp rMAPPER, 0
        errorlt STATUS_INVALID_TVMJUMP
        mov rTEMPD, fs:[context.vm + random_const_FS]
        cmp rMAPPER, [rTEMPD + tactyk_vm.program_count]
        errorge STATUS_INVALID_TVMJUMP
        
        ; rTEMPD -> program declaration
        mov rTEMPD, [rTEMPD + tactyk_vm.program_list]
        imul rMAPPER, program_dec_size
        add rTEMPD, rMAPPER
        
        ; validate $FUNC_HANDLE
        cmp rTEMPA, 0
        errorlt STATUS_INVALID_TVMJUMP
        cmp rTEMPA, [rTEMPD + program_dec.function_count]
        errorge STATUS_INVALID_TVMJUMP
        mov [rTEMPC + tvmstackentry.target_jump_index], rTEMPA_32
        
        ; obtain target jump tables.
        mov rTEMPA, [rTEMPD + program_dec.instruction_jumptable]
        mov rMAPPER, [rTEMPD + program_dec.function_jumptable]
        mov [rTEMPC + tvmstackentry.target_program], rTEMPA
        mov [rTEMPC + tvmstackentry.target_function_jumptable], rMAPPER
        mov rTEMPA, [rTEMPD + program_dec.instruction_count]
        mov [rTEMPC + tvmstackentry.dest_max_iptr], rTEMPA_32
        mov rTEMPA, [rTEMPD + program_dec.memblocks]
        mov [rTEMPC + tvmstackentry.target_memblocks], rTEMPA
        mov rTEMPA, [rTEMPD + program_dec.memblocks_count]
        mov [rTEMPC + tvmstackentry.target_memblocks_count], rTEMPA
        
        xor rTEMPA, rTEMPA
        xor rTEMPC, rTEMPC
        xor rTEMPD, rTEMPD
        xor rMAPPER, rMAPPER
        
        ; the only thing missing here is the return index (not avaialble until the actual jump).
        jmp $NEXT_INSTRUCTION
    
    case DI DC
      code
        mov rTEMPC, fs:[context.stack + random_const_FS]
        mov rTEMPA, [rTEMPC + tactyk_stack.stack_lock]
        cmp rTEMPA, 0
        errorneq STATUS_INVALID_TVMJUMP_STATE
        mov qword [rTEMPC + tactyk_stack.stack_lock], 1
        mov rTEMPA, [rTEMPC + tactyk_stack.stack_position]
        inc rTEMPA
        cmp rTEMPA, stacksize
        errorge STATUS_STACK_OVERFLOW
        mov [rTEMPC + tactyk_stack.stack_position], rTEMPA

        ; rTEMPC -> stack entry pointer
        imul rTEMPA, tvmstackentry_size
        add rTEMPC, tactyk_stack.stack
        add rTEMPC, rTEMPA
        
        mov rTEMPA, fs:[context.floor + random_const_FS]
        mov rMAPPER, fs:[context.program_map + random_const_FS]
        mov [rTEMPC + tvmstackentry.source_program], rMAPPER
        mov [rTEMPC + tvmstackentry.source_stack_floor], rTEMPA
        mov rTEMPD_32, fs:[context.instruction_count + random_const_FS]
        mov [rTEMPC + tvmstackentry.source_max_iptr], rTEMPD_32
        mov rTEMPD, fs:[context.memblocks + random_const_FS]
        mov [rTEMPC + tvmstackentry.source_memblocks], rTEMPD
        mov rTEMPD, fs:[context.memblocks_count + random_const_FS]
        mov [rTEMPC + tvmstackentry.source_memblocks_count], rTEMPD
        
        $LD_IMMEDIATE_FUNC_HANDLE
        mov rMAPPER, $PROG_HANDLE
        
        ; validate $PROG_HANDLE
        cmp rMAPPER, 0
        errorlt STATUS_INVALID_TVMJUMP
        mov rTEMPD, fs:[context.vm + random_const_FS]
        cmp rMAPPER, [rTEMPD + tactyk_vm.program_count]
        errorge STATUS_INVALID_TVMJUMP
        
        ; rTEMPD -> program declaration
        mov rTEMPD, [rTEMPD + tactyk_vm.program_list]
        imul rMAPPER, program_dec_size
        add rTEMPD, rMAPPER
        
        ; validate $FUNC_HANDLE
        cmp rTEMPA, 0
        errorlt STATUS_INVALID_TVMJUMP
        cmp rTEMPA, [rTEMPD + program_dec.function_count]
        errorge STATUS_INVALID_TVMJUMP
        mov [rTEMPC + tvmstackentry.target_jump_index], rTEMPA_32
        
        ; obtain target jump tables.
        mov rTEMPA, [rTEMPD + program_dec.instruction_jumptable]
        mov rMAPPER, [rTEMPD + program_dec.function_jumptable]
        mov [rTEMPC + tvmstackentry.target_program], rTEMPA
        mov [rTEMPC + tvmstackentry.target_function_jumptable], rMAPPER
        mov rTEMPA, [rTEMPD + program_dec.instruction_count]
        mov [rTEMPC + tvmstackentry.dest_max_iptr], rTEMPA_32
        mov rTEMPA, [rTEMPD + program_dec.memblocks]
        mov [rTEMPC + tvmstackentry.target_memblocks], rTEMPA
        mov rTEMPA, [rTEMPD + program_dec.memblocks_count]
        mov [rTEMPC + tvmstackentry.target_memblocks_count], rTEMPA
        
        xor rTEMPA, rTEMPA
        xor rTEMPC, rTEMPC
        xor rTEMPD, rTEMPD
        xor rMAPPER, rMAPPER
        
        ; the only thing missing here is the return index (not avaialble until the actual jump).
        jmp $NEXT_INSTRUCTION
    
    case ID CD
      code
        mov rTEMPC, fs:[context.stack + random_const_FS]
        mov rTEMPA, [rTEMPC + tactyk_stack.stack_lock]
        cmp rTEMPA, 0
        errorneq STATUS_INVALID_TVMJUMP_STATE
        mov qword [rTEMPC + tactyk_stack.stack_lock], 1
        mov rTEMPA, [rTEMPC + tactyk_stack.stack_position]
        inc rTEMPA
        cmp rTEMPA, stacksize
        errorge STATUS_STACK_OVERFLOW
        mov [rTEMPC + tactyk_stack.stack_position], rTEMPA

        ; rTEMPC -> stack entry pointer
        imul rTEMPA, tvmstackentry_size
        add rTEMPC, tactyk_stack.stack
        add rTEMPC, rTEMPA
        
        mov rTEMPA, fs:[context.floor + random_const_FS]
        mov rMAPPER, fs:[context.program_map + random_const_FS]
        mov [rTEMPC + tvmstackentry.source_program], rMAPPER
        mov [rTEMPC + tvmstackentry.source_stack_floor], rTEMPA
        mov rTEMPD_32, fs:[context.instruction_count + random_const_FS]
        mov [rTEMPC + tvmstackentry.source_max_iptr], rTEMPD_32
        mov rTEMPD, fs:[context.memblocks + random_const_FS]
        mov [rTEMPC + tvmstackentry.source_memblocks], rTEMPD
        mov rTEMPD, fs:[context.memblocks_count + random_const_FS]
        mov [rTEMPC + tvmstackentry.source_memblocks_count], rTEMPD
        
        $LD_IMMEDIATE_PROG_HANDLE
        mov rTEMPA, $FUNC_HANDLE
        
        ; validate $PROG_HANDLE
        cmp rMAPPER, 0
        errorlt STATUS_INVALID_TVMJUMP
        mov rTEMPD, fs:[context.vm + random_const_FS]
        cmp rMAPPER, [rTEMPD + tactyk_vm.program_count]
        errorge STATUS_INVALID_TVMJUMP
        
        ; rTEMPD -> program declaration
        mov rTEMPD, [rTEMPD + tactyk_vm.program_list]
        imul rMAPPER, program_dec_size
        add rTEMPD, rMAPPER
        
        ; validate $FUNC_HANDLE
        cmp rTEMPA, 0
        errorlt STATUS_INVALID_TVMJUMP
        cmp rTEMPA, [rTEMPD + program_dec.function_count]
        errorge STATUS_INVALID_TVMJUMP
        mov [rTEMPC + tvmstackentry.target_jump_index], rTEMPA_32
        
        ; obtain target jump tables.
        mov rTEMPA, [rTEMPD + program_dec.instruction_jumptable]
        mov rMAPPER, [rTEMPD + program_dec.function_jumptable]
        mov [rTEMPC + tvmstackentry.target_program], rTEMPA
        mov [rTEMPC + tvmstackentry.target_function_jumptable], rMAPPER
        mov rTEMPA, [rTEMPD + program_dec.instruction_count]
        mov [rTEMPC + tvmstackentry.dest_max_iptr], rTEMPA_32
        mov rTEMPA, [rTEMPD + program_dec.memblocks]
        mov [rTEMPC + tvmstackentry.target_memblocks], rTEMPA
        mov rTEMPA, [rTEMPD + program_dec.memblocks_count]
        mov [rTEMPC + tvmstackentry.target_memblocks_count], rTEMPA
        
        xor rTEMPA, rTEMPA
        xor rTEMPC, rTEMPC
        xor rTEMPD, rTEMPD
        xor rMAPPER, rMAPPER
        
        ; the only thing missing here is the return index (not avaialble until the actual jump).
        jmp $NEXT_INSTRUCTION
instruction tvmjump
  $KW dword
  scramble rTEMPA $LD_CMDNEXT_IMMEDIATE $COMMAND_INDEX_NEXT
  code
    mov dword fs:[context.lwcall_floor + random_const_FS], rLWCSI_32
    mov dword fs:[context.microcontext_floor + random_const_FS], rMCSI_32
    
    mov rTEMPC, fs:[context.stack + random_const_FS]
    mov rTEMPA, [rTEMPC + tactyk_stack.stack_lock]
    cmp rTEMPA, 1
    errorneq STATUS_INVALID_TVMJUMP_STATE
    
    mov qword [rTEMPC + tactyk_stack.stack_lock], 0
    mov rTEMPA, [rTEMPC + tactyk_stack.stack_position]
    
    ; rTEMPC -> stack entry pointer
    imul rTEMPA, tvmstackentry_size
    add rTEMPC, tactyk_stack.stack
    add rTEMPC, rTEMPA
    
    $LD_CMDNEXT_IMMEDIATE
    mov [rTEMPC + tvmstackentry.source_return_index], rTEMPA_32
    mov [rTEMPC + tvmstackentry.source_lwcallstack_position], rLWCSI_32
    mov [rTEMPC + tvmstackentry.source_mctxstack_position], rMCSI_32

    ; load the target context
    mov rTEMPA, [rTEMPC + tvmstackentry.target_program]
    mov fs:[context.program_map + random_const_FS], rTEMPA
    mov rTEMPA_32, [rTEMPC + tvmstackentry.dest_max_iptr]
    mov fs:[context.instruction_count + random_const_FS], rTEMPA
    mov rTEMPA, [rTEMPC + tvmstackentry.target_memblocks]
    mov fs:[context.memblocks + random_const_FS], rTEMPA
    mov rTEMPA, [rTEMPC + tvmstackentry.target_memblocks_count]
    mov fs:[context.memblocks_count + random_const_FS], rTEMPA
    
    ; prepare the jump
    mov rMAPPER_32, [rTEMPC + tvmstackentry.target_jump_index]
    shl rMAPPER, 3
    add rMAPPER, [rTEMPC + tvmstackentry.target_function_jumptable]
    
    ; go!
    xor rTEMPA, rTEMPA
    xor rTEMPC, rTEMPC
    jmp [rMAPPER]

instruction tvmreturn
  code
    mov rTEMPC, fs:[context.stack + random_const_FS]
    mov rTEMPA, [rTEMPC + tactyk_stack.stack_lock]
    cmp rTEMPA, 0
    errorneq STATUS_INVALID_TVMJUMP_STATE
    mov rTEMPA, [rTEMPC + tactyk_stack.stack_position]
    cmp rTEMPA, 0
    errorlt STATUS_STACK_UNDERFLOW
    mov rTEMPD, rTEMPA
    dec rTEMPA
    mov [rTEMPC + tactyk_stack.stack_position], rTEMPA
    
    ; rTEMPC -> stack entry pointer
    imul rTEMPD, tvmstackentry_size
    add rTEMPC, tactyk_stack.stack
    add rTEMPC, rTEMPD
    
    ; restore the caller context
    mov rTEMPD, [rTEMPC + tvmstackentry.source_stack_floor]
    mov fs:[context.floor + random_const_FS], rTEMPD
    mov rLWCSI_32, [rTEMPC + tvmstackentry.source_lwcallstack_position]
    mov rMCSI_32, [rTEMPC + tvmstackentry.source_mctxstack_position]
    mov rMAPPER, [rTEMPC + tvmstackentry.source_program]
    mov fs:[context.program_map + random_const_FS], rMAPPER
    mov rTEMPA_32, [rTEMPC + tvmstackentry.source_max_iptr]
    mov fs:[context.instruction_count + random_const_FS], rTEMPA
    mov rTEMPA, [rTEMPC + tvmstackentry.source_memblocks]
    mov fs:[context.memblocks + random_const_FS], rTEMPA
    mov rTEMPA, [rTEMPC + tvmstackentry.source_memblocks_count]
    mov fs:[context.memblocks_count + random_const_FS], rTEMPA
    
    ; prepare a return jump
    mov rTEMPA_32, [rTEMPC + tvmstackentry.source_return_index]
    shl rTEMPA, 3
    add rMAPPER, rTEMPA

    ; MAYBE zero out the stack entry - this doesn't seem to be needed, as the most exploitable case that came up in testing
    ; does not differ from what can be accomplished through ordinary means.
    ; mov qword [rTEMPC + tvmstackentry.source_program], 0
    ; mov qword [rTEMPC + tvmstackentry.source_exec_position], 0
    ; mov qword [rTEMPC + tvmstackentry.source_stack_floor], 0
    ; mov qword [rTEMPC + tvmstackentry.target_program], 0
    ; mov qword [rTEMPC + tvmstackentry.target_function_jumptable], 0
    ; mov qword [rTEMPC + tvmstackentry.target_exec_position], 0
    
    xor rTEMPA, rTEMPA
    xor rTEMPC, rTEMPC
    xor rTEMPD, rTEMPD
    jmp [rMAPPER]

typespec vec-float-format
  $VECFMT sd
  select-operand
    case pd PD
      $VECFMT pd
    case ps PS
      $VECFMT ps
    case sd SD
      $VECFMT sd
    case ss SS
      $VECFMT ss

typespec xmmx
  select-operand
    case x0 xmm0 xa xA
      value xmm0
    case x1 xmm1 xb xB
      value xmm1
    case x2 xmm2 xc xC
      value xmm2
    case x3 xmm3 xd xD
      value xmm3
    case x4 xmm4 xe xE
      value xmm4
    case x5 xmm5 xf xF
      value xmm5
    case x6 xmm6 xg xG
      value xmm6
    case x7 xmm7 xh xH
      value xmm7
    case x8 xmm8 xi xI
      value xmm8
    case x9 xmm9 xj xJ
      value xmm9
    case x10 xmm10 xk xK
      value xmm10
    case x11 xmm11 xl xL
      value xmm11
    case x12 xmm12 xm xM
      value xmm12
    case x13 xmm13 xn xN
      value xmm13
  pick X
