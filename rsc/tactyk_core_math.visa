subroutine unary_fpu_instruction
  operand
    type xmmx
    $A $VALUE
  opt-operand
    type xmmx
    $B $VALUE
  select-template
    case X
      code
        movq fs:[context.fpu_b + random_const_FS], $A
        fld qword fs:[context.fpu_b + random_const_FS]
        $INSTRUCTION
        fstp qword fs:[context.fpu_a + random_const_FS]
        movq $A, fs:[context.fpu_a + random_const_FS]
        jmp $NEXT_INSTRUCTION
    case XX
      code
        movq fs:[context.fpu_b + random_const_FS], $B
        fld qword fs:[context.fpu_b + random_const_FS]
        $INSTRUCTION
        fstp qword fs:[context.fpu_a + random_const_FS]
        movq $A, fs:[context.fpu_a + random_const_FS]
        jmp $NEXT_INSTRUCTION

subroutine unary_fpu_instruction__pop1first
  operand
    type xmmx
    $A $VALUE
  opt-operand
    type xmmx
    $B $VALUE
  select-template
    case X
      code
        movq fs:[context.fpu_b + random_const_FS], $A
        fld qword fs:[context.fpu_b + random_const_FS]
        $INSTRUCTION
        fstp st0
        fstp qword fs:[context.fpu_a + random_const_FS]
        movq $A, fs:[context.fpu_a + random_const_FS]
        jmp $NEXT_INSTRUCTION
    case XX
      code
        movq fs:[context.fpu_b + random_const_FS], $B
        fld qword fs:[context.fpu_b + random_const_FS]
        $INSTRUCTION
        fstp st0
        fstp qword fs:[context.fpu_a + random_const_FS]
        movq $A, fs:[context.fpu_a + random_const_FS]
        jmp $NEXT_INSTRUCTION

# compute sine of X
#   If two operands (A,B), compute sine(B) and store the result in register A
#   If one operand (A), compute sine(A) and replace the value on register A with the result
instruction sine
  $INSTRUCTION fsin
  sub unary_fpu_instruction

# compute cosine of X
#   If two operands (A,B), compute cosine(B) and store the result in register A
#   If one operand (A), compute cosine(A) and replace the value on register A with the result
instruction cosine
  $INSTRUCTION fcos
  sub unary_fpu_instruction

# compute tangent of X
#   If two operands (A,B), compute tangent(B) and store the result in register A
#   If one operand (A), compute tangent(A) and replace the value on register A with the result
instruction tangent
  $INSTRUCTION fptan
  sub unary_fpu_instruction__pop1first

# Compute arctangent of X or point (X,Y)
#   if three operands, (T, X,Y), compute arctangent(X,Y) and store the result on register T
#     ("north-clockwise" convention - because every time I've ever used an atan2() function, my paramters have always been geometric coordinates )
#   if two operands (T, R), compute arctangent(R) and store the result on register T
#   if one operand (R), compute arctangent(R) and replace the value on register R with the result
instruction arctangent
  operand
    type xmmx
    $A $VALUE
  opt-operand
    type xmmx
    $B $VALUE
  opt-operand
    type xmmx
    $C $VALUE
  select-template
    case X
      code
        movq fs:[context.fpu_b + random_const_FS], $A
        fld qword fs:[context.fpu_b + random_const_FS]
        fld1
        fpatan
        fstp qword fs:[context.fpu_a + random_const_FS]
        movq $A, fs:[context.fpu_a + random_const_FS]
        jmp $NEXT_INSTRUCTION
    case XX
      code
        movq fs:[context.fpu_b + random_const_FS], $B
        fld qword fs:[context.fpu_b + random_const_FS]
        fld1
        fpatan
        fstp qword fs:[context.fpu_a + random_const_FS]
        movq $A, fs:[context.fpu_a + random_const_FS]
        jmp $NEXT_INSTRUCTION
    case XXX
      code
        movq fs:[context.fpu_b + random_const_FS], $B
        movq fs:[context.fpu_c + random_const_FS], $C
        fld qword fs:[context.fpu_c + random_const_FS]
        fld qword fs:[context.fpu_b + random_const_FS]
        fpatan
        fstp qword fs:[context.fpu_a + random_const_FS]
        movq $A, fs:[context.fpu_a + random_const_FS]
        jmp $NEXT_INSTRUCTION

# compute log-base2 of X
#   If two operands (A,B), compute log2(B) and store in register A
#   If one operand (A), compute log2(A) and replace value on register A
instruction log2
  $INSTRUCTION fyl2x
  # note:  code auto-concatenation is used to inject ASM for pushing a constant on the stack into the otherwise conventional subroutine.
  code
    fld1
  sub unary_fpu_instruction

# compute log-baseN of X
# if three operands (A,B,C), compute log-C(B) and store in register A 
# if two operands (A,B), compute log-B(A) and replace value on register A 
instruction log
  operand
    type xmmx
    $A $VALUE
  operand
    type xmmx
    $B $VALUE
  opt-operand
    type xmmx
    $C $VALUE
  select-template
    case XX
      code
        ; do the RPN thing.
        fld1
        fld1
        movq fs:[context.fpu_c + random_const_FS], $B
        fld qword fs:[context.fpu_c + random_const_FS]
        fyl2x
        fdivp 
        movq fs:[context.fpu_b + random_const_FS], $A
        fld qword fs:[context.fpu_b + random_const_FS]
        fyl2x
        fstp qword fs:[context.fpu_a + random_const_FS]
        movq $A, fs:[context.fpu_a + random_const_FS]
        jmp $NEXT_INSTRUCTION
    case XXX
      code  
        fld1
        fld1
        movq fs:[context.fpu_c + random_const_FS], $C
        fld qword fs:[context.fpu_c + random_const_FS]
        fyl2x
        fdivp 
        movq fs:[context.fpu_b + random_const_FS], $B
        fld qword fs:[context.fpu_b + random_const_FS]
        fyl2x
        fstp qword fs:[context.fpu_a + random_const_FS]
        movq $A, fs:[context.fpu_a + random_const_FS]
        jmp $NEXT_INSTRUCTION

# Compute sine and cosine of X and store both results
#   $DEST_SINE:     xmm register to write the result of sine(X) to
#   $DEST_COSINE:   xmm register to write the result of cosine(X) to
#   $ARG:           xmm register containing argument X
# x87 includes it, so why not?
instruction sine_and_cosine
  operand
    type xmmx
    $DEST_SINE $VALUE
  operand
    type xmmx
    $DEST_COSINE $VALUE
  operand
    type xmmx
    $ARG $VALUE
  select-template
    case XXX
      code
        movq fs:[context.fpu_c + random_const_FS], $ARG
        fld qword fs:[context.fpu_c + random_const_FS]
        fsincos
        fstp qword fs:[context.fpu_a + random_const_FS]
        fstp qword fs:[context.fpu_b + random_const_FS]
        movq $DEST_COSINE, fs:[context.fpu_a + random_const_FS]
        movq $DEST_SINE, fs:[context.fpu_b + random_const_FS]
        jmp $NEXT_INSTRUCTION


typespec compute-op
  $COMPUTE_ARG ;
  select-operand
    # passive functions - these are applied unconditionally to every item loaded by the compute instruction.
    case load
      $COMPUTE_OP fstp
      $COMPUTE_ARG 1
    case add
      $COMPUTE_OP faddp
    case sub
      $COMPUTE_OP fsubp
    case div
      $COMPUTE_OP fdivp
    case mul
      $COMPUTE_OP fmulp
    case ~div
      $COMPUTE_OP fdivrp
    case ~sub
      $COMPUTE_OP fsubrp
    case atan
      $COMPUTE_OP fpatan
    case mod
      $COMPUTE_OP fprem
    
    # apply the passive function using the accumulator vale for both operands 
    case .
      code
        fld st0
        $COMPUTE_OP $COMPUTE_ARG
    
    # immediate functions
    # These have special behavior and dont make much sense to use passively.
    #   (and most of them also don't pop an entry off the stack and thus would require more complications if so used)
    case log2
      code
        fld1
        fxch
        fyl2x
    case sin
      code
        fsin
    case cos
      code
        fcos
    case tan
      code
        ftan
    case sqrt
      code
        fsqrt
    case round
      code
        frndint
    
    # transient variable accessors
    case ->w ->W ->fw ->fW
      code
        fst st1
    case ->x ->X ->fx ->fX
      code
        fst st2
    case ->y ->Y ->fy ->fY
      code
        fst st3
    case ->z ->Z ->fz ->fZ
      code
        fst st4
    case <-w <-W <-fw <-fW
      code
        fld st1
        $COMPUTE_OP $COMPUTE_ARG
    case <-x <-X <-fx <-fX
      code
        fld st2
        $COMPUTE_OP $COMPUTE_ARG
    case <-y <-Y <-fy <-fY
      code
        fld st3
        $COMPUTE_OP $COMPUTE_ARG
    case <-z <-Z <-fz <-fZ
      code
        fld st4
        $COMPUTE_OP $COMPUTE_ARG
    
    # x87 constant loaders
    #   possibly should include the rest if there is 
    case 0
      code
        fldz
        $COMPUTE_OP $COMPUTE_ARG
    case 1
      code
        fld1
        $COMPUTE_OP $COMPUTE_ARG
    case CONST_PI
      code
        fldpi
        $COMPUTE_OP $COMPUTE_ARG
  pick .

instruction compute
  $COMPUTE_OP fstp
  $COMPUTE_ARG ;
  $CMODE norm
  operand
    type xmmx data  stash-item stash-item-low stash-item-high
    $DEST $VALUE
  code
    ffree st0
    fldz
  select-template
    case X
      code $FOOTER
        fstp qword fs:[context.fpu_a + random_const_FS]
        movq $DEST, fs:[context.fpu_a + random_const_FS]
        ffree st0
        jmp $NEXT_INSTRUCTION
    case Si
      code $FOOTER
        fstp tword gs:[microcontext.$DEST+random_const_GS]
        ffree st0
        jmp $NEXT_INSTRUCTION
    case Sil Sih
      code $FOOTER
        fstp qword gs:[microcontext.$DEST+random_const_GS]
        ffree st0
        jmp $NEXT_INSTRUCTION
    case D
      code $FOOTER
        fisttp qword fs:[context.fpu_a + random_const_FS]
        mov $DEST, fs:[context.fpu_a + random_const_FS]
        ffree st0
        jmp $NEXT_INSTRUCTION
  
  composite 16
    operand
      type compute-op xmmx data  stash-item stash-item-low stash-item-high  float fconst integer const
      $SRC $VALUE
      scramble rTEMPC $LD_B_IMMEDIATE
    select-template
      case X
        code
          movq fs:[context.fpu_a + random_const_FS], $SRC
          fld qword fs:[context.fpu_a + random_const_FS]
          $COMPUTE_OP $COMPUTE_ARG
      case Si
        code
          fld tword gs:[microcontext.$SRC+random_const_GS]
      case Sil Sih
        code
          fld qword gs:[microcontext.$SRC+random_const_GS]
      case D
        code
          mov fs:[context.fpu_a + random_const_FS], $SRC
          fild qword fs:[context.fpu_a + random_const_FS]
          $COMPUTE_OP $COMPUTE_ARG
      case I C
        code
          $LD_B_IMMEDIATE
          mov fs:[context.fpu_a + random_const_FS], rTEMPC
          fild qword fs:[context.fpu_a + random_const_FS]
          $COMPUTE_OP $COMPUTE_ARG
      case F Cf
        code
          $LD_B_IMMEDIATE
          mov fs:[context.fpu_a + random_const_FS], rTEMPC
          fld qword fs:[context.fpu_a + random_const_FS]
          $COMPUTE_OP $COMPUTE_ARG
      case .
        # do nothing
  code
    $FOOTER
